<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[中文技术文档写作规范]]></title>
      <url>http://www.lizorn.com//2016/11/06/document-style-guide/</url>
      <content type="text"><![CDATA[国外有非常多优秀的技术文档，黑客也大多擅长写作，无奈墙以及国内外文化差异的原因，总是会让你对文档的理解有或多或少的偏差。而国内技术氛围对敏捷开发理解有误，不重视文档。仅有的技术文档，也是挠痒之作。技术类的书，不管是出自翻译，还是由国内技术人员编写，质量普遍不高。 我一直都觉得：中文博大精深，要写出优秀的作品远比英文要难，尤其是技术文档，会有大量中英文的结合，即使是标点符号的运用都是一件烦恼的事情。最近一直在思考如何写出优秀的技术文档，其实技术文档的规范和编码规范差不多：要语法统一、用词精准、多用短句、不应该存在歧义、同样不应该有坏味道。看到这篇出自阮一峰的《中文技术文档的写作规范》，很有启发。该指导文档比较系统，遂摘录，共勉！ 另附上维基百科的各组织的写作要求写作要求。 标题层级标题分为四级。 一级标题：文章的标题 二级标题：文章主要部分的大标题 三级标题：二级标题下面一级的小标题 四级标题：三级标题下面某一方面的小标题 原则 一级标题下，不能直接出现三级标题。 标题要避免孤立编号（即同级标题只有一个）。 下级标题不重复上一级标题的内容。 谨慎使用四级标题，尽量避免出现，保持层级的简单和防止出现过于复杂的章节。如果三级标题下有并列性的内容，建议只使用项目列表（Item list）。 文本字间距全角中文字符与半角英文字符之间，应有一个半角空格。 123错误：本文介绍如何快速启动Windows系统。正确：本文介绍如何快速启动 Windows 系统。 全角中文字符与半角阿拉伯数字之间，有没有半角空格都可，但必须保证风格统一，不能两种风格混杂。 123正确：2011年5月15日，我订购了5台笔记本电脑与10台平板电脑。正确：2011 年 5 月 15 日，我订购了 5 台笔记本电脑与 10 台平板电脑。 半角的百分号，视同阿拉伯数字。 英文单位若不翻译，单位前的阿拉伯数字与单位间不留空格。 123错误：一部容量为 16 GB 的智能手机正确：一部容量为 16GB 的智能手机 半角英文字符和半角阿拉伯数字，与全角标点符号之间不留空格。 123错误：他的电脑是 MacBook Air 。正确：他的电脑是 MacBook Air。 句子 避免使用长句。一个句子建议不超过 100 字或者正文的 3 行。 尽量使用简单句和并列句，避免使用复合句。 写作风格尽量不使用被动语态，改为使用主动语态。 123错误：假如此软件尚未被安装，正确：假如尚未安装这个软件， 不使用非正式的语言风格。 123错误：Lady Gaga 的演唱会真是酷毙了，从没看过这么给力的表演！！！正确：无法参加本次活动，我深感遗憾。 用对“的”、“地”、“得”。 12345678她露出了开心的笑容。（形容词＋的＋名词）她开心地笑了。（副词＋地＋动词）她笑得很开心。（动词＋得＋副词） 使用代词时（比如“其”、“该”、“此”、“这”等词），必须明确指代的内容，保证只有一个含义。 123错误：从管理系统可以监视中继系统和受其直接控制的分配系统。正确：从管理系统可以监视两个系统：中继系统和受中继系统直接控制的分配系统。 名词前不要使用过多的形式词。 123错误：此设备的使用必须在接受过本公司举办的正式的设备培训的技师的指导下进行。正确：此设备必须在技师的指导下使用，且指导技师必须接受过由本公司举办的正式设备培训。 单个句子的长度尽量保持在 20 个字以内；20～29 个字的句子，可以接受；30～39 个字的句子，语义必须明确，才能接受；多于 40 个字的句子，在任何情况下都不能接受。 123错误：本产品适用于从由一台服务器进行动作控制的单一节点结构到由多台服务器进行动作控制的并行处理程序结构等多种体系结构。正确：本产品适用于多种体系结构。无论是由一台服务器（单一节点结构），还是由多台服务器（并行处理结构）进行动作控制，均可以使用本产品。 同样一个意思，尽量使用肯定句表达，不使用否定句表达。 123错误：请确认没有接通装置的电源。正确：请确认装置的电源已关闭。 避免使用双重否定句。 123错误：没有删除权限的用户，不能删除此文件。正确：用户必须拥有删除权限，才能删除此文件。 英文处理英文原文如果使用了复数形式，翻译成中文时，应该将其还原为单数形式。 123英文：⋯information stored in random access memory (RAMs)⋯中文：……存储在随机存取存储器（RAM）里的信息…… 外文缩写可以使用半角圆点(.)表示缩写。 12U.S.A.Apple, Inc. 表示中文时，英文省略号（⋯）应改为中文省略号（……）。 123英文：5 minutes later⋯中文：5 分钟过去了⋯⋯ 英文书名或电影名改用中文表达时，双引号应改为书名号。 123英文：He published an article entitled &quot;The Future of the Aviation&quot;.中文：他发表了一篇名为《航空业的未来》的文章。 第一次出现英文词汇时，在括号中给出中文标注。此后再次出现时，直接使用英文缩写即可。 1IOC（International Olympic Committee，国际奥林匹克委员会）。这样定义后，便可以直接使用“IOC”了。 专有名词中每个词第一个字母均应大写，非专有名词则不需要大写。 123“American Association of Physicists in Medicine”（美国医学物理学家协会）是专有名词，需要大写。“online transaction processing”（在线事务处理）不是专有名词，不应大写。 段落原则 一个段落只能有一个主题，或一个中心句子。 段落的中心句子放在段首，对全段内容进行概述。后面陈述的句子为核心句服务。 一个段落的长度不能超过七行，最佳段落长度小于等于四行。 段落的句子语气要使用陈述和肯定语气，避免使用感叹语气。 段落之间使用一个空行隔开。 段落开头不要留出空白字符。 引用引用第三方内容时，应注明出处。 1One man’s constant is another man’s variable. — Alan Perlis 如果是全篇转载，请在全文开头显著位置注明作者和出处，并链接至原文。 1本文转载自 WikiQuote 使用外部图片时，必须在图片下方或文末标明来源。 1本文部分图片来自 Wikipedia 数值半角数字数字一律使用半角形式，不得使用全角形式。 123错误： 这件商品的价格是１０００元。正确： 这件商品的价格是 1000 元。 千分号数值为千位以上，应添加千分号（半角逗号）。 1XXX 公司的实收资本为 RMB1,258,000。 对于 4 ～ 6 位的数值，千分号是选用的，比如1000和1,000都可以接受。对于7位及以上的数值，千分号是必须的。 多位小数要从小数点后从左向右添加千分号，比如4.234,345。 货币货币应为阿拉伯数字，并在数字前写出货币符号，或在数字后写出货币中文名称。 12$1,0001,000 美元 数值范围表示数值范围时，用～连接。参见《标点符号》一节的“连接号”部分。 带有单位或百分号时，两个数字都要加上单位或百分号，不能只加后面一个。 12345正确：132kg～234kg错误：132～234kg正确：67%～89%错误：67～89% 变化程度的表示法数字的增加要使用“增加了”、“增加到”。“了”表示增量，“到”表示定量。 12345增加到过去的两倍（过去为一，现在为二）增加了两倍（过去为一，现在为三） 数字的减少要使用“降低了”、“降低到”。“了”表示增量，“到”表示定量。 12345降低到百分之八十（定额是一百，现在是八十）降低了百分之八十（原来是一百，现在是二十） 不能用“降低N倍”或“减少N倍”的表示法，要用“降低百分之几”或“减少百分之几”。因为减少（或降低）一倍表示数值原来为一百，现在等于零。 标点符号原则 中文语句的标点符号，均应该采取全角符号，这样可以保证视觉的一致。 如果整句为英文，则该句使用英文/半角标点。 句号、问号、叹号、逗号、顿号、分号和冒号不得出现在一行之首。 句号中文语句中的结尾处应该用全角句号（。）。 句子末尾用括号加注时，句号应在括号之外。 123错误：关于文件的输出，请参照第 1.3 节（见第 26 页。）正确：关于文件的输出，请参照第 1.3 节（见第 26 页）。 逗号逗号，表示句子内部的一般性停顿。 注意避免“一逗到底”，即整个段落除了结尾，全部停顿都使用逗号。 顿号句子内部的并列词，应该用全角顿号(、) 分隔，而不用逗号，即使并列词是英语也是如此。 123错误：我最欣赏的科技公司有 Google, Facebook, 腾讯, 阿里和百度等。正确：我最欣赏的科技公司有 Google、Facebook、腾讯、阿里和百度等。 英文句子中，并列词语之间使用半角逗号（,）分隔。 1例句：Microsoft Office includes Word, Excel, PowerPoint, Outlook and other components. 分号分号；表示复句内部并列分句之间的停顿。 引号引用时，应该使用全角双引号（“ ”），注意前后双引号不同。 1例句：许多人都认为客户服务的核心是“友好”和“专业”。 引号里面还要用引号时，外面一层用双引号，里面一层用单引号（‘ ’），注意前后单引号不同。 1例句：鲍勃解释道：“我要放音乐，可萨利说，‘不行！’。” 圆括号补充说明时，使用全角圆括号（），括号前后不加空格。 1例句：请确认所有的连接（电缆和接插件）均安装牢固。 冒号全角冒号（：）常用在需要解释的词语后边，引出解释和说明。 1例句：请确认以下几项内容：时间、地点、活动名称，以及来宾数量。 表示时间时，应使用半角冒号（:）。 1例句：早上 8:00 省略号省略号……表示语句未完、或者语气的不连续。它占两个汉字空间、包含六个省略点，不要使用。。。或...等非标准形式。 省略号不应与“等”这个词一起使用。 12345错误：我们为会餐准备了香蕉、苹果、梨…等各色水果。正确：我们为会餐准备了各色水果，有香蕉、苹果、梨……正确：我们为会餐准备了香蕉、苹果、梨等各色水果。 感叹号应该使用平静的语气叙述，尽量避免使用感叹号！。 不得多个感叹号连用，比如！！和!!!。 破折号破折号————一般用于做进一步解释。破折号应占两个汉字的位置。 1例句：直觉————尽管它并不总是可靠的————告诉我，这事可能出了些问题。 连接号连接号用于连接两个类似的词。 以下场合应该使用直线连接号（-），占一个半角字符的位置。 两个名词的复合 图表编号 123例句：氧化-还原反应例句：图 1-1 以下场合应该使用波浪连接号（～），占一个全角字符的位置。 数值范围（例如日期、时间或数字） 1例句：2009 年～2011 年 注意，波浪连接号前后两个值都应该加上单位。 波浪连接号也可以用汉字“至”代替。 1例句：周围温度：-20°C 至 -10°C 章节结构软件手册是一部完整的书，建议采用下面的结构。 简介（Introduction）： [必备] [文件] 提供对产品和文档本身的总体的、扼要的说明 快速上手（Getting Started）：[可选] [文件] 如何最快速地使用产品 入门篇（Basics）： [必备] [目录] 又称”使用篇“，提供初级的使用教程 环境准备（Prerequisite）：[必备] [文件] 软件使用需要满足的前置条件 安装（Installation）：[可选] [文件] 软件的安装方法 设置（Configuration）：[必备] [文件] 软件的设置 进阶篇（Advanced)：[可选] [目录] 又称”开发篇“，提供中高级的开发教程 API（Reference）：[可选] [目录|文件] 软件API的逐一介绍 FAQ：[可选] [文件] 常见问题解答 附录（Appendix）：[可选] [目录] 不属于教程本身、但对阅读教程有帮助的内容 Glossary：[可选] [文件] 名词解释 Recipes：[可选] [文件] 最佳实践 Troubleshooting：[可选] [文件] 故障处理 ChangeLog：[可选] [文件] 版本说明 Feedback：[可选] [文件] 反馈方式 范例 Redux 手册 Atom 手册 参考链接 产品手册中文写作规范, by 华为 写作规范和格式规范, by DaoCloud 技术写作技巧在日汉翻译中的应用, by 刘方 简体中文规范指南，by lengoo 文档风格指南, by LeanCloud 豌豆荚文案风格指南, by 豌豆荚 中文文案排版指北，by sparanoid 中文排版需求，by W3C]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ubuntu docker镜像问题]]></title>
      <url>http://www.lizorn.com//2016/11/02/docker-ubuntu-issue/</url>
      <content type="text"><![CDATA[起因emacs使用多年,发现spacemacs的配置还算符合胃口,于是想做一个基于Ubuntu16.04的Docker镜像,以后就可以带着这粒胶囊行走天下了. 没想到踩到一个坑… Dockerfile: 12345RUN \ DEBIAN_FRONTEND=noninteractive apt-get update &amp;&amp; \ DEBIAN_FRONTEND=noninteractive apt-get -y install wget curl git emacs&amp;&amp; \ DEBIAN_FRONTEND=noninteractive apt-get -y autoremove &amp;&amp; \ DEBIAN_FRONTEND=noninteractive git clone https://github.com/syl20bnr/spacemacs ~/.emacs.d &amp;&amp; \ 镜像build完成,启动emacs报错:Debugger entered--Lisp error:(Wrong-type-argument stringp nil) 打开--debug-info进行调试,出错的堆栈信息如下: 12345678string-match(&quot;\\(fish\\|t?csh\\)$&quot; nil)exec-path-from-shell--standard-shell-p(nil)exec-path-from-shell-printf(&quot;%S\\000%s&quot; (&quot;$&#123;PATH-ad3306701bb5eb9f528b5c1b34485248&#125;&quot; &quot;$&#123;MANPYTHON-ad3306701bb5eb9f528b5c1b34485248&#125;&quot;))exec-path-from-shell-getenvs((&quot;PATH&quot; &quot;MANPATH&quot;))exec-path-from-shell-copy-envs((&quot;PATH&quot; &quot;MANPATH&quot;))exec-path-from-shell-initialize()(progn (exec-path-from-shell-initialize))... 分析Emacs本质上是个操作系统,它有自己的环境变量. 所以为了让它可以使用宿主的shell,首先需要确保宿主和Emacs自身环境变量的一致性. exec-path-from-shell 就是一这么个GNU Emacs库,它将宿主的关键SHELL环境复制到EMACS的环境变量里,从而确保Emacs可以正常调用宿主机的BASH. 查看exec-path-from-shell-printf的代码: 1234567891011121314151617181920(defun exec-path-from-shell-printf (str &amp;optional args) "Return the result of printing STR in the user's shell. Executes $SHELL as interactive login shell. STR is inserted literally in a single-quoted argument to printf, and may therefore contain backslashed escape sequences understood by printf. ARGS is an optional list of args which will be inserted by printf in place of any % placeholders in STR. ARGS are not automatically shell-escaped, so they may contain $ etc." (let* ((printf-bin (or (executable-find "printf") "printf")) (printf-command (concat printf-bin " '__RESULT\\000" str "' " (mapconcat #'exec-path-from-shell--double-quote args " "))) (shell-args (append exec-path-from-shell-arguments (list "-c" (if (exec-path-from-shell--standard-shell-p (getenv "SHELL")) printf-command (concat "sh -c " (shell-quote-argument printf-command)))))) (shell (getenv "SHELL"))) 结合出错堆栈分析,问题基本可以定位,即: (getenv &quot;SHELL&quot;)去获取”SHELL”的环境变量,返回为空. 接着来查看getenv方法,它通过调用getenv-internal用来获取系统environment的变量. 查看系统环境变量,env|grep SHELL,果然无值. 那么只需要设置Docker-Ubuntu16.04容器的SHELL环境变量到env里就可以了. 12echo &quot;export SHELL=/bin/bash&quot; &gt;&gt; ~/.bashrcsource ~/.bashrc 运行emacs,问题解决.此时Dockerfile可以配置如下: 12345678...RUN \ DEBIAN_FRONTEND=noninteractive apt-get update &amp;&amp; \ DEBIAN_FRONTEND=noninteractive apt-get -y install wget curl git emacs&amp;&amp; \ DEBIAN_FRONTEND=noninteractive apt-get -y autoremove &amp;&amp; \ DEBIAN_FRONTEND=noninteractive git clone https://github.com/syl20bnr/spacemacs ~/.emacs.d &amp;&amp; \ DEBIAN_FRONTEND=noninteractive echo "export SHELL=/bin/bash" &gt;&gt; ~/.bashrc &amp;&amp; \ ... 疑问为什么官方Ubuntu Docker镜像没有将SHELL加到环境变量里? 有一点很明确,Docker不同于虚拟机,它的镜像文件确实需要保持精简,只需为容器保留必要的linux核心功能就可以了. Docker官方也给出了,-env的选项命令,用于自行进行环境变量配置.在Dockerfile中也可以使用ENV进行环境变量的配置,我们的Dockerfile可以写成如下的形式. 12345...RUN \ ... DEBIAN_FRONTEND=noninteractive ENV SHELL /bin/bash ... 那么,这个Docker镜像连$SHELL,$BASH等环境变量都省略了,是否还有其他功能被阉割了呢? 确实是的,问题还很多. 比如Docker下的ubuntu有一个很大的问题,它的PID1是bash! 1234root@0d9e754629e0:/# ps PID TTY TIME CMD 1 ? 00:00:00 bash 37 ? 00:00:00 ps 而完整的系统应该是init 1234lizorn@lizorn:/etc$ ps auxUSER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMANDroot 1 0.0 0.0 185604 6388 ? Ss 10:39 0:01 /sbin/init splashroot 2 0.0 0.0 0 0 ? S 10:39 0:00 [kthreadd] PID1 init是系统所有进程的祖先,同时它还负责接收和处理僵尸进程,the PID 1 zombie reaping problem. 这个问题会导致docker-ubuntu系统有可能产生无法回收的僵尸进程,造成内存孤岛,浪费系统性能.需要额外的补丁程序来完成PID1任务的回收工作,修复该问题的轮子已经具备,你可以直接使用phusion的baseimage来制作Docker基础镜像文件. 附录: linux 环境变量shell变量&amp;用户变量 set:显示当前shell的变量 env:显示当前用户的环境变量 export可将当前shell变量导出成用户变量. set下的环境变量不等同于env下的用户变量,两者是有区分的,因为一个用户可以有多个SHELL,如fish,tsh等. linux shell环境初始化流程Linux系统登录，bash其初始化过程依次加载如下文件(文件不存在就跳过): /etc/profile-&gt;/etc/profile.d~/.bash_profile-&gt;~/.bashrc-&gt;~/.bash_logout /etc/profile: 系统级用户环境变量.当用户第一次登录时,该文件被加载.设置命令行提示符$PS,并从/etc/profile.d目录的配置文件中搜集shell的设置. /etc/bashrc: 系统级用户环境变量.当bash shell被打开时加载. ~/.bash_profile: 用户级环境变量.用户登录时加载,默认情况下,他设置一些环境变量,执行用户的.bashrc文件. ~/.bashrc: 用户级环境变量.该文件包含专用于你的bash shell的bash信息,当登录时以及每次打开新的shell时加载该文件. ~/.bash_logout:当每次退出系统(退出bash shell)时执行该文件.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[键盘键位映射]]></title>
      <url>http://www.lizorn.com//2016/11/01/keymap/</url>
      <content type="text"><![CDATA[自从HHKB键盘败家卖了后,其他键盘一直用着不爽,只能稍微设置下,聊以自慰. 首先,capslock必须死,这么好的位置居然被这废材占据着. linuxcapslock-&gt;ctrlsudo emacs /etc/default/keyboard 修改下面这一行： XKBOPTIONS=&quot;ctrl:nocaps&quot; 重新配置系统键盘，全部选默认： sudo dpkg-reconfigure keyboard-configuration windowscapslock-&gt;ctrlCtrl2Cap maccapslock-&gt;ctrl 打开System Preferences → Keyboard → Modifier Keys]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hadoop快速入门]]></title>
      <url>http://www.lizorn.com//2016/10/27/hadoop-quick-start/</url>
      <content type="text"><![CDATA[什么是hadoop?Hadoop是一个由Apache基金会所开发的分布式系统基础架构，用户可以在不知道底层细节的情况下,将可自己的程序运行在分布式系统上,利用计算机集群对海量数据进行高速的数据运算和存储. 要学习hadoop,首先要了解它的核心设计:MapReduce和HDFS. HDFSHDFS(Hadoop Distributed File System，Hadoop分布式文件系统),是一个具备高度容错性的文件系统,可以部署在廉价的系统上. 基本架构 Block: 块文件,通常是64M. DataNode：用于存储Block块文件. NameNode: 保存整个文件系统的目录,文件和分布信息.指示文件是如何被拆分成block以及这些block都存储到了哪些DateNode节点上.通常只有一台,2.X版本提供了master-slave模式. MapReduceMapReduce是一种编程模型,用于大规模数据集(大于1TB)的并行运算.基本原理就是：分析大数据，然后析分成小块逐个分析，最后再将提取出来的数据汇总分析，最终获得我们想要的内容。 MapReduce操作的都是键值对上,大致流程如下: (input) -&gt; map -&gt; -&gt; combine -&gt; -&gt; reduce -&gt; (output) Apache hadoop家族基础成员 Hadoop Common Hadoop Distributed File System (HDFS™) Hadoop MapReduce 其他成员 Hadoop YARN: 用于工作调度和集群资源管理的框架. Avro™: 是一个数据序列化系统,设计用于支持数据密集型,大批量数据交换的应用.Avro是新的数据序列化格式与传输工具,将逐步取代Hadoop原有的IPC机制. Cassandra™:是一套开源分布式NoSQL数据库系统. Chukwa™: 是一个开源的用于监控大型分布式系统的数据收集系统，它可以将各种各样类型的数据收集成适合Hadoop处理的文件,并保存在HDFS中供Hadoop进行各种MapReduce操作. HBase™: 是一个高可靠性、高性能、面向列、可伸缩的分布式存储系统,利用HBase技术可在廉价PC Server上搭建起大规模结构化存储集群. Hive™: 基于Hadoop的一个数据仓库工具,可以将结构化的数据文件映射为一张数据库表,通过类SQL语句快速实现简单的MapReduce统计,不必开发专门的MapReduce应用,十分适合数据仓库的统计分析. Mahout™: 基于Hadoop的机器学习和数据挖掘的一个分布式框架.Mahout用MapReduce实现了部分数据挖掘算法,解决了并行挖掘的问题。 Pig™: Pig提供更高级的数据流语言，类似SQL的语言(Pig Latin),有效提高MapReduce编写的抽象表现能力. Spark™: 一个新兴的大数据处理引擎,提供了一个集群的分布式抽象模型RDD(Resilient Distributed Dataset).支持的实际应用范围非常广,如:ETL,机器学习,图像处理等. Tez™: 是Apache最新开源的支持DAG作业的计算框架,它直接源于MapReduce框架,核心思想是将Map和Reduce两个操作进一步拆分,即Map被拆分成Input、Processor、Sort、Merge和Output,Reduce被拆分成Input、Shuffle、Sort、Merge、Processor和Output等,这样,这些分解后的元操作可以任意灵活组合,产生新的操作,这些操作经过一些控制程序组装后,可形成一个大的DAG作业. ZooKeeper™: 是一个为分布式应用所设计的分布的、开源的协调服务，它主要是用来解决分布式应用中经常遇到的一些数据管理问题,简化分布式应用协调及其管理的难度,提供高性能的分布式服务. 环境准备docker run -it invain/hadoop hadoop案例:统计词频统计一个文本文件,一本书，或者一个web上各个单词出现的频率. WordCount.java源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import java.io.IOException;import java.util.StringTokenizer;import org.apache.hadoop.conf.Configuration;import org.apache.hadoop.fs.Path;import org.apache.hadoop.io.IntWritable;import org.apache.hadoop.io.Text;import org.apache.hadoop.mapreduce.Job;import org.apache.hadoop.mapreduce.Mapper;import org.apache.hadoop.mapreduce.Reducer;import org.apache.hadoop.mapreduce.lib.input.FileInputFormat;import org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;public class WordCount &#123; public static class TokenizerMapper extends Mapper&lt;Object, Text, Text, IntWritable&gt;&#123; private final static IntWritable one = new IntWritable(1); private Text word = new Text(); public void map(Object key, Text value, Context context) throws IOException, InterruptedException &#123; StringTokenizer itr = new StringTokenizer(value.toString()); while (itr.hasMoreTokens()) &#123; word.set(itr.nextToken()); context.write(word, one); &#125; &#125; &#125; public static class IntSumReducer extends Reducer&lt;Text,IntWritable,Text,IntWritable&gt; &#123; private IntWritable result = new IntWritable(); public void reduce(Text key, Iterable&lt;IntWritable&gt; values, Context context) throws IOException, InterruptedException &#123; int sum = 0; for (IntWritable val : values) &#123; sum += val.get(); &#125; result.set(sum); context.write(key, result); &#125; &#125; public static void main(String[] args) throws Exception &#123; Configuration conf = new Configuration(); Job job = Job.getInstance(conf, "word count"); job.setJarByClass(WordCount.class); job.setMapperClass(TokenizerMapper.class); job.setCombinerClass(IntSumReducer.class); job.setReducerClass(IntSumReducer.class); job.setOutputKeyClass(Text.class); job.setOutputValueClass(IntWritable.class); FileInputFormat.addInputPath(job, new Path(args[0])); FileOutputFormat.setOutputPath(job, new Path(args[1])); System.exit(job.waitForCompletion(true) ? 0 : 1); &#125;&#125; 编译12hadoop com.sun.tools.javac.Main WordCount.javajar cf wc.jar WordCount*.class 创建FS在hdfs上的用户目录下创建输入/输出文件的文件夹. hadoop fs -mkdir -p /user/{whoami}/wordcount/input 下本书 123mkdir -p ~/tmp/book/cd ~/tmp/bookwget http://www.gutenberg.org/files/5000/5000-8.txt 将书放到HDFS上 hadoop fs -put ~/tmp/book/*.txt /user/${whoami}/input 运行程序1hadoop jar wc.jar WordCount /user/$&#123;whoami&#125;/wordcount/input /user/$&#123;whoami&#125;/wordcount/output 查看解析内容hadoop fs -cat /user/${whoami}/wordcount/output/part-r-00000 hadoop steamingHadoop是使用Java语言编写的,所以最直接的方式的就是使用Java语言来实现Mapper和Reducer,然后配置MapReduce Job,提交到集群计算环境来完成计算.hadoop也为其它语言，如C++、Shell、Python、 Ruby、PHP、Perl等提供了支持，这个工具就是Hadoop Streaming. wordcount的python实现mapper.py源码1234567891011121314#!/usr/bin/env pythonimport sysdef read_input(file): for line in file: yield line.split()def main(separator='\t'): data = read_input(sys.stdin) for words in data: for word in words: print "%s%s%d" % (word, separator, 1)if __name__ == "__main__": main() reducer.py1234567891011121314151617181920#!/usr/bin/env pythonfrom operator import itemgetterfrom itertools import groupbyimport sysdef read_mapper_output(file, separator = '\t'): for line in file: yield line.rstrip().split(separator, 1)def main(separator = '\t'): data = read_mapper_output(sys.stdin, separator = separator) for current_word, group in groupby(data, itemgetter(0)): try: total_count = sum(int(count) for current_word, count in group) print "%s%s%d" % (current_word, separator, total_count) except valueError: passif __name__ == "__main__": main() 运行可以写个sh脚本运行 123456hadoop jar $STREAM \-files ./mapper.py,./reducer.py \-mapper ./mapper.py \-reducer ./reducer.py \-input /user/$&#123;whoami&#125;/input/ \-output ~/output]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Docker环境]]></title>
      <url>http://www.lizorn.com//2016/10/27/docker-developer-env/</url>
      <content type="text"><![CDATA[如今技术革新非常快,搭建环境也日趋繁杂.我是个爱好折腾之人,时不时的总想把玩下新的技术,每天在win10,ubuntu,mac系统间来回切换,感谢Docker,救我于水火. 基础镜像自己裁剪一个baseImage,带emacs编辑器.编写Dockerfile,并编译 123git clone https://github.com/LiZoRN/DockerBaseImage.gitcd DockerBseImagedocker build -t invain/ubuntu . 将镜像文件push到Docker hub docker push invain/ubuntu 其他环境下就可以直接使用 docker pull invain/ubuntu 注意: Docker镜像共享，不建议直接拿Dockerfile build生产, 而应从Docker镜像库里拉,避免镜像Build的过程中引入编译环境差异. Hadoop环境搭建(单站)创建hadoop用户增加hadoop用户，授予管理员权限，并登录 1234$ sudo useradd -m hadoop$ sudo passwd hadoop$ sudo adduser hadoop sudo$ sudo su hadoop 安装并配置SSH安装openssh $ sudo apt-get install openssh-server 启动 $ sudo /etc/init.d/ssh start 设置免密码登录，生成私钥和公钥,并将公钥追加到 authorized_keys中，它为用户保存所有允许登录到ssh客户端用户的公钥内容。 12$ ssh-keygen -t rsa -P ""$ cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys 安装Java环境sudo apt-get install openjdk-7-jdk 获取java安装目录. 1234$ update-alternatives --config javaThere is only one alternative in link group java (providing /usr/bin/java): /usr/lib/jvm/java-7-openjdk-amd64/jre/bin/javaNothing to configure. ~/.bashrc中写入JAVA_HOME路径, 1export JAVA_HOME=JDK安装路径 安装Hadoop安装hadoop,如2.7.3版本 123wget http://mirrors.tuna.tsinghua.edu.cn/apache/hadoop/common/hadoop-2.7.3/hadoop-2.7.3.tar.gzsudo tar xzf hadoop-2.7.3.tar.gzsudo mv hadoop-2.7.3 /usr/local/hadoop 配置Hadoop的环境变量 给你的~/bashrc添加如下内容. 1234567891011121314#HADOOP VARIABLES STARTexport JAVA_HOME=/usr/lib/jvm/java-7-openjdk-amd64export HADOOP_HOME=/usr/local/hadoopexport PATH=$PATH:$HADOOP_HOME/binexport PATH=$PATH:$HADOOP_HOME/sbinexport HADOOP_MAPRED_HOME=$HADOOP_HOMEexport HADOOP_COMMON_HOME=$HADOOP_HOMEexport HADOOP_HDFS_HOME=$HADOOP_HOMEexport YARN_HOME=$HADOOP_HOMEexport HADOOP_COMMON_LIB_NATIVE_DIR=$HADOOP_HOME/lib/nativeexport HADOOP_OPTS="-Djava.library.path=$HADOOP_HOME/lib"export STREAM=$HADOOP_HOME/share/hadoop/tools/lib/hadoop-streaming-*.jarexport HADOOP_CLASSPATH=$&#123;JAVA_HOME&#125;/lib/tools.jar#HADOOP VARIABLES END 验证hadoop是否安装成功 1234567hadoop@8bbae082ad69:~$ hadoop versionHadoop 2.7.3Subversion https://git-wip-us.apache.org/repos/asf/hadoop.git -r baa91f7c6bc9cb92be5982de4719c1c8af91ccffCompiled by root on 2016-08-18T01:41ZCompiled with protoc 2.5.0From source with checksum 2e4ce5f957ea4db193bce3734ff29ff4This command was run using /usr/local/hadoop/share/hadoop/common/hadoop-common-2.7.3.jar 将镜像push到Docker hub 12docker commit 8bbae082ad69 invain/hadoopdocker push invain/hadoop spark运行一个java docker容器. docker run -it invain/java 下载spark包. 123wget http://mirrors.hust.edu.cn/apache/spark/spark-2.0.1/spark-2.0.1-bin-hadoop2.7.tgzsudo tar xzf spark-2.0.1-bin-hadoop2.7.tgzsudo mv spark-2.0.1-bin-hadoop2.7 /usr/local/spark 配置好环境变量. 12export SPARK_HOME=/usr/local/sparkexport PATH=$SPARK_HOME/bin:$PATH 跑个小小示例.创建个文本文件,如hellospark.txt: 12hello world!hello spark! 运行spark的python交互式控制台,pyspark. 123456789101112131415161718hadoop@4532e4bdaa51:~$ pysparkPython 2.7.6 (default, Jun 22 2015, 17:58:13)[GCC 4.8.2] on linux2Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.Using Spark&apos;s default log4j profile: org/apache/spark/log4j-defaults.propertiesSetting default log level to &quot;WARN&quot;.To adjust logging level use sc.setLogLevel(newLevel).16/10/28 02:10:51 WARN NativeCodeLoader: Unable to load native-hadoop library for your platform... using builtin-java classes where applicableWelcome to ____ __ / __/__ ___ _____/ /__ _\ \/ _ \/ _ `/ __/ &apos;_/ /__ / .__/\_,_/_/ /_/\_\ version 2.0.1 /_/Using Python version 2.7.6 (default, Jun 22 2015 17:58:13)SparkSession available as &apos;spark&apos;.&gt;&gt;&gt; 使用textFile加载文本到RDD,进行’wordcount’.12&gt;&gt;&gt; text = sc.textFile("hellospark.txt")&gt;&gt;&gt; counts = text.flatMap(lambda line: line.split(" ")).map(lambda word: (word,1)).reduceByKey(lambda x,y: x + y) 调用saveAsTextFile,分布式作业开始了…1counts.saveAsTextFile(&quot;hellospark_out&quot;) 可以在工作台输出目录里查看12345hadoop@4532e4bdaa51:~$ cat hellospark_out/part-00000(u&apos;&apos;, 1)(u&apos;spark!&apos;, 1)(u&apos;world!&apos;, 1)(u&apos;hello&apos;, 2) tensorflowdocker run -it b.gcr.io/tensorflow/tensorflow Docker hub需要什么库可以从docker hub找. Docker hub是一个类似Github一样的地方,只不过前者是一个镜像仓库. docker可以让你的环境配置异常简单，通常你只需要执行一个命令. Mysql 1$ docker run -p 3306:3306 --name username -e MYSQL_ROOT_PASSWORD=password -d mysql:tag mongo docker run --name some-mongo -d mongo Oracle]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[代码的味道]]></title>
      <url>http://www.lizorn.com//2016/10/25/Taste-of-code/</url>
      <content type="text"><![CDATA[代码的味道你的代码臭不可闻，为什么？ 工期太赶 前任的坑 还是…水平未到？ 很多程序员会给自己的代码找很多借口，我认为糟糕代码的产生除了上述原因外，主要是思想问题，要摒弃糟糕的代码，让代码变得整洁，必须要先弄明白一件事情：大家写程序，你的客户是谁? 代码的表现力 “程序写出来是给人看的,附带能在机器上运行. “ 代码的表现力主要体现在两个方面: 软件的部分功能就是解释自身,为了写出优秀的软件,你必须假定用户对你的软件基本上一无所知. 源代码也应该可以自己解释自己,你需要保证源代码自身的可观赏性. 说白了，编程不是简单的完成一次功能交付，代码的表现形式不仅仅是产品本身，还包括代码自己。也就是说在你充分的实现‘功能客户’的需求的同时，你还需要满足‘code reviewer’的胃口。 我们就需要让代码变的整洁。 什么是整洁的代码?我喜欢优雅和高效的代码.代码逻辑应当直截了当,叫缺陷难以隐藏;尽量减少依赖关系,使之便于维护;依据某种分层战略完善错误处理代码;性能调至最优,省得引诱别人做没规矩的优化,搞出一堆换乱来.整洁的代码只做好一件事. Bjarne ShroustrupC++程序设计语言 C++之父Bjarne认为代码应该是优雅而高效的. 整洁的代码简单直接;整洁的代码如同优美的散文;整洁的代码从不隐藏设计者的意图,充满了干净利落的抽象和直截了当的控制语句. rady Booch面向对象分析与设计 编程是一门技艺，代码是一种艺术，很难有语言表达。我摘录了《clean code》书中‘味道与启发’这一章节部分清单，进行了修整和梳理，清单里的代码会让你非常不舒服，清单的内容需要持续维护和更新。 命名问题命名要具备描述性,避免歧义 名副其实, 好的命名不需要额外的注释 12int d; // 消逝的时间,以日计 ----badint elapsedTimeInDays; // ----good 避免误导 必须避免留下隐藏代码本意的错误线索,避免使用与本意相悖的词,如系统预留字段要尽量避免,歧义的缩写也应当避免.比如用accountList表示一组账号，会有歧义，这是是List类型? 用accountGroup则能更好的表示。 命名要有明显的区别 以下的方法很难区分具体含义：123getActiveCustomer();getActiveCustomers();getActiveCustomerInfo() 命名要具备可读性 命名通常要用于交流和沟通，需要具备基本的口语习惯。12private Date modymdhms; //badprivate Date modificationTimestamp; /good 类名使用名词,方法名使用动词. 名称应与抽象层级相符.1234567public interface Modem &#123; boolean dial(String phoneNumber);//应修改为 boolean connect(String phoneNumber); boolean disconnect(); boolean send(char c); char recv(); String getConnectedPhoneNumber();&#125; 尽可能使用标准命名法. 如果名称基于现有的约定或用法,命名就比较容易理解 命名要遵循专业领域的命名 命名要遵循团队的编码规范 名称的长度应与作用范围的广泛度相关. 对于较小的作用范围,可以用很短的名称,而对于较大作用范围就该用较长的名称. 作用范围在5行之内,i和j之类的变量名没有问题,如果范围变大,需要加长命名长度,用更有意义的命名. 避免编码.不应该在名称中包括类型或者作用范围信息，以下命名方法均可以考虑废弃： 匈牙利标记法: cClass, init,intNUmber; 成员前缀: private String m_member; 接口: 接口已I开头，IInterface 名称应说明附加功能和副作用 命名应该说明函数,变量或类的一切信息,不要用名称掩蔽副作用 不使用简单的动词来描述不止做了一个简单动作的函数. 123456public ObjectOutputStream getOos() throws IOException &#123; if (m_oos == null) &#123; m_oos = new ObjectOutputStream(m_socket.getOutputStream()); &#125; return m_oos;&#125; getOos应改为createOrReturnOos 注释问题不恰当的注释.注释只应该描述相关代码和设计的技术信息.如描述一些修改记录,问题追踪等是不恰当的注释,这些注释过时且无实际意义，会扰乱和降低阅读体验.这些工作需要交给版本能控制工具。 废弃的注释.注释也需要维护,过时,无关或不正确的注释会引起歧义并影响代码的可读性,需第一时间删除或更新. 冗余注释.代码已经充分自我描述了,那么注释就是冗余的. 注释应该是代码未能涉及信息的补充. 1i++; // increment i 坏注释.注释也是代码的一部分,要保持简洁和语句通顺,别在里面闲扯. 123456789101112131415161718192021/*I fear that I will always be A lonely number like root threeA three is all that's good and rightWhy must my three keep out of sight Beneath a vicious square-root sign?I wish instead I were a nineFor nine could thwart this evil trick With just some quick arithmeticI know I'll never see the sunAs 1.7321...Such is my reality A sad irrationalityWhen,hark, just what is this I see?Another square root of a threeHas quietly come waltzing byTogether now we multiplyTo form a number we preferRejoicing as an integerWe break free from our mortal bondsAnd with a wave of magic wandsOur square-root signs become ungluedAnd love for me has been renewed */double number = Math.sqrt(3)*Math.sqrt(3); 废弃的代码.不应该出现注释的代码, 注释掉的代码需要及时删除,版本控制系统会记录没一次的修改,不需要通过注释的形式. 一般性问题理所当然的行为未被实现.根据”最小惊异原则”,函数或类应该实现用户或程序员有理由期待的行为. 1Day day = DayDate.StringToDay(String dayName); 我们期望字符串Monday转化为Day类型的Day.MONDAY，也期望可以转化为常用缩写的Day.MON,还期望可以忽略大小写,Day.mon，这个再正常不过了.还比如，一个EXCEL的字段解析,一次web页面的字符串输入，至少要保证忽略两边的空格. 不正确的边界行为.单元测试需要追索每种边界条件,并编写测试. 忽略安全.不要关闭编译器的告警,不要忽略编译告警,甚至可以引入**Lint等语法静态编译校验工具来提高代码质量. 重复.牢记DRY原则(Don’t Repeat Yourself). 发现重复代码就表示遗漏了抽象.复制粘贴式的编码会造成大量的重复,你需要不断的重构，将重复的代码叠放成抽象对象. 代码出现在错误的抽象层级上.良好的软件设计要求将代码,文件,组件和模块，根据层级分离,将它们放到不同的位置. 基类依赖于派生类.基类不应该依赖派生类,抽象类不依赖于实体类，这是面向对象设计的基本准则，篇幅有限，具体详细查看设计模式. 信息过多 设计良好的模块有非常小的接口,耦合度低. 限制类或模块中暴露的接口数量.类中的方法越少越好.函数知道的变量越少越好. 隐藏模块和类中的数据和工具函数,隐藏常量和你的临时变量,不要创建有大量方法或大量实体变量的类,保持接口紧凑. 混淆视听未被执行的代码,没有用到的变量,没有信息量的注释等需要尽早删除,保持源文件整洁和良好. 垂直分割. 变量和函数应该在靠近被使用的地方定义. 本地变量应该正好在其首次被使用的位置上面声明,垂直距离要短. 私有函数应该刚好在其首次被使用的位置下面定义. 前后不一致.命名要保持一致性.如果在特定函数中用名为response的变量来持有HttpServletResponse对象,则在其他用到该对象的地方也使用response变量名. 设计耦合 不相互依赖的东西不该耦合.例如,普通的enum不应该包含在特殊类里,否则使用这些enum就需要了解这个特殊类. 花点时间设计代码结构,研究应该在什么地方声明函数,常量和变量.不要为了方便而随手放置,放置后又置之不理. 隐晦的意图. 代码尽可能具有表达力. 短小紧凑的代码不一定是最好的代码,魔法数字应该拆分到具备解释性的变量里.如下代码你能明白什么意思吗？ 123public init m_otCalc() &#123; return iThsWkd * iThsRte + (int) Math.round(0.5 * iThsRte * Math.max(0, iThsWkd - 400));&#125; 代码位置错误.开发人员做出的最重要决定之一就是在哪里放代码. 比如做一个考勤模块的功能,可以在打印报表的代码中做工作时间统计,或者在刷卡代码中保留一份工作时间记录.这个时候最小惊异原则就起了作用.代码应该放在读者自然而然的地方，期待它所在的地方，就和老婆一样，每天早上醒来就在边上. 所以说编程其实是一种艺术行为. PI应该出现在声明三角函数的地方，而不是和一只老虎困在大海里. 不恰当的静态方法. 通常应该倾向于选用非静态方法,如果需要静态函数,确保不会让它有多态行为. Math.max(double a, double)是个良好的静态方法,因为它并不在需要在的那个实体上运作. 使用解释性变量.和G16类同,使用解释性变量,只要把计算过程打散成一系列良好命名的中间值,就可以提高代码的可读性, 123456Matcher match = headerPattern.matcher(line);if(match.find())&#123; String key = match.gourp(1); String value = match.group(2); headers.put(key.toLowerCase(), value);&#125; 函数名称应该表达其行为.如果必须要通过查看函数的实现(或文档)才知道它是做什么的,那是时候该换个更好的函数名了. 1Date newDate = date.add(5); 从函数调用中看不出函数的行为,如果是添加5天并修改日期,那么命名需要调整为increaseByDays. 理解算法. 很多可笑代码的出现,是因为没花时间去理解公式和算法,硬塞进足够的if语句和标示,让系统勉强运作. 在完成某个函数之前,要确认自己完全理解了它是怎么工作的,只有理解了公式,才能更好的进行优化. 遵循标准约定.每个团队都应遵循基于通用行业规范的一套编码标准. 魔法数.用常量代替魔法数字. 封装条件语句.如果没有if或while语句的上下文,布尔逻辑就难以理解,应该把解释了条件意图的函数抽离出来. 1if (timer.hasExpired() &amp;&amp; !timer.isRecurrent()) //bad 换成 1if (shouldBeDeleted(timer)) //good 避免否定性条件.人的逆向思维能力一般都比较差，否定式要比肯定式难明白一些.所以,尽可能将条件表示为肯定形式. 1if (!buffer.shouldNotompact()) //bad 1if (buffer.shouldCompact()) //good 函数只该做一件事.遵循职责单一原则.以下的代码完成了太多的事情，我们需要拆分. 12345678public void pay() &#123; for (Employee e : employees) &#123; if (e.isPayday()) &#123; Money pay = e.calculatePay(); e.deliverPay(pay) &#125; &#125;&#125; 遍历雇员12345public void pay() &#123; for (Employee e : employees) &#123; payIfNecessary(e); &#125;&#125; 检查是否该给雇员付工资12345private void payIfNecessary(Employee e) &#123; if (e.isPayday())&#123; calculateAndDeliverPay(e); &#125;&#125; 给雇员付工资1234private void caculateAndDeliverPay(Employee e) &#123; Money pay = e.calculatePay(); e.deliverPay.pay()&#125; 掩藏时序耦合.不要隐藏时序耦合.如下代码，三个函数存在时序,捕鱼之前先织网,织网之前先编绳.如果调用倒换,可能就导致抛出异常. 1234567public class MoogDiver &#123; public void dive(String reson) &#123; saturateGradient(); reticulateSplines(); diveForMoog(reason); &#125;&#125; 我们需要做调整，该耦合的还是得耦合,要符合实际的业务逻辑. 1234567public class MoogDiver &#123; public void dive(String reson) &#123; Gradient gradient = saturateGradient(); List&lt;Spline&gt; splines = reticulateSplines(gradient ); diveForMoog(splines ,reason); &#125;&#125; 函数应该只在一个抽象层级上.避免传递浏览,函数或者接口调用者不需要了解太多架构相关的东西.如果A与B协作,B与C协作,我们不想让使用A的模块了解C的信息 bad: a.getB().getC().doSomething() good: myCollaborator.doSomething() 环境问题需要多步才能实现的构建.构建系统应到是单步的操作, 执行一条命令,就可以从版本控制系统里拉下源代码,并完成构建. 123svn get myPorjectcd myProjectant all 或者1234git clone *******cd **npm intallnpm start 需要多步才能做到的测试单个命令应该可以运行全部的单元测试，并输出结果和报告. 测试问题测试不足,未使用覆盖率工具. 一套测试中应该有多少个测试?CMMI将单元测试作为QA考核项,单元测试需考虑测试用例的代码覆盖率. 使用覆盖率工具能更容易地找到测试不足的模块,类和函数. 测试边界条件.特别需要注意测试边界条件.这是最基本的测试方法. 测试覆盖率都具备启发性,查看未执行和已执行测试的代码,往往能发现线索,有效的定位问题. 测试应该快速单元测试保障了代码的重构.重构行为给代码带来更长的生命周期和更高的质量. 函数问题过多的参数.最理想的参数数量是零,其次是一,再次是三,此类推,应避免三个以上的参数,符合职责单一原则. 输出参数.容易把输出参数误看做输入参数,应少用或不用输出参数. 标示参数.不要向函数传入布尔值.这不符合职责单一原则. 不被调用的函数.用不被调用的方法应该丢弃,直接删除,保留代码的整洁. 命名不明确.使用动词与关键字给函数去个好名字,能较好的解释方法的意图,以及参数的顺序和意图.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Google的职业生涯：技术开发指导(学生)]]></title>
      <url>http://www.lizorn.com//2016/10/13/google-guide-to-development/</url>
      <content type="text"><![CDATA[Google的职业生涯：技术开发指导(面向学生)本指南列举各项领域知识和相关资源来帮助你学习和提高相关技术能力。 建议 资源 基础知识 计算机科学 掌握至少一门面向对象语言(C++, Java®, Python®) 初级程序员在线资源: - Java 程序设计 - 学习编程：基础 多伦多大学 - java编程介绍 MIT - 谷歌python教学 - python编程 莱斯大学 在线高级教程: - 面向对象 Java 程序设计 加州大学圣迭戈分校 - 计算机编程设计 - 学习编程：撰写高质量代码 多伦多大学 学习其他编程语言 - JavaScript® - CSS &amp; HTML - Ruby® - PHP® - C® - Perl® - Shell® script - Lisp® - Scheme® - CSS &amp; HTML - Ruby® - PHP® - Go® 在线资源: - Codecademy 调试代码 学习如何catch bugs，进行代码测试.在线资源:- 软件测试- 软件调试 提高离散数学的逻辑推理和知识 在线资源 - 计算机科学数学应用 MIT - 数学思维 斯坦福大学 - 概率图模型 斯坦福大学 - 博弈论 斯坦福科伦比亚大学 提高对算法和数据结构有很强的理解能力 熟悉基础数据类型（栈，队列，包），排序算法（快速排序，合并排序，堆排序），数据结构（二分搜索树，红黑树，哈希表）以及BIG O. 在线资源： - 算法简介 斯坦福大学 - 算法1&amp;算法2 普林斯顿大学 - 算法总览 维基百科 - 数据结构总览 维基百科 操作系统 在线资源： - 操作系统和系统编程 人工智能和机器学习 在线资源： - 机器学习工程师Nanodegree Udacity - 深度学习 Udacity - 机器人技术 斯坦福大学 - 机器学习 斯坦福大学 安卓开发 在线资源： - 谷歌Android开发教学 web开发 在线资源： - 谷歌web开发教学 学习其他开发技术 在线资源： - 谷歌工程师培训站点 学习密码学 在线资源： - 密码学 - 密码学应用 在一个代码库里工作，通过阅读优秀的代码来提高你的编码，文档以及debug能力 - Github - Klin 和其他程序员一起工作 这将有利于锻炼你的团队合作能力并使你从学习其他人的优点 锻炼你的算法知识和编程技巧 通过编程竞赛（CodeJam，ACM）锻炼你的算法知识 成为导师助理 通过指导其他学生将能有效增强和巩固你的知识体系]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Docker使用手册]]></title>
      <url>http://www.lizorn.com//2016/09/27/docker-manual/</url>
      <content type="text"><![CDATA[什么是Docker?先看一段Docker创始人的一段视频: Ship! Docker就是用来解决日渐繁杂的开发和生产环境的痛点问题的!大大简化了软件开发的流程和环境搭建的复杂性,解放重复劳动,让技术人员更关注功能和需求. Docker的产生是为了解决以下的问题: 环境管理复杂:从各种OS到中间件到APP,开发者需要关心太多的东西,Docker可以通过镜像分享的形式简化部署多应用实例. 虚拟化手段变化:采用虚拟化手段满足用户按需分配的资源需求以及保证可用性和隔离型. 如何学习一种工具和技术?入门非常的容易 上官网,跟着教程走 下载DOCKER FOR WINDOWS SERVER安装 非win10 pro,得安装docker toolbox 安装后,上docker hub pull一个镜像下来. 试运行下 Docker run hello-world 发现已经被墙了,google之,配置DaoCloud的Docker加速器 1234docker-machine ssh defaultsudo sed -i &quot;s|EXTRA_ARGS=&apos;|EXTRA_ARGS=&apos;--registry-mirror=加速地址 |g&quot; /var/lib/boot2docker/profileexitdocker-machine restart default 开胃菜结束,进入主菜 Docker OverviewDocker是一个用于Developing,shipping,running应用的开放平台. 先预览一下,之后我们需要弄清楚以下几个问题. Docker是什么? Docker是如何驱动的? Docker能解决什么问题? Docker的架构? 什么是Docker平台?Docker提供管理容器生命周期的工具和平台: 将你的应用[包括组件]打包到Docker容器内 分发这些容器到团队,进行进一步的开发和测试 将应用发布到生产环境 Docker引擎?Docker是C/S结构的应用,Server是守护程序常驻内存,Client通过REST API和Server交互. Docker解决什么问题?快速可持续行的发布应用开发人员本地编码并通过分享Dorker容器进行集成,测试,发布 按需部署和裁剪Docker容器具备很高的移植性,它可以在开发人员的本地环境运行,也可以在数据中心,云的物理和虚拟环境中运行. 同一个硬件环境提供更高的负载Docker的架构? Docker daemonServer守护程序,用户通过Docker client和它交互 Docker Client用户和Docker交互的主要工具,使用命令行和配置和Docker damon进行交互. Docker内部结构imagesDocker的镜像是只读的模板,用于指示Docker创建容器的,由Dockerfile文本文件来描述.说白了就是Docker的Build组件. containers可运行的Docker image实例.是Docker的运行组件. registriesdocker registry是镜像库,是Docker的分发组件. Docker的容器如何加载和运行?$ docker run -i -t ubuntu /bin/bash 当运行一条命令,Docker引擎会进行一系列的处理来加载和运行容器: 获取ubuntu镜像: Docker引擎首先在本地查找镜像,如果存在就作为新的容器加载进来,如不存在就从Docker hub获取镜像 创建一个新的容器:Docker使用image创建容器 配置文件系统并加载一个读写层: 在文件系统里创建容器并将读写层让入image 配置网络接口:创建一个网络接口,允许Docker容器和local host交互 配置IP地址: 查找并绑定一个可用的ip地址 执行命令: 执行/bin/bash 应用输出:连接应用标准输入,输出,错误接口,供交互. 入门示例构建image从Docker hub获取whalesay镜像1234567891011121314151617181920212223242526272829$ docker run docker/whalesay cowsay booUnable to find image &apos;docker/whalesay:latest&apos; locallylatest: Pulling from docker/whalesaye9e06b06e14c: Pull completea82efea989f9: Pull complete37bea4ee0c81: Pull complete07f8e8c5e660: Pull complete676c4a1897e6: Pull complete5b74edbcaa5b: Pull complete1722f41ddcb5: Pull complete99da72cfe067: Pull complete5d5bd9951e26: Pull completefb434121fc77: Already existsDigest: sha256:d6ee73f978a366cf97974115abe9c4099ed59c6f75c23d03c64446bb9cd49163Status: Downloaded newer image for docker/whalesay:latest _____&lt; boo &gt; ----- \ \ \ ## . ## ## ## == ## ## ## ## === /&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;___/ === ~~~ &#123;~~ ~~~~ ~~~ ~~~~ ~~ ~ / ===- ~~~ \______ o __/ \ \ __/ \____\______/ 写一个Dockerfile123FROM docker/whalesay:latestRUN apt-get -y update &amp;&amp; apt-get install -y fortunesCMD /usr/games/fortune -a | cowsay 编译image1$ docker build -t docker-whale . 编译流程 首先,Docker校验编译所需要素. 1Sending build context to Docker daemon 2.048 kB Docker加载whalesay镜像.镜像已经在本地,所以不需要再去下载. 12Step 1 : FROM docker/whalesay:latest ---&gt; 6b362a9f73eb Docker更新apt-get包管理器 1234567Step 2 : RUN apt-get -y update &amp;&amp; apt-get install -y fortunes ---&gt; Running in 21b7de6678a8Ign http://archive.ubuntu.com trusty InReleaseGet:1 http://archive.ubuntu.com trusty-updates InRelease [65.9 kB]Get:2 http://archive.ubuntu.com trusty-security InRelease [65.9 kB]Hit http://archive.ubuntu.com trusty Release.gpgGet:3 http://archive.ubuntu.com trusty-updates/main Sources [474 kB] 安装fortunes 12345678Reading state information...The following extra packages will be installed: fortune-mod fortunes-min librecode0Suggested packages: x11-utils bsdmainutilsThe following NEW packages will be installed: fortune-mod fortunes fortunes-min librecode00 upgraded, 4 newly installed, 0 to remove and 87 not upgraded. 完成编译 12345Step 3 : CMD /usr/games/fortune -a | cowsay ---&gt; Running in 3a10806db557 ---&gt; e02e38c358dbRemoving intermediate container 3a10806db557Successfully built e02e38c358db 运行新的docker-whale123456789101112131415161718docker run docker-whale/ Everyone has a purpose in life. Perhaps \| yours is watching television. || |\ -- David Letterman /----------------------------------------- \ \ \ ## . ## ## ## == ## ## ## ## === /&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;___/ ===~~~ &#123;~~ ~~~~ ~~~ ~~~~ ~~ ~ / ===- ~~~ \______ o __/ \ \ __/ \____\______/ Docker hub使用Docker hub对镜像进行配置管理,和Git使用方式类似. 容器命名1$ docker run -d -P --name web training/webapp python app.py 容器挂载管理Docker ComposeCompose是一个定义和运行多Docker容器应用的工具. 使用Compose通常有3个步骤: 将应用的环境定义到Dockerfile,以便在其他地方可以复用. 在docker-compose.yml将应用定义为服务,这样你可以在解耦的环境中运行 最后,执行docker-compose up docker-compose.yml大致内容如下: 123456789101112131415version: &apos;2&apos;services: web: build: . ports: - &quot;5000:5000&quot; volumes: - .:/code - logvolume01:/var/log links: - redis redis: image: redisvolumes: logvolume01: &#123;&#125; Compose的使用场景 开发环境 自动化测试环境 单站部署 使用指南跟着官网教程 Docker MachineDocker Machine说白了就是个Docker Server集群管理的client端,便于远程发布和部署Docker应用 Docker应用到项目开发方法 如果是新的团队,那没什么问题,起初就可以商量好.如果是已经比较成熟的团队,Docker逐步嵌入到几个持续集成的流程中去.应用Docker到软件开发的流程,首先需要解决几个问题. Base Image的选择, phusion-baseimage 配置管理Docker镜像的工具的选择，如Ansible、Chef、Puppet Host主机系统的选择，如CoreOS、Ubuntu 使用持续集成工具(Jenkins)进行管道部署进行持续集成 使用Google Kubernetes进行生产部署 Docker的集成测试部署之道 Docker文件挂载Docker image打包发布的时候,如果源码也一并放在image里是不合理的,所以具体开发过程中需要将宿主文件挂载到Docker容器里. windows下开发环境windows在vxbox的虚拟机在起Docker,所以需要迂回挂载. 利用vxbox共享 设置vxbox共享文件夹 进入vxbox虚拟机,将windows目录挂载到虚拟机,如： 1sudo mount -t vboxsf project /mnt/data 进入Docker终端，-v启动挂载到容器 1docker run -it -v /mnt/data:/usr/data ubuntu:trusty Docker常用命令清除 停止所有container 1docker stop $(docker ps -a -q) 删除所有container 1docker rm $(docker ps -a -q) 删除所有images 1docker rmi $(docker images -q) Docker的坑希特勒吐槽Docker Docker工具 Kubernetes InfoQ上的Docker]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[攻城狮周记(五)]]></title>
      <url>http://www.lizorn.com//2016/09/26/readmemo/</url>
      <content type="text"><![CDATA[Fintech细分领域研究报告随着科技的发展，大数据和人工智能等前沿科技早已介入金融领域。Fintech美国已经领先中国很多,是一个好的领域.原文 大数据团队建设 数据基础服务团队，负责Hadoop、Spark、Hbase、Hive等基础组件的运维、开发和优化； 数据开放平台团队； 数据仓库团队，负责统一的数据仓库，力图解决数据不一致、口径不一致、模型不一致以及数据质量等问题； 数据挖掘团队，偏算法研究与建模，负责核心应用开发。 质量控制（QA）团队，主要负责软件测试及DevOps流程贯彻落地。 项目管理团队，有专门的项目管理团队负责项目需求及进度。 数据分析纬度一个优秀的数据分析师是怎样炼成的？ # 前端知识库知识库 开源大数据工具原文 微信小程序微信小程序简易教程 如何讲故事?原文 数据挖掘四大信仰信仰1：不以具体业务场景出发，不考虑大数据并发实现的数据挖掘，都在耍流氓；信仰2：知其然，晓其所以然，万变不离其宗，必定变化莫测，这正是算法魅力；信仰3：在DataMining领域，不做两种人。一种是工具人，一种是研究者；信仰4：拥有健康、丰满的数据，业务场景建模已经成功90%以上了；]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[My little trouble]]></title>
      <url>http://www.lizorn.com//2016/09/22/my-little-upset/</url>
      <content type="text"><![CDATA[碎片化的时代,获取了太多的垃圾信息,最近又想的太多.于是最近就变得比较焦虑,异常的焦虑. 两年前回到宁波,这里的好企业真的太少了,尤其是技术类的.最后进入互联网的领域,web,app大部分都毫无技术含量,发现已于研发越走越远. 反复思考自己的职业规划,思考自己想要什么.近几年换工作比较频繁,切换了不同的领域,由于具备通用的专业能力,知识的转化率都还算高.眼界虽宽了很多,但还是缺乏某一个领域深度,没有享受到领域知识的时间复利,一直处于开荒状态,不能进行有效的farm. 我觉得必须开始经营自己的品牌: 精进一项核心技能 混圈子 持续的自我进化 于是问题来了,这次换还是不换呢?]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[IONIC2使用感想]]></title>
      <url>http://www.lizorn.com//2016/09/22/ionic2-/</url>
      <content type="text"><![CDATA[IONIC2基于Angular2,属于Ponegap体系,和RN都是我比较看好的框架,都还未正式发布.之所以会去使用它,完全是因为Typescript的缘故,TS作为ES/JS的超集使用起来比较方便. Ionic2处于Beta阶段,现在社区不活跃,资源也相对比较少,和我去年预研RN时候不同,RN是由于迭代太快,坑太多,但社区还是比较活跃的.如今RN已如日中天…,但不差钱还是要选择原生技术. 期间看了下官网的一个实例conference,并移植和改写了一个示例ionic2-realty,也算入了门了. 这类框架也称不上预研,入门门槛比较低,当然要精通都不是一蹴而就的,需要时间和经验的积累. 过早的使用某种技术势必要填很多的坑.于是在不断的填坑和弃坑中,度日如年…]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[攻城狮周记(四)]]></title>
      <url>http://www.lizorn.com//2016/09/12/readmemo/</url>
      <content type="text"><![CDATA[你的收入，为什么还没有指数增长？ 两个乞丐在比划说，我要是当上了皇帝，我要饭时候的那个碗，必须是纯金的。 打造自己能力的”单品爆款”,要专注,专业需要时间的积累. 做有价值的事,让自己增值. 经常复盘,我们要在有限的时间里，多做些战略上的努力，而不是战术层面的付出。原文 Saas产品如何运营原文 在大数据时代，每家公司都要有大数据部门吗？大数据都知道是一个方向,问题是谁能站在浪潮之巅?原文 邮件营销平台实践没接触过这个领域,长了点见识.邮件营销平台实践 直播技术代码居多原文 深度学习主题下周专题深入研究原文 Git配置管理git的配置管理和SVN有较多不同.SVN默认有三条配置流,trunk,branch,tag. git的master并不是svn的trunk,趋同于svn的tag,是对外可发布版本的最终标示,是一个完整的可部署的生产版本. 以下是一个不错的git配置管理模型: feature（多个、玫红）。主要是自己玩了，差不多的时候要合并回develop去。从不与master交互。 develop（1个、黄色）。主要是和feature以及release交互。 release（同一时间1个、绿色）。总是基于develop，最后又合并回develop。当然对应的tag跑到master这边去了。生命周期很短，只是为了发布 hotfix（同一时间1个、红色）。总是基于master，并最后合并到master和develop。生命周期较短，用了修复bug或小粒度修改发布。 master（1个蓝色）。没有什么东西，仅是一些关联的tag，因从不在master上开发。 在这个模型中，master和develop都具有象征意义。master分支上的代码总是稳定的（stable build），随时可以发布出去。develop上的代码总是从feature上合并过来的，可以进行Nightly Builds，但不直接在develop上进行开发。当develop上的feature足够多以至于可以进行新版本的发布时，可以创建release分 支。 release分支基于develop，进行很简单的修改后就被合并到master，并打上tag，表示可以发布了。紧接着release将被合 并到develop；此时develop可能往前跑了一段，出现合并冲突，需要手工解决冲突后再次合并。这步完成后就删除release分支。 当从已发布版本中发现bug要修复时，就应用到hotfix分支了。hotfix基于master分支，完成bug修复或紧急修改后，要merge回master，打上一个新的tag，并merge回develop，删除hotfix分支 主分支:master,develop, master分支为稳定版本,develop为整合分支可在之上进行日编译和持续集成.辅助分支:feature(功能开发),hotfix(热补丁),release(发布整合),生命周期较短 feature 分支使用规范： 可以从develop分支发起feature分支 代码必须合并回develop分支 feature分支的命名可以使用除master，develop，release-，hotfix-之外的任何名称 release分支使用规范 可以从develop分支派生 必须合并回develop分支和master分支 分支命名惯例：release-* release分支是为发布新的产品版本而设计的。在这个分支上的代码允许做小的缺陷修正、准备发布版本所需的各项说明信息（版本号、发布时间、 编译时间等等）。当develop分支上的代码已经包含了所有即将发布的版本中所计划包含的软件功能，并且已通过所有测试时，我们就可以考虑准备创建 release分支了。成功的派生了release分支，并被赋予版本号之后，develop分支就可以为“下一个版本”服务了。所谓的“下一个版本”是在当前即将发布的版本之后发布的版本。版本号的命名可以依据项目定义的版本号命名规则进行。 hotfix分支使用规范： 可以从master分支派生 必须合并回master分支和develop分支 分支命名惯例：hotfix-*和release分支一样hotfix分支都会产生新的版本号. 人员权限开发人员:feature,hotfix技术经理:feature,develop,hotfix,release运维:release,master测试人员:develop,release,master 原文 git基础 VC经济基本概念 VC经济基本概念 决策分析模型]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[攻城狮周记(三)]]></title>
      <url>http://www.lizorn.com//2016/09/05/readmemo/</url>
      <content type="text"><![CDATA[Yahoo开源Pulsar：大规模的发布/订阅（Pub-Sub）消息传递平台yahoo/pulsar python进行数据分析 基础知识:set,list,dict等数据架构 学习数据处理库:numpy,pandas等模块 csv,数据库等导入导出 爬虫:爬豆瓣,然后爬动态网站,爬的动80%的网站后,再挑战下淘宝,天猫等 web: django, flask, highcharts 文本挖掘:jieba分词模块 人工智能之机器学习路线图 精通机器学习的5本免费电子书原文 医学影像,成像蓝海原文 互联网数据分析书籍清单数据分析是一个好行当,部分书籍已看过.原文 打破定制旅游的产能边界原文 视频直播技术编码和封装原文 如何成为一名数据科学家原文]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[我皮肤上的字]]></title>
      <url>http://www.lizorn.com//2016/09/02/the-words-on-my-skin/</url>
      <content type="text"><![CDATA[翻译自科幻小小说,转载请注明出处. 原文 我的皮肤上写着字,字代表了我的个性. 我身上最大那几个字是母亲写的-机灵,有爱,随和,守记.它们写在我的背上,这是我自己无法接触的皮肤. 母亲的那几个最大的字叫体贴,由她的爸爸所赐,整个字填满了她的整个右手臂. 六岁,我还不太识字,我偷了母亲的那个笔,为自己选择了第一个词–快乐.当这两个字歪歪扭扭的出现在我的整个左前臂上时,母亲震惊了.私下在皮肤上写字的是违法的,母亲可能会因此失去持笔者的资格.但是母亲没有生气,她的身上没有愤怒,取而代之的是耐心和谅解. 持笔机制是这样的,只有少数的家庭成员负责持笔,成为持笔者就意味着更多的权利和责任,他们需要对用笔情况做备案报告,还时不时要受审查.违背了持笔规则会受到非常严厉的制裁.这种规则意图控制笔的滥用,但事实上,审查人员非常的腐败,用点金钱就可以买通了. 于是十岁,我又几次偷偷的在身上写了字–聪明,鬼祟,独立,一次也没被抓住. 十四岁,我半夜起来,再次在自己的大腿内侧写上–热情,敏感,轻浮.母亲为此多年没有和我说话,她默默在我的背上增加了三个词–责任,真实,谨慎. 母亲的管教激发了我的叛逆,我报复性在整个左身体写上了–艺术,粗鲁,野心,玩乐,爱交际,固执.母亲假装没有看到,她可能不想激化我们之间的矛盾,她也可能默许了我的选择,总之,她沉默了. 十八岁,我搬出了家,我给自己写上自信和性感. 我开始和一个老男人约会,我疯狂的爱上了他.他并不来自持笔者的家庭,所以他身上的词语非常匮乏,只有三个–勇敢,健壮,迷人.和他在一起很幸福,直到我发现了他的秘密和谎言.于是趁他睡着的时候,我冲动的在他的后劲(靠近耳朵那,他永远也不会看到那个地方)写上–忠诚,信任,诚实,有爱.结果第二天早上,他离我而去,再也没有回来. 我不知道他应该忠于谁,但我知道那个人不是我. 之后我又陷入到几场短暂的关系里,我的责任感和谨慎已经被刺激,狂野淹没了.我变得鲁莽而歇斯底里,虽然我身上并没有这些字.我感到茫然,我举足无措,更让我沮丧的是,我还怀孕了… 虽然母亲和我已经几个月没有联系了,我还是去了她那里.我很害怕她又会在我身上写字,害怕她会把我变成另外一个人,但她没有,她倾听了我的遭遇,安抚了我的焦虑,她耐心的等待着我,等待我持笔为自己写下此刻最需要的那几个字–母爱,信赖,聪慧. 现在,我的身上已经没有太多的位置可以写了,字越写越小,我的个性也变得越来越固定,不大会有太大的变化.我必须得小心翼翼的选词了,想着想着,我开始为年幼时候的冲动选择后悔万分,我对着母亲大声发泄着,”就让我这样吧”,我的眼泪和悔恨绝提而出. 随着宝宝的成长,我肚子上的皮肤延伸开来了,我落笔在这个额外的空间写上了–坚韧,力量,坚持,冷静, 这将有助于我的分娩. 我顺利产下了一个健康的男孩,他的皮肤就像一块空帆布,崭新而又纯粹,也承载了太多别人的期许. 母亲递给我那支笔,我准备在那张空白的背上写下什么. 什么词是宝宝最适合的?母亲和我苦思冥想. 我终于明白了应该写的字,但那些字不应该由我来写. 我于掰断了笔芯,把笔扔的远远的. 我爱我的儿子,不管他会变成什么. 他可以去做自己了.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[攻城狮周记(二)]]></title>
      <url>http://www.lizorn.com//2016/08/30/readmemo/</url>
      <content type="text"><![CDATA[百度Github技术栈原文 众安保险战略路线图原文 浏览器存储及使用原文 RN在直播应用中的实践原文 从0到N建立高性价比的大数据平台原文 直播技术知识库干活一瞥原文 一切商业皆内容,一切内容皆IP原文]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[攻城狮周记(一)]]></title>
      <url>http://www.lizorn.com//2016/08/22/readmemo/</url>
      <content type="text"><![CDATA[每周花时间阅读技术文章,摘录精华 花1小时写代码，就要花10小时检查代码。查找漏洞都成了写代码的一部分了，这个差距太悬殊。就算写代码多费点时间，代码也要简单易懂。—— Robert C. Martin《Clean Code: A Handbook of Agile Software Craftsmanship》 高性能开源通用RPC框架,谷歌出品以前用RPC开发过一个分布式系统,那么gRPC又是什么? 与许多 RPC 系统类似，gRPC 也是基于以下理念：定义一个服务，指定其能够被远程调用的方法（包含参数和返回类型）。在服务端实现这个接口，并运行一个 gRPC 服务器来处理客户端调用。在客户端拥有一个存根能够像服务端一样的方法。 grpc 高并发系统HTTP缓存 服务端响应的Last-Modified会在下次请求时以If-Modified-Since请求头带到服务端进行文档是否修改的验证，如果没有修改则返回304，浏览器可以直接使用缓存内容； Cache-Control:max-age和Expires用于决定浏览器端内容缓存多久，即多久过期，过期后则删除缓存重新从服务端获取最新的；另外可以用于from cache场景； http/1.1规范定义的Cache-Control优先级高于http/1.0规范定义的Expires； 一般情况下Expires=当前系统时间+缓存时间（Cache-Control:max-age）； http/1.1规范定义了ETag来通过文档摘要的方式控制。 nginx缓存配置见原文 携程大数据实践：高并发应用架构及推荐系统案例有比较大的参考价值,当然整体架构都描述的比较笼统. 应用系统的整体架构 数据源部分，Hermes是携程框架部门提供的消息队列，基于Kafka和MySQL做为底层实现的封装，应用于系统间实时数据传输交互通道。Hive和HDFS是携程海量数据的主要存储，两者来自Hadoop生态体系。 离线部分，包含的模块有MR、Hive、Mahout、SparkQL/MLLib。Mahout提供基于Hadoop平台进行数据挖掘的一些机器学习的算法包。Spark类似hadoop也是提供大数据并行批量处理平台，但是它是基于内存的。SparkQL 和Spark MLLib是基于Spark平台的SQL查询引擎和数据挖掘相关算法框架。携程主要用Mahout和Spark MLLib进行数据挖掘工作。 调度系统zeus，是淘宝开源大数据平台调度系统. 近线部分，是基于Muise来实现我们的近实时的计算场景，Muise是也是携程OPS提供的实时计算流处理平台，内部是基于Storm实现与HERMES消息队列搭配起来使用。例如，我们使用MUSIE通过消费来自消息队列里的用户实时行为，订单记录，结合画像等一起基础数据，经一系列复杂的规则和算法，实时的识别出用户的行程意图。 后台/线上应用部分，MySQL用于支撑后台系统的数据库。ElasticSearch是基于Lucene实现的分布式搜索引擎，用于索引用户画像的数据，支持离线精准营销的用户筛选，同时支持线上应用推荐系统的选品功能。HBase 基于Hadoop的HDFS 上的列存储NoSQL数据库，用于后台报表可视化系统和线上服务的数据存储。 这里说明一下, 在线和后台应用使用的ElasticSearch和HBase集群是分开的，互不影响。Redis支持在线服务的高速缓存，用于缓存统计分析出来的热点数据。 系统案例 数据源，分结构化数据和非结构化数据. 离线计算,经过数据预处理,数据挖掘,和数据配置后(建立ES索引),输出产品画像,用户画像等. 近线计算,输出用户意图和产品缓存. 全文 大数据4V特征大数据的特点,按照IBM提出的,4V特性: Volume(海量): 数量大 Velocity(速度): 数据量增长快 Variety(多样性): 各种各样类型的数据出现 Varacity(准确性): 数据的准确性 日志分析智能化日志是企业内部宝贵的IT大数据,相比excel和数据库而言,日志是非结构化数据,需要进行进一步的挖掘. 日志分析产品:Splunk,ELK,日志易 日志易的技术架构: 实现了搜索处理语言SPL（Search Processing Language），用户可以在搜索框里编写SPL脚本，对日志进行复杂的关联分析，非常强大、灵活，实现了“框计算” IOS动态更新方案JSPatch 是 iOS 平台上的一个开源库，只需接入极小的三个引擎文件，即可以用 JavaScript 调用和替换任意 Objective-C 方法，也就是说可以在 App 上线后通过下发 JavaScript 脚本，实时修改任意 Objective-C 方法的实现，达到修复 Bug 或动态运营的目的。 如果作为热更新工具,相比RN,更轻量级,更稳定些,学习成本也稍低些. 人工智能的挑战人工智能技术前景? 无监督预测学习,例如联想能力; 单例(有限例)学习; 结合贝叶斯统计的深度学习，使得融入由因到果或互为因果的relation变得容易； 层级增强的memory，reasoning，planning的表征方法； 深度增强学习； 动态neural turing machine及其变种。这些技术的落地应用,可以使得相当程度的机器智能改善人类生活,例如机器助理,自动驾驶,智能服务等. 技术人员需要学习那些人工智能技术? 人工智能未来应该是一种工具,会用就好,软件工程师需要考虑如何将人工智能的工具应用到实际产品中. 人工智能是一种思维方式,工程师重新审视自己的工作方式:是否可以借鉴AI来改善和提升现在的工作? 移动端高效实用SQLite原文 移动端少量的KV类型数据库可以直接存在文件上,稍微复杂一点的格式化成JSON或XML保存.在更大的量级上则需要使用SQLite. 数据库初始化设置合理的page_size和cache_sizeSQLite 数据库把其所存储的数据以 page 为最小单位进行存储。cache_size 的含义为当进行查询操作时，用多少个 page 来缓存查询结果. 可能影响到 page_size 和 cache_size 最优值选取的三个因素： table_size 存储的数据类型 增删查改比例 通过timer控制数据库事务定时提交一个Transaction能够大大的提升其内部的增删改查操作的速度.事务的引入能提升性能两个数量级以上. 数据库完整性校验移动客户端的数据库运行环境比较复杂,需呀校验数据库的完整性, 1PRAGMA integrity_check 如执行失败就需要回滚到上一个版本. 数据库升级逻辑可以在meta表中并加入版本号,SQL语句需通过版本号来提供兼容性. 123CREATE TABLE meta (key LONGVARCHAR NOT NULL UNIQUE PRIMARY KEY, value LONGVARCHAR)INSERT OR REPLACE INTO meta (key,value) VALUES (version, 1)INSERT OR REPLACE INTO meta (key,value) VALUES (last_compatible_version, 1) 高效SQL语句 建立索引，就是将这列以及主键所有数据取出。以索引列为主键按照升序，原表主键为第二列，重新创建一张新的表。使其搜索速度降低到 Log(N)。 先SELECT 再选择 INSERT OR UPDATE 的方法。 FTS(Full Text Search)是SQLite未加快字符串搜索而创建的虚拟表.通过分词大大加快英文类/中文类字符串(配合ICU)的搜索速度. 为做到数据库Model跨IOS,Android平台,用protobuf作为数据库的输入输出参数.两个平台用一份proto文件分别生成各自的实现文件. 不是用SQLite的多线程实现,多线程会增加线程开销而且操作加锁,性能比较差. 加密数据库.加密对性能损耗大约是3%的CPU时间. 移动端开发流程 web端流程. 产品经理提出需求(原型等)&gt;讨论需求&gt;通过需求&gt;交付设计师设计layout&gt;确认&gt;切页面&gt;交付工程师开发&gt;后端(前端)定接口&gt;前后端并行开发&gt;修改细节及bug&gt;上线。 移动客户端. 产品经理提出需求(原型等)&gt;讨论需求&gt;通过需求&gt;设计layout(包括交互设计及ui设计)&gt;确认&gt;切图&gt;交付工程师开发&gt;后端接口开发/移动开发&gt;上线。 大体上的流程都不会变,移动端的如果使用Native开发,那前端就消失了,切图部分交给UI来做. 移动端的产品设计交互性和逻辑性会更强,所以原型设计需要由设计把控交互部分,如果产品经理无法把控交互部分,至少要画出概念图和流程图,交给设计师进行设计. 移动设计相比web端设计有一些异同点: 字体选用. web端一般是宋体或者微软雅黑. IOS:冬青黑体或者华文黑体. Android: Droid Sans Fallback, 冬青黑或者华文黑也可以考虑. 简单易用. 分辨率. iphone + andorid存在大量的分辨率,需要设计适配. 切图. 安卓和iphone差别交互设计. 架构设计主要是后端,需要考虑如何提供高性能的API接口,接口的制定可以由后端牵头也可以由移动开发人员牵头. 运营产品核心指标分析流程电商产品 SaaS类产品和移动用户产品的核心指标 内容网站关注的核心指标 UGC,社交站关注的核心指标 双边市场(服务方与提供服务方)关注的指标 融资相关流程异步36氪]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[活着为了讲述]]></title>
      <url>http://www.lizorn.com//2016/08/13/vivir-para-contarla/</url>
      <content type="text"><![CDATA[我是个爱讲故事的孩子,我想说的是:爱真的存在,幸福真的可能,死神也会败在幸福的手下. 《活着为了讲述》是诺贝尔文学奖获得者，《百年孤独》作者加西亚·马尔克斯唯一传记,14年,新闻头条报道了这位文学巨匠的陨落,当时就非常想看这本书.马尔克斯是个爱讲故事的人,在虚实之间，在&lt;&lt;活着为了讲述&gt;&gt;里他亲自讲述了自己的故事。 马尔克斯出生于哥伦比亚马格达莱纳的一个海滨小镇–阿拉卡塔卡,童年和外祖父母一起生活.他的父亲和大多数的欧美父母一样,希望他以后过上体面而稳定的生活–做一个律师,但马尔克斯对写作有着无限的遐想和热情,’要么写作,要么死去!’,’个人志向与生俱来,背道而驰,有违健康.顺势而行,灵丹妙药’.马尔克斯不但成为了一个作家,更跃升成为20世纪伟大的文学大师之一. 自传里提及了他非常多的短篇小说,一个灵感就促成了一篇故事,受卡夫卡《变形记》启发的《第三次忍受》,因美女一句话而写成的《埃娃在猫身体里面》,石鸻鸟啄人一触而就《石鸻鸟之夜》,遗憾的是这本自传并未完成,最后停留在马尔克斯的青年时期,那个时候&lt;&lt;百年孤独&gt;&gt;还未问世,还藏匿在&lt;&lt;家&gt;&gt;中,也许在他心中这才是真实的自己,&lt;&lt;百年孤独&gt;&gt;的成功反而成为一种桎梏. 马尔克斯的&lt;&lt;活着为了讲述&gt;&gt;即像小说又像自传,他自述了一个浓缩的世界,喧嚣纷乱却又生动可信的显示了一片大陆及其人民的富足和贫困,以及,妖娆妩媚的哥伦比亚女人在这个贫穷,落后的,但充满生机的小镇里抽烟,喝酒,调情,生育和生存… 生活不是我们活过的日子,而是我们记住的日子,我们为了讲述而在记忆中重现的日子.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[讲故事的人：斯皮尔伯格传]]></title>
      <url>http://www.lizorn.com//2016/08/10/Steven-Allan-Spielberg/</url>
      <content type="text"><![CDATA[其实每一部电影都是一个时间胶囊,当你拍完一部影片,向演职人员道别时,你也把一段生命埋在了那个片场——你知道的,而那段生命将会永远留在那里. 史蒂文·斯皮尔伯格1946年12月18日出生于俄亥俄州的辛辛那提市一个美国犹太家庭，12岁就开始执导,是个天才.在长达40多年的岁月里,史蒂文·斯皮尔伯格创造了鼓舞人心并且令人难以忘怀的影坛奇迹.他执导的电影范围也很广,惊悚片’&lt;&lt;大白鲨&gt;&gt;’,科幻片’&lt;&gt;’,动作片’&lt;&lt;夺宝奇兵&gt;&gt;’,剧情片’&lt;&lt;辛德勒的名单&gt;&gt;’,战争片’&lt;&lt;太阳帝国&gt;&gt;’钧有代表作. 斯皮尔伯格的电影我大部分都看过,印象比较深的还属&lt;&lt;辛德勒的名单&gt;&gt;.那时我还在大学里,不识愁滋味,过着一天5部电影的日子… 评价一本书的好坏需要50年以后,评价一个人一样,所以一本写当世人的传记更是不好写的,这需要岁月的沉淀和时间的审批.不过这本书也不应该称为传记,充其量是一些访谈语录加上对斯皮尔伯格电影创作的一些梳理,有电影创作的幕后故事以及创作意图但并未深入,作者的文笔也比较一般. 全书的插图较多,但排版太差,打乱了几次正文的衔接,尤其是在不熟悉的时候,比如翻看第一页的时候正文断了,第二页接了两页插图,第四页才是续接的正文,实在让人摸不清道不明. 适合电影爱好者购入,翻看,收藏. {:height=”120px” width=”120px”}]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[渴望生活]]></title>
      <url>http://www.lizorn.com//2016/08/09/lust-for-life/</url>
      <content type="text"><![CDATA[开启不同于前人的艺术，启发后人的艺术，这就是梵高作品的伟大之处。 梵高.温森特励志成为一名福音传教士,由于他并未完成传教士的学业,于是屈就到博里那日的矿区传教.他感受到了博里那日煤矿工人生活的艰辛和他们的朴实,然而在一次矿井坍塌事故中,矿产公司的残忍,福音教会的傲慢偏执和不作为,让他开始质疑上帝的存在,上帝放弃了这些朴实和卑微的旷工.他也因此失去了成为传教士的资格,失去了上帝,失去了自己. 他明白了有些上帝的话,不过是孩子气的借口和托词,是一个吓坏了的孤独的人在寒冷,漫长的黑夜中,由于绝望而散布编造的谎言.没有什么上帝,事情就是这么简单.压根就没有上帝,只有混乱–悲惨的,痛苦的,残忍的,莫名其妙的,无止无休的混乱. 吃土豆的人,1885 梵高在上帝退场后,终于投入了绘画的怀抱.他并没有绘画的基础,虽然他的画比例失调,但他的画有一些说不清道不明的东西…… 梵高过于迷恋绘画,显然他周围的人都无法理解,’有谁会盯着一颗树,顶着一头烈日,画一天的画呢’.在他穷困潦倒的一生里全靠他的弟弟提奥资助过活.在经常饿着肚子,发着烧,身无分文的情况下,梵高完成一副又一副的作品,他对绘画的热爱是狂热的,犹如他对爱情的渴望那样,虽然他的爱情总是不顺的. 人的行为,非常像画画.整个透视关系随着眼睛的变化而变化,起决定作用的并不是被绘画的对象,而是正在看它的人. 塞纳河上的桥,1886 梵高早期在荷兰自学绘画,最后到了巴黎–这座艺术的天堂,他才受到了艺术的召唤,他的艺术形态开始形成.在那他受到了前所未有的冲击,他的画是那么的与众不同,不同到差点让他放弃绘画生涯,梵高的画色彩强烈，色调明亮。他那富于激情的旋转、跃动的笔触，则使他的麦田、柏树、星空等，有如火焰般升腾、颤动，震撼观者的心灵。在他的画上，强烈的情感完全溶化在色彩与笔触的交响乐中,他是表现主义的先驱. 梵高觉得巴黎过于喧嚣于是独自一人来到了法国南方的城市’阿尔勒’,重新过上了贫困的,清苦的,但是纯粹的只有绘画的生活. 我在寻求,我在奋斗,我在全心全意的投入到艺术之中.我不属于这儿。我是个农民画家，我要回到我的田野上去。我要找到一个太阳，它炽热得能把我心中除了绘画这种慾望以外的一切都烧光。 向日葵,1888 在阿尔,他精神已经有些不正常了,他知道了,长时间观看事物,才能使他的思想更成熟,理解更深刻.他把他的朋友保尔高更也接到了一起住,于是两个精神病人开始了无止尽的争论.在绘画的领域,梵高是一座真正的火山,而高更则是满腔热血沸腾,即便是没有分歧的部分,他们的讨论也是惊心动魄的. 黄房子,1888 我画太阳时，要画得让人们感觉到它以可怕的速度在旋转。它发射出力量无穷的光波和热波。我画麦田时，要人们感觉到谷粒中的原子在生长、爆裂。我画苹果时，要人们感觉到苹果中的液汁溅到皮肤上，果核中的种籽在往外钻向开花结果！ 当我画一个在田里干活的农民的时候,我希望人们感觉到,农民就像庄稼那样正向下融会到土壤里面,而土壤也向上融会到农民身上.我希望人们感受到,太阳正注入到农民,土地,庄稼,犁和马的内部,恰如他们反过来又注入到太阳里面一样.当我开始感受到事件万物运动的这一普遍的节奏时,你才开始懂得了生活.只有这,才是主宰一切的上帝. 是的,梵高的上帝已经死了,他成为主宰自己生活的上帝,也是他绘画的源泉. 然而正是这份对艺术的热爱和执着与生活的艰辛形成鲜明的对比,时时刻刻折磨着他的神经,’他是一个因善良受苦的天使,也是一个用色彩享乐的天才’,最后他割下了自己的耳朵…随后,他被送入圣雷米的疗养院,在那个安静的世界里,他的内心更为纯净,他画了星空,绽放了他内心最纯净的颜色. 星空,1889 我想,对生活充满热爱的人们都应该读一下这本书,去感受一下这个崇高的灵魂,感受一下它的孤独,感受一下我们拥有的幸福. 致敬梵高! 麦田里的乌鸦,1890]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[建国大业]]></title>
      <url>http://www.lizorn.com//2016/08/08/blockbuster-Founding-of-the-Republic/</url>
      <content type="text"><![CDATA[‘念奴娇·昆仑 横空出世，莽昆仑，阅尽人间春色。 飞起玉龙三百万，搅得周天寒彻。 夏日消溶，江河横溢，人或为鱼鳖。 千秋功罪，谁人曾与评说? 而今我谓昆仑：不要这高，不要这多雪。 安得倚天抽宝剑，把汝裁为三截? 一截遗欧，一截赠美，一截还东国。 太平世界，环球同此凉热。’ 终于读完了这几本书,本意是一周完成的专题阅读,无奈工作过于操心,迟迟未能完成.上面的诗是在长征途中所写，毛泽东登上岷山峰顶，远望青海一带苍茫的昆仑山脉有感而作。整首诗气势磅礴,放眼天下.长征确定了老毛的领袖地位,长征更是宣传书,是宣传队,共产党是播种机. 传记系列的书我本不想涉及,因为传记太虚,虚了那远不如看小说了,而且大部分的自传都是写成他传,他传就是自传,总是会带有一些目的性.尤其是这几人的官方传记,更是具有强烈的政治诉求.所幸挑的这几版书均是国外名人所写,应当还具有一定的客观性吧. 一口气看完这四本书,20世纪的中国从暗潮汹涌,到动荡不安,到建国立业,经历太多.看完后恍如隔世,国外写的传记并未毁三观,大事件还是那几个大事件,想来历史是照妖镜总不至于过于捏造. 几本书都对’大跃进’描述比较少,应该是资料较少的缘故,善长宣传的共产党保密工作确实做的不错.对几个敏感事件也没有太明晰的描述,比如类似89年天安门事件,是谁下令开的枪?并未明说!觉得可能是译者的原因吧,毕竟是要在中国出版的,虽不至于造神但还是有些避讳的,于是翻墙Google了原版,均要收费,无果. 笔记以史为鉴,20世纪的中国动荡不安,经历了辛亥革命-&gt;五四运动-&gt;国民党成立-&gt;共产党成立-&gt;国共第一次合作-&gt;北伐全国一统一-&gt;剿共-&gt;九一八事变-&gt;西安事变-&gt;国共联合抗日-&gt;抗日胜利-&gt;国共内战-&gt;中华人民共和国成立-&gt;百花齐放-&gt;大跃进-&gt;文化大革命-&gt;四人帮事件-&gt;天安门事件-&gt;中国经济起飞. 从几大事件看来,蒋公失天下是必然的,作为一个政治家和政治领袖,蒋介石是一个战术家而不是战略家,虽然他善于玩弄权术并牢牢的控制了中国人口的大多数,但他实际上不了解整个政权的社会基础.蒋介石是个悲剧人物,他的悲剧是他自己造成的,虽然他有勇气,有精力,有领袖品质,但他缺乏战略眼光,在关键的时刻做了不该做的决定,该攘外的时候坚持按内,该剿匪扫荡的时候又做的不够彻底,丢了民心丢了权利. 而老毛不同,毛虽没有喝过洋墨水,但他有非常高的战略眼光,他从农民中来到农民中去,毛泽东给了农民最想要的东西：“土地和同多年来压迫他们的地主们算帐的机会。” 他来自中国’受虐待的一方’,他所知道是贫困,堕落,剥削和非正义,这些东西他花费了一生在做搏斗.他具备强大的政治野心和执行力,他把改造世界的愿望从教室里带到政治竞技场,在解放人民方面他是光辉的,但在管理复杂的政治军事方面他是不成功的.老毛喜欢斗争,所以他的周围都在斗争中度过.老毛缺乏治理能力,思想极度左倾,而新中国在动荡中最终得以站稳,这都是下面两位的功劳. 周恩来原先在日本留学,五四运动的时候回到上海,随后又到法国求学,回来领导了上海的几次大罢工,早早就成为了中共关键领导人.周的视野比较开阔,有非常大的包容性.他对共产主义的信仰是真诚的,正如他对中国的感情和他那持久的任性也是发自内心的一样.然而他却是典型的儒家政治家,做事比较温和,缺乏领导能力,无法掌舵中国这艘大船,所以最后只能做个大副.周在毛统治的阶段小心翼翼的不进行政治站队,在几次大事件相安无事,充当着调和员和补救者的角色.他并未留恋权利,连子嗣都没有留下,一心辅佐毛,治理中国,对他选择的道路,我们内心感到欣慰,对他身后的中国,我们充满了希望. &lt;&lt;邓小平传&gt;&gt; (英)理查德.伊文思伊文思是英国驻中国大使,同时也是一位中国社会问题研究专家,他在20世纪50年代,60年代,80年代先后在中国呆了8年,同时也直接参与了英国问题的谈判,他始终关注着中国,关注着邓小平.他已相对客观公平的眼光展示和解读了邓小平波澜壮阔的一生. &lt;&lt;毛泽东传&gt;&gt; (英)迪克.威尔逊 &lt;&lt;周恩来传&gt;&gt; (英)迪克.威尔逊 &lt;&lt;蒋介石传&gt;&gt; (美)布兰恩.克洛泽]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[极简欧洲史]]></title>
      <url>http://www.lizorn.com//2016/06/30/Shortest-History-of-Europe/</url>
      <content type="text"><![CDATA[欧洲文明是独特的,因为它一直是唯一能让世界其他地区马首是瞻的文明.它之所以可以做到这点,是靠不断的征服和定居,强大的经济势力和思想观念,以及拥有其他人向往的东西. 该书的欧洲史划分包括古典时期、中世纪和近代。古典时期从公元元年到476年日耳曼蛮族入侵，西罗马帝国灭亡；中世纪从476年到1400年。希腊人贡献了哲学,艺术,文学,数学,科学,医学以及政治思想的源头.罗马人则建立强大的帝国,并有着先进的建筑技术与治理国家的法律.整个欧洲的文明建立在希腊文明和罗马文明之上.宗教是一种粘合剂,将不同的文明粘合在一起. 宗教世界 只要相信耶稣，你便能得救，死后免受地狱火烧之苦，还能升入天堂。 希腊人的观点:这是一个简单,符合逻辑,能以数学表达的世界.基督教的观点:这是个邪恶的世界,唯有耶稣能拯救它.日耳曼蛮族的观点:打仗是好玩的事.这些元素组合在一起,造就了欧洲的文明. 几次革命浪潮 文艺复兴着眼的是古希腊和罗马的智识成就,新教改革者则是频频回顾罗马教廷承袭罗马习性之前的基督教会. 数学是科学的中心.顿和爱因斯坦都说: 答案应该简单,符合逻辑,能以数学表达,唯有答案简单,才可能近乎正确. 军政演变 好战者和基督教的结合是个矛盾体,前者崇尚武力,而耶稣说”要爱你的敌人”,于是就有了骑士-保护弱者,战斗被赋予了这种新的道德意涵,一个男人要借由一种犹如宗教的仪式才能成为骑士,骑士绝迹之后,就演变成了”绅士”. 人是善变无常的,优柔寡断的,浅薄无知的,容易被操弄的,而政治是一种精细的艺术,需要智慧和良好的判断 近代农工制圈地运动 田地制度 为什么欧洲跑第一?中国以前很强大,但近代中国对世界几乎没有什么贡献.不管是科学上,军事上,经济上,政治上,哲学上,中国都扮演着拿来主义者,山寨者的角色,走着自己所谓的中国特色.反观欧洲,为什么欧洲可以跑第一? 不是所有东西都归国王所有,这是欧洲自由和繁荣的基石. 权利分散,遗产多元. 信仰. 没有信仰的中国人确实是可怕的,会少一份道德上的约束.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Angularjs2教程:英雄之途]]></title>
      <url>http://www.lizorn.com//2016/06/17/angularjs2-TUTORIAL-TOUR-OF-HEROES/</url>
      <content type="text"><![CDATA[转摘请说明出处! 译者自序:仅是自己学习的时候顺便翻译下,仅当做笔记加深印象之用,并未对所翻译内容进行过复查和校对,应该会有大量狗屁不通的地方,建议还是看官方原文吧 Tour of Heroes教程一步一步教大家如何用TypeScript写Angular应用.* 介绍英雄之旅:预览我们更大的计划是创建一个应用,帮助人员管理机构来管理英雄们,即使是英雄他也需要有一份工作. 当然本教程会进一步深入使用Angular来构建应用.在一个成熟的,数据驱动的应用中我们需要购将非常多的功能:获取和展示英雄列表,编辑选中的英雄细节,英雄数据视图导航等. 英雄之旅覆盖了Angular的核心功能,我们使用内置指令显示/隐藏元素并展示英雄数据列表.我们创建一个组件用于展示英雄细节,另外一个组件用于显示所有的英雄列表.我们增加一个可编辑字段通过双向数据绑定的形式更新model.我们将组件的方法绑定到用户事件上,如键盘敲击或者鼠标点击.我们将学习如何从主列表内选择英雄并在细节视图里编辑他.我们通过pipes格式化数据.我们将会创建一个共享服务来收集我们的英雄.我们将使用路由功能来实现不同视图和组件之间的导航. 我们将会接触到足够多的Angular的核心功能,我们会发现Angular很强大几乎可以用来实现任何的应用.在线示例 最终效果这是这个应用的最终效果,从仪表盘可以浏览我们的主要应用:仪表盘上面有两个链接(“Dashboard”和”英雄们”).我们可以通过点击它们导航到这个仪表盘和英雄视图中. 我们点击仪表盘上的名为”Magneta”的英雄,会有这个英雄的细节展示,并且我们可以修改英雄的名字.点击”Back”按键,我们可以返回”Dashboard”.顶部的导航栏可以带我们进入任一一个主要视图.我们点击”Heroes”,应用就会展示英雄们的列表视图.我们点击不同的英雄,会有一个可读的小细节展示到我们的点击处. 下图列出了我们导航栏的选择流程图:以下是APP的动画效果: 下一步我们开始一步步构建英雄之旅这个应用了,我们每一步都是为了解决应用中某个需求为目的的.我们一起来见识下Angular非常多的核心功能. 英雄编辑器从前…每一个故事都得从某一个时间开始,我们的故事从QuickStart教程介绍开始. 运行教程这部分的示例: live example 创建一个名为angular2-tour-of-heroes的文件夹,并跟着快速入门教程进行工程的预配置和安装. 你也可以直接下载快速入门源码 最终结构如下:我们最终的工程文件结构如下：1234567891011121314151617181920212223--angular2-quickstart----app------app.component.ts------main.ts----node_modules ...----typings ...----index.html----package.json----styles.css----systemjs.config.js----tsconfig.json----typings.json 保持app在线编译和运行实时监控文件改变,编译TypeScript并更新app,我们只需: npm start 这个命令运行编译器的观察模式,启动服务,在浏览器里打开应用,并维持app持续构建和运行. 英雄展示我们想在APP里显示英雄.让我们增加两个特性到AppComponent, title表示应用的名字,hero赋值一个英雄,名为Windstorm. 1234export class AppComponent &#123; title = &apos;Tour of Heroes&apos;; hero = &apos;Windstorm&apos;;&#125; 更新@component装饰器里的模板,将数据绑定到新的特性里. 1template: &apos;&lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt;&lt;h2&gt;&#123;&#123;hero&#125;&#125; details!&lt;/h2&gt;&apos; 此时浏览器应该会刷新并显示title和英雄名. 双大括号表示读取和渲染组件内的title和hero特性,这是单向数据绑定的”插值”形式. 关于’插值’更详细的信息请查看 数据展示章节 英雄对象现在,我们的英雄就只有一个名字而已,我们想要更多的特性,我们需要把它转换成类. 创建一个带有id和name特性的Hero类,暂时放到app.component.ts文件里,import语句之下. 1234export class Hero &#123; id: number; name: string;&#125; 现在我们有了Hero类,让我们重构下hero特性: 1234hero: Hero = &#123; id:1, hero:&apos;Windstorm&apos;&#125;; hero特性从字符串变成了类,修改模板里的对应字段: 1template: &apos;&lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt;&lt;h2&gt;&#123;&#123;hero.name&#125;&#125; details&lt;/h2&gt;&apos; 修改HTML模板我们现在需要显示更多的信息,不仅仅是名字,修改下html模板: 123456template:` &lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt; &lt;h2&gt;&#123;&#123;hero.name&#125;&#125; details!&lt;/h2&gt; &lt;div&gt;&lt;label&gt;id: &lt;/label&gt;&#123;&#123;hero.id&#125;&#125;&lt;/div&gt; &lt;div&gt;&lt;label&gt;name: &lt;/label&gt;&#123;&#123;hero.name&#125;&#125;&lt;/div&gt; ` 编辑英雄我们需要在文本框里编辑英雄的名字,重构英雄名字部分的模板,增加一个&lt;input&gt;元素. 123456789template:` &lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt; &lt;h2&gt;&#123;&#123;hero.name&#125;&#125; details!&lt;/h2&gt; &lt;div&gt;&lt;label&gt;id: &lt;/label&gt;&#123;&#123;hero.id&#125;&#125;&lt;/div&gt; &lt;div&gt; &lt;label&gt;name: &lt;/label&gt; &lt;input value=&quot;&#123;&#123;hero.name&#125;&#125;&quot; placeholder=&quot;name&quot;&gt; &lt;/div&gt; ` 现在浏览器上英雄名字确实显示到了&lt;input&gt;文本框里.但似乎有些不对,当我们改变名字的时候,我们发现这些改变并没有反应到&lt;h2&gt;里.这种单向绑定到&lt;input&gt;的形式无法满足需求. 双向绑定我们现在的需求是这样的,&lt;input&gt;框内显示英雄的名字,修改它,绑定了这个英雄名字的其他地方都需要对应改变.简而言之,我们想要双向数据绑定. 让我们使用ngModel这个内置指令来实现双向绑定. 关于ngModel的更多信息可以查看表单和模板语法章节 用以下HTML替换&lt;input&gt;: 1&lt;input [(ngModel)]=&quot;hero.name&quot; placeholder=&quot;name&quot;&gt; 刷新浏览器,我们再次编辑英雄的名字,可以发现&lt;h2&gt;里的内容也可以联动起来了. 本章小结让我们看看本章做了些什么. 英雄之旅使用大括号插入显示应用的title以及hero对象特性. 通过使用内建指令ngModel对&lt;input&gt;元素和组件数据进行双向绑定 ngModel指令将数据变化响应到绑定的hero.name特性上. app.component.ts代码如下: 123456789101112131415161718192021222324import &#123; Component &#125; from &apos;@angular/core&apos;;export class Hero &#123; id: number; name: string;&#125;@Component(&#123; selector: &apos;my-app&apos;, template: ` &lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt; &lt;h2&gt;&#123;&#123;hero.name&#125;&#125; details!&lt;/h2&gt; &lt;div&gt;&lt;label&gt;id: &lt;/label&gt;&#123;&#123;hero.id&#125;&#125;&lt;/div&gt; &lt;div&gt; &lt;label&gt;name: &lt;/label&gt; &lt;input [(ngModel)]=&quot;hero.name&quot; placeholder=&quot;name&quot;&gt; &lt;/div&gt; `&#125;)export class AppComponent &#123; title = &apos;Tour of Heroes&apos;; hero: Hero = &#123; id: 1, name: &apos;Windstorm&apos; &#125;;&#125; 未来之路现在的应用只展示了一个英雄,我们希望展示一个英雄的列表,同时允许用户可以点击选择查看他们的详情.下一章节,我们将会学习到如何获取一个列表,并将他们绑定到模板上,渲染到页面可供用户选择. Master/Detail有很多英雄我们的故事需要更多的英雄.我们可以扩展英雄之旅APP展示英雄列表,允许用户选择英雄并显示英雄的详情. 这部分的在线示例. 让我们来预估下显示一个英雄列表需要做点什么. 首先,我们需要一个英雄的列表数据.然后,我们将它通过视图模板展示出来. 显示英雄们创建英雄数据在app.component.ts底部创建一个包含10个英雄的数组. 123456789101112const HEROES: Hero[] = [ &#123; id: 11, name: &apos;Mr. Nice&apos; &#125;, &#123; id: 12, name: &apos;Narco&apos; &#125;, &#123; id: 13, name: &apos;Bombasto&apos; &#125;, &#123; id: 14, name: &apos;Celeritas&apos; &#125;, &#123; id: 15, name: &apos;Magneta&apos; &#125;, &#123; id: 16, name: &apos;RubberMan&apos; &#125;, &#123; id: 17, name: &apos;Dynama&apos; &#125;, &#123; id: 18, name: &apos;Dr IQ&apos; &#125;, &#123; id: 19, name: &apos;Magma&apos; &#125;, &#123; id: 20, name: &apos;Tornado&apos; &#125;]; 数组HEROES是Hero类型的,类型已在上一章节定义,为了创建这个英雄数组.我们最终希望可以从web service获取这个列表,目前我们先用模拟数据代替. 展示英雄AppComponent里创建一个public的heroes特性并绑定. 1public heroes = HEROES; 我们并不需要声明heroes类型,TS可以隐式赋值为HEROES数组. 在模板里展示英雄我们的组件有heroes,让我们再创建一个无序列表.将以下的HTML代码插入到模板里. 123456&lt;h2&gt;My Heroes&lt;/h2&gt;&lt;ul class=&quot;heroes&quot;&gt; &lt;li&gt; &lt;!-- each hero goes here --&gt; &lt;/li&gt;&lt;/ul&gt; 现在我们已经有模板了,开始填充英雄数据. 使用ngFor展示英雄列表我们想绑定heroes数组绑定到组件的模板里,并迭代渲染展示他们. 首先修改&lt;li&gt;标签,增加内置指令*ngFor. 1&lt;li *ngFor=&quot;let hero of heroes&quot; &gt; 前置符*表示&lt;li&gt;元素节点以及它的子孙节点组成一个主模板.ngFor指令迭代AppComponent.heroes数组,并放入hero变量中. 现在我们可以在&lt;li&gt;标签里插入一些内容了: 123&lt;li *ngFor=&quot;let hero of heroes&quot;&gt; &lt;span class=&quot;badge&quot;&gt;&#123;&#123;hero.id&#125;&#125;&lt;/span&gt; &#123;&#123;hero.name&#125;&#125;&lt;/li&gt; 样式化我们的英雄列表看起来比较乏味,我们需要一些视觉效果,如在某个英雄上鼠标悬停或者英雄选择. 通过在@component里设置styles特性.将样式加入到组件. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849styles: [` .selected &#123; background-color: #CFD8DC !important; color: white; &#125; .heroes &#123; margin: 0 0 2em 0; list-style-type: none; padding: 0; width: 15em; &#125; .heroes li &#123; cursor: pointer; position: relative; left: 0; background-color: #EEE; margin: .5em; padding: .3em 0; height: 1.6em; border-radius: 4px; &#125; .heroes li.selected:hover &#123; background-color: #BBD8DC !important; color: white; &#125; .heroes li:hover &#123; color: #607D8B; background-color: #DDD; left: .1em; &#125; .heroes .text &#123; position: relative; top: -3px; &#125; .heroes .badge &#123; display: inline-block; font-size: small; color: white; padding: 0.8em 0.7em 0 0.7em; background-color: #607D8B; line-height: 1em; position: relative; left: -1px; top: -4px; height: 1.8em; margin-right: .8em; border-radius: 4px 0 0 4px; &#125;`] 请注意,组件样式只有该组件有效,不会影响到其他的HTML.现在用于展示英雄列表的模板如下: 123456&lt;h2&gt;My Heroes&lt;/h2&gt;&lt;ul class=&quot;heroes&quot;&gt; &lt;li *ngFor=&quot;let hero of heroes&quot;&gt; &lt;span class=&quot;badge&quot;&gt;&#123;&#123;hero.id&#125;&#125;&lt;/span&gt; &#123;&#123;hero.name&#125;&#125; &lt;/li&gt;&lt;/ul&gt; 选择英雄我们有一个英雄列表,我们也有了单个英雄的显示界面,但目前两者还没有关联起来.我们接下来想要做的是,在英雄列表里点击英雄,可以查看这个英雄的详情.这种UI模式就是广泛使用的master-detail.在这个示例中,master是英雄列表,detail是选择的英雄.让我们通过一个绑定点击事件的selectedHero组件来连接master和detail. 点击事件修改模板&lt;li&gt;标签,插入Angular事件绑定到鼠标点击事件. 123&lt;li *ngFor=&quot;let hero of heroes&quot; (click)=&quot;onSelect(hero)&quot;&gt; &lt;span class=&quot;badge&quot;&gt;&#123;&#123;hero.id&#125;&#125;&lt;/span&gt; &#123;&#123;hero.name&#125;&#125;&lt;/li&gt; 来看看事件绑定: 1(click)=&quot;onSelect(hero)&quot; 这个插入语指示了&lt;li&gt;元素是click事件的目标,在等于符号右边的表达式调用了AppComponent方法,onSelect(),将模板内的变量hero作为参数传入,这个参数就是ngFor遍历的变量hero. 更多关于事件绑定可以查看用户输入和模板语法章节. 增加点击句柄我们的事件绑定的onSelect方法还没有实现,下面就来实现这个方法. 首先我们思考下,这个方法应该做些什么?它应该将组件内的选择英雄属性设置为用户点击的英雄. 声明选择的英雄我们现在不需AppComponent组件内静态的hero特性了,用selectedHero特性替换它: 1selectedHero: Hero; selectedHero不进行初始化,如果用户不点击,这个值就为空.现在增加一个onSelect方法,将点击的hero特性设置为selectedHero. 1onSelect(hero: Hero) &#123; this.selectedHero = hero; &#125; 将模板展示数据绑定selectedHero特性上. 123456&lt;h2&gt;&#123;&#123;selectedHero.name&#125;&#125; details!&lt;/h2&gt;&lt;div&gt;&lt;label&gt;id: &lt;/label&gt;&#123;&#123;selectedHero.id&#125;&#125;&lt;/div&gt;&lt;div&gt; &lt;label&gt;name: &lt;/label&gt; &lt;input [(ngModel)]=&quot;selectedHero.name&quot; placeholder=&quot;name&quot;/&gt;&lt;/div&gt; 使用ngIf过滤空异常当我们的app加载起来,我们看到英雄的列表,但此时没有英雄被选择,selectedHero是undefined.浏览器的控制窗口会有如下的打印: 1EXCEPTION: TypeError: Cannot read property &apos;name&apos; of undefined in [null] 我们之后会将英雄的详情作为组件移除,就不存在这个问题了,但在那之前要处理掉这个问题,就需要判断selectedHero是否为undefined,我们可以使用内置ngIf指令: 12345678&lt;div *ngIf=&quot;selectedHero&quot;&gt; &lt;h2&gt;&#123;&#123;selectedHero.name&#125;&#125; details!&lt;/h2&gt; &lt;div&gt;&lt;label&gt;id: &lt;/label&gt;&#123;&#123;selectedHero.id&#125;&#125;&lt;/div&gt; &lt;div&gt; &lt;label&gt;name: &lt;/label&gt; &lt;input [(ngModel)]=&quot;selectedHero.name&quot; placeholder=&quot;name&quot;/&gt; &lt;/div&gt;&lt;/div&gt; ngIf和ngFor都叫做结构指令,因为他能够改变DOM的部分结构,更对内容请查看结构指令和模板语法章节. 刷新浏览器,我们可以看到英雄列表,但我们并没有选择英雄的详情页.当selectedHero为undefined的时候,ngIf从DOM过滤掉了这部分节点.当我们点击一个列表里的英雄,详情页面会出现,这就是我们想要的效果. 美化slection被选择的英雄没有很直观的标示在英雄列表里,我们可以使用selected CSS类来改变主元素的样式. 1[class.selected]=&quot;hero === selectedHero&quot; 中括号里的class.selected,这是一种特性绑定的方法,即从某个数据源(表达式 hero === selectedHero)单向流入到特性中. 12345&lt;li *ngFor=&quot;let hero of heroes&quot; [class.selected]=&quot;hero === selectedHero&quot; (click)=&quot;onSelect(hero)&quot;&gt; &lt;span class=&quot;badge&quot;&gt;&#123;&#123;hero.id&#125;&#125;&lt;/span&gt; &#123;&#123;hero.name&#125;&#125;&lt;/li&gt; 可以在模板语法章节查看更多关于特性绑定的内容. 重新加载app到浏览器,我们选择英雄Magneta,就有高亮标示了. 完整的app.component.ts代码如下: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394import &#123; Component &#125; from &apos;@angular/core&apos;;export class Hero &#123; id: number; name: string;&#125;const HEROES: Hero[] = [ &#123; id: 11, name: &apos;Mr. Nice&apos; &#125;, &#123; id: 12, name: &apos;Narco&apos; &#125;, &#123; id: 13, name: &apos;Bombasto&apos; &#125;, &#123; id: 14, name: &apos;Celeritas&apos; &#125;, &#123; id: 15, name: &apos;Magneta&apos; &#125;, &#123; id: 16, name: &apos;RubberMan&apos; &#125;, &#123; id: 17, name: &apos;Dynama&apos; &#125;, &#123; id: 18, name: &apos;Dr IQ&apos; &#125;, &#123; id: 19, name: &apos;Magma&apos; &#125;, &#123; id: 20, name: &apos;Tornado&apos; &#125;];@Component(&#123; selector: &apos;my-app&apos;, template: ` &lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt; &lt;h2&gt;My Heroes&lt;/h2&gt; &lt;ul class=&quot;heroes&quot;&gt; &lt;li *ngFor=&quot;let hero of heroes&quot; [class.selected]=&quot;hero === selectedHero&quot; (click)=&quot;onSelect(hero)&quot;&gt; &lt;span class=&quot;badge&quot;&gt;&#123;&#123;hero.id&#125;&#125;&lt;/span&gt; &#123;&#123;hero.name&#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;div *ngIf=&quot;selectedHero&quot;&gt; &lt;h2&gt;&#123;&#123;selectedHero.name&#125;&#125; details!&lt;/h2&gt; &lt;div&gt;&lt;label&gt;id: &lt;/label&gt;&#123;&#123;selectedHero.id&#125;&#125;&lt;/div&gt; &lt;div&gt; &lt;label&gt;name: &lt;/label&gt; &lt;input [(ngModel)]=&quot;selectedHero.name&quot; placeholder=&quot;name&quot;/&gt; &lt;/div&gt; &lt;/div&gt; `, styles: [` .selected &#123; background-color: #CFD8DC !important; color: white; &#125; .heroes &#123; margin: 0 0 2em 0; list-style-type: none; padding: 0; width: 15em; &#125; .heroes li &#123; cursor: pointer; position: relative; left: 0; background-color: #EEE; margin: .5em; padding: .3em 0; height: 1.6em; border-radius: 4px; &#125; .heroes li.selected:hover &#123; background-color: #BBD8DC !important; color: white; &#125; .heroes li:hover &#123; color: #607D8B; background-color: #DDD; left: .1em; &#125; .heroes .text &#123; position: relative; top: -3px; &#125; .heroes .badge &#123; display: inline-block; font-size: small; color: white; padding: 0.8em 0.7em 0 0.7em; background-color: #607D8B; line-height: 1em; position: relative; left: -1px; top: -4px; height: 1.8em; margin-right: .8em; border-radius: 4px 0 0 4px; &#125; `]&#125;)export class AppComponent &#123; title = &apos;Tour of Heroes&apos;; heroes = HEROES; selectedHero: Hero; onSelect(hero: Hero) &#123; this.selectedHero = hero; &#125;&#125; 小结本章小结: 我们现在可以选择列表里的英雄了 应用由了选择并展示英雄详情的功能 我们学习了怎么在组件模板里使用内置指令ngIf和ngFor 现在英雄之旅初具雏形,但还远远没有完成,我们不能使用单个组件来实现整个app,需要将组件分成若干个子组件,并将他们有效的组合起来. 多组件 重构master/detail视图到分离的组件 构建一个英雄详情组件我们的英雄列表和我们的英雄详情目前处于一个文件里.他们现在虽然很小但是不利于扩展.我们目前的组件设计遵守单一组件原则,虽然这只是个教程,但精益求精依然是要追求的,尤其是使用Angular是非常容易做到这一点的. 让我们将英雄详情移出目前组件 分离英雄详情组件app文件夹里增加一个新的文件hero-detail.component.ts,并创建如下的HeroDetailComponent: app/hero-detail.component.ts (initial version) 12345678import &#123; component. Input &#125; from &apos;@angular/core&apos;;@component(&#123; selector: &apos;my-hero-detail&apos;,&#125;)export class HeroDetailComponent&#123;&#125; 命名规则我们希望通过文件名可以知道对应的组件名.所有组件的文件后缀名已.component结尾.如HeroDetailComponent对应的文件名为hero-detail.component.ts. 英雄详情模板现在,Heroes和Hero详情视图还在AppComponent的模板里.让我们英雄详情相关的内容黏贴到HeroDetailComponent里. 我们之前绑定了AppComponent的selectedHero.name特性.在新的模板中将selectedHero替换为hero. app/hero-detail.component.ts (template) 12345678910template: ` &lt;div *ngIf=&quot;hero&quot;&gt; &lt;h2&gt;&#123;&#123;hero.name&#125;&#125; details!&lt;/h2&gt; &lt;div&gt;&lt;label&gt;id: &lt;/label&gt;&#123;&#123;hero.id&#125;&#125;&lt;/div&gt; &lt;div&gt; &lt;label&gt;name: &lt;/label&gt; &lt;input [(ngModel)]=&quot;hero.name&quot; placeholder=&quot;name&quot;/&gt; &lt;/div&gt; &lt;/div&gt;` 现在英雄详情展示只会在HeroDetailComponent里. 增加hero特性将Hero类从app.component.ts移出,创建并放入一个hero.ts文件里. app/hero.ts 1234export class Hero &#123; id: number; name: string;&#125; 我们将Hero类从hero.ts暴露出来,因为我们需要在多个地方引用它.在app.component.ts和hero-detail.component.ts增加以下的语句引用Hero: 1import &#123; Hero &#125; from &apos;./hero&apos;; hero特性是输入HeroDetailComponent需要被告之哪个英雄需要显示,谁可以干这个事?它的父组件AppComponent! AppComponent知道哪个英雄需要显示:就是用户从列表里选择的那个.用户选择被放入selectedHero特性. 我们更新模板,将HeroDetailComponent的hero特性和AppComponent的selectedHero绑定. 1&lt;my-hero-detail [hero]=&quot;selectedHero&quot;&gt;&lt;/my-hero-detail&gt; 注意到hero特性是特性绑定的目标-它在方括号里并处于(=)号的左边. Angular主张将目标特性作为一个可输入的特性,如果不这样做,Angular就会拒绝绑定并抛出异常. input特性的详情请看这里. 有若干方法可以声明hero是一个输入特性.我们可以按选择,比如在hero特性里加一个@Input注释. 12@Input()hero: Hero; 更多关于@Input装饰器内容查看属性指令章节. 更新AppComponentAppComponent里导入HeroDetailComponent. 1import &#123; HeroDetailComponent &#125; from &apos;./hero-detail.component&apos;; 在模板中找到移除Hero Detail内容的地方,增加一个表示HeroDetailComponent的元素标签,并将AppComponent的selectedHero特性和HeroDetailComponent的hero特性进行双向绑定. 1&lt;my-hero-detail [hero]=&quot;selcetedHero&quot;&gt;&lt;/my-hero-detail&gt; 此时AppComponent模板如下: 123456789101112template: ` &lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt; &lt;h2&gt;My Heroes&lt;/h2&gt; &lt;ul class=&quot;heroes&quot;&gt; &lt;li *ngFor=&quot;let hero of heroes&quot; [class.selected]=&quot;hero === selectedHero&quot; (click)=&quot;onSelect(hero)&quot;&gt; &lt;span class=&quot;badge&quot;&gt;&#123;&#123;hero.id&#125;&#125;&lt;/span&gt; &#123;&#123;hero.name&#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;my-hero-detail [hero]=&quot;selectedHero&quot;&gt;&lt;/my-hero-detail&gt;`, HeroDetailComponent 可以接收AppComponent的选择事件,并在list底部将这个英雄的详情展示出来,这个详情会随着用户的选择而改变.但是!现在什么也没有发生!我们在英雄之间来回点击,但没有详情显示,我们也没有调试到任何的错误信息. 这有点像是Angular忽略了这个新的标签,事实上确实如此. 指令数组浏览器会忽略它不识别的HTML标签和属性,Angular也是如此.我们导入HeroDetailComponent,在模板里使用它,但并没有告诉Angular它是什么.如何告诉Angular?将组件列入元数据directives数组: 1directives: [HeroDetailComponent] 现在功能实现了,我们也创建了第一个可复用的组件! 小结本章小结 我们创建了一个可复用的组件 我们学习了如何让组件接收输入信息 我们学习了绑定父组件和子组件 我们学习了如何声明应用指令 未来之路我们的英雄之旅将会有可多可复用的组件.我们现在模拟数据依然处于AppComponent中,这并不合理.我们需要重构数据接入组件,将它放到分离的服务里,可被其他组件共享. 下一章,我们将学习如何创建Services. Services 我们创建一个可复用的service来管理英雄数据的调用 英雄之旅在逐步进化,可以预料以后将会增加更多的组件.多个组件需要获取英雄数据信息,我们并不想通过重复拷贝相同的代码来实现它.所以,我们将要创建一个可复用的数据服务,并学习怎么将它注入到组件里. 重构数据获取方式将它放入到分离的服务里,可以保持组件只关注它的视图,也可以使用模拟服务使得组件的单元测试更加方便. 因为数据services始终是异步的,本章最后我们将用基于Promise机制来实现数据服务. 创建一个英雄Service我们的合伙人说我们的这个APP有巨大的潜力,他们告诉我们他们想通过各种方法在不同的页面像是英雄信息.我们已经可以从列表里选择英雄,我们马上就需要增加一个仪表板来展示顶尖的英雄们,创建一个单独的视图来渲染英雄详情编辑界面,这三个视图都需要英雄数据. AppComponent里定义了要展示的英雄模拟数据.我们需要至少2个对象.首先,如何定义英雄并不是组件完成的.其次,我们并不能简单的再其他组件和视图之间分享英雄列表. 创建一个HeroServiceapp文件夹里创建一个名为hero.service.ts. app/hero.service.ts 12345import &#123; Injectable &#125; from &apos;@angular/core&apos;;@Injectable()export class HeroService &#123;&#125; 我们将Angualr的Injectable功能导入了,使用@Injectable()注释注入Services. 千万不要忘了()!否则很难诊断问题. 获取Heros增加一个getHeroes方法(打桩): 12345@Injectable()export class HeroService &#123; getHeroes() &#123; &#125;&#125; 这里有个重要的问题我们稍后再说.现在服务的消费者并不知道服务是如何获取到数据的.我们的HeroService可以从任何地方获取Hero数据.它可以从一个web服务里获取,可以从本地存储获取,甚至可以从一个模拟数据源里获取. 这就是将数据获取从组件移除最美妙的地方,我们可以根据具体实现来变更数据实现方式. 模拟英雄数据我们已经在AppComponent里模拟了Hero数据.它并不属于那,也不属于service这.我们将模拟数据一到它自己的文件里. 创建一个mock-heroes.ts文件,将模拟数据放到这里: 1234567891011121314import &#123;hero&#125; from &apos;./hero&apos;;export var HEROES: hero[] = [ &#123;id: 11, name: &apos;Mr. Nice&apos;&#125;, &#123;id: 12, name: &apos;Narco&apos;&#125;, &#123;id: 13, name: &apos;Bombasto&apos;&#125;, &#123;id: 14, name: &apos;Celeritas&apos;&#125;, &#123;id: 15, name: &apos;Magneta&apos;&#125;, &#123;id: 16, name: &apos;RubberMan&apos;&#125;, &#123;id: 17, name: &apos;Dynama&apos;&#125;, &#123;id: 18, name: &apos;Dr IQ&apos;&#125;, &#123;id: 19, name: &apos;Magma&apos;&#125;, &#123;id: 20, name: &apos;Tornado&apos;&#125; ]; 我们导出HEROES常量,这样就可以在其他地方使用它了,比如HeroService. 同时,回到app.component.ts,将heroes特性回复到未初始化状态. 1heroes: Hero[]; 返回模拟英雄数据回到HeroService我们导入模拟数据HEROES并返回给getHeroes方法.我们的HeroService现在看起来是这样的: 12345678910import &#123; Injectable &#125; from &apos;@angular/core&apos;;import &#123; HEROES &#125; from &apos;./mock-heroes&apos;;@Injectable()export class HeroService &#123; getHeroes() &#123; return HEROES; &#125;&#125; 使用英雄Service我们已经准备好在其他组件里使用HeroSevice了,从AppComponent开始. 首先,我们先导入它 import { HeroService } from &#39;./hero.service&#39;;. 导入Service后,允许我们引用它的代码.AppComponent是怎样获取HeroService实例的? new一个实例吗?不行! 我们可以new一个新的HeroService实例,如: 1heroService = new HeroService(); // don&apos;t do this 但这么做有几点不好的地方: 我们的组件需要知道如何构建HeroService示例.如果我们改变了HeroService的构造函数,我们就需要找到所有使用了这个service的地方,并修改它.不利于维护和扩展. 我们每次都new一个service,当需要缓存和共享数据这些数据的时候,我们就无法满足了. 我们现在将HeroService锁定到了AppComponent,如果执行场景有变化的时候我们该怎么办呢?我们可以离线操作吗?需要对不同的模拟版本进行单元测试?这很难办到. 要解决这些问题真的非常容易.那就是注入HeroService: 我们增加一个构造器并定义一个私有特性 我们增加一个组件的provider元数据. 构造器如下: app/app.component.ts1constructor(private heroService: HeroService) &#123; &#125; 构造器并没有干什么,参数同时定义了一个私有的heroService属性并指定它未HeroService的注入站点. 现在当构建一个新的AppComponent的时候,Angular就可以支持HeroService的实例构建了. 更多信息,请查看依赖注入章节. 注入器并不知道怎么创建HeroService.如果我们执行代码.此时Angualr会报错: 1EXCEPTION: No provider for HeroService! (AppComponent -&gt; HeroService) 我们需要通过注册一个HeroService的容器来告诉注入器如何构建HeroService.如下,在@Component里增加一个providers数组属性. 1providers: [HeroService] providers数组告诉Angular,当构建一个新的AppComponent的时候就会创建一个新的HeroService实例.AppComponent以及它的子组件都可以使用这个service去获取英雄数据. 123getHeroes() &#123; this.heroes = this.heroService.getHeroes(); &#125; ngOnInit生命周期HookAppComponent应该立即获取和展示英雄们,我们在哪里调用getHeroes方法?在构造器里?我们不这样做! 数年挖坑填坑之痛告诉我们,要保持构造器的逻辑尽量简单,尤其当我们还需要调用server的data数据的时候. 构造器用于一些简单的初始化工作,比如讲参数写入属性里,并不适合做太重的活,所以需要在其他地方调用getHeroes. Angular将会在ngOnInit生命周期Hook里调用这个getHeroes. Angular 提供了数个接口可以进入组件生命周期的关键节点:创建,改变后,消除. 每一个接口对用一个单独的方法,当组件应用了这个方法,Angular会在合适的时间调用他. 关于生命周期详细内容请查看生命周期Hook章节 以下是OnInit接口的基本应用框架: 123456import &#123; OnInit &#125; from &apos;@angular/core&apos;;export class AppComponent implements OnInit &#123; ngOnInit() &#123; &#125;&#125; 我们在ngOnInit里写入符合该逻辑的方法,Angualr会在合适的地方调用它. 123ngOnInit() &#123; this.getHeroes();&#125; 我们的应用如我们期望运行,显示了一组英雄列表,当我们选择点击的时候,可以查看该英雄的详情. 异步服务和Promises我们的HeroService会立即返回一组模拟的英雄,getHeroes是同步的. 1this.heroes = this.heroService.getHeroes(); 当某天我们想从远程服务器获取heroes的时候,虽然我们现在还不能通过http调用,但后面的章节我们马上就要这样了.我们将不得不等待服务器的响应信息,我们不能让UI跟着等待,因为浏览器是不会堵塞的. 我们就需要一些一步技术来调用getHeroes方法.我们使用Promises. Promise就是说它保证会结果准备好的时候回调我们.我们给服务器发了一个异步请求并将回调函数告诉它.当请求有结果的时候,服务器会回调告诉我们结果. 更新HeroService: 123getHeroes() &#123; return Promise.resolve(HEROES);&#125; 使用Promise回到AppComponent的getHeroes方法,目前代码如下: 123getHeroes() &#123; this.heroes = this.heroService.getHeroes();&#125; 我们需要修改代码来解析Promise: 123getHeroes() &#123; this.heroService.getHeroes().then(heroes =&gt; this.heroes = heroes);&#125; 查看APP结构12345678910111213141516171819202122232425262728293031--angular2-tour-of-heroes----app------app.component.ts------hero.ts------hero-detail.component.ts------hero.service.ts------main.ts------mock-heroes.ts----node_modules ...----typings ...----index.html----package.json----styles.css----systemjs.config.js----tsconfig.json----typings.json 小结本章小结 我们创建了一个可分享的服务类 我们使用ngOnInit生命周期的挂钩来获取英雄数据列表 我们在AppComponent里将HeroService定义为一个provider 我们创建模拟英雄数据并将它导入服务. 我们将服务设计为异步Promise,让组件从Promise里解析获取数据. 下一章我们的英雄之旅代码现在有了可复用的服务,我们现在想创建一个导航栏,可以在仪表盘和英雄详情编辑页里来回切换. 路由英雄之旅的新需求: 增加一个Dashboard视图 可以在Heroes和Dashboard视图来回切换 点击选择英雄可以跳转到英雄详情 计划 将AppComponent变为处理导航的外壳. 将Heroes相关内容从AppComponent重定向HeroesComponent. 增加路由 创建一个DashboardComponent 将Dashboard绑定到导航结构. 重组AppComponent我们当前应用加载AppComponent并立即展示英雄列表.现在我们先进入导航界面. AppComponent应该只处理导航,将英雄显示相关部分移到它自己的组件HeroesComponent. HerosComponent目前的AppComponent主要专注于英雄展示,将其改名未HerosComponent,改名步骤如下: app.component.ts改为heroes.component.ts AppComponent类改名为HeroesComponent 选择器my-app改为my-heroes 12345@Component(&#123; selector: &apos;my-heroes&apos;,&#125;)export class HeroesComponent implements OnInit &#123;&#125; 创建AppComponent 创建一个新文件名app.component.ts 定义一个AppComponent类 导出模块以便可在main.ts引用 定义title属性 增加一个有my-app选择器的@Component元数据装饰器 增加一个有&lt;h1&gt;标签的模板并绑定到title属性 模板里增加&lt;my-heroes&gt;标签用于显示英雄 将HeroesComponent放入directives数组,这样Angluar就可以识别&lt;my-heroes&gt;标签了. 增加HeroService到providers数组,因为我们在其他视图中也需要它. 增加支持import语句. 1234567891011121314151617import &#123; Component &#125; from &apos;@angular/core&apos;;import &#123; HeroService &#125; from &apos;./hero.service&apos;;import &#123; HeroesComponent &#125; from &apos;./heroes.component&apos;;@Component(&#123; selector: &apos;my-app&apos;, template: ` &lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt; &lt;my-heroes&gt;&lt;/my-heroes&gt; `, directives: [HeroesComponent], providers: [ HeroService ]&#125;)export class AppComponent &#123; title = &apos;Tour of Heroes&apos;;&#125; 这个app依然可以显示英雄,我们的重构工作就完成了. 增加路由我们准备进行下一步.和自动展示英雄相比,我们更喜欢点击展示的方式,换句话说,我们想当行到英雄列表.这个时候我们就需要Angular的组件路由功能. 设置基础标签打开index.html在顶部的&lt;head&gt;部分增加&lt;base href=&quot;/&quot;&gt;. 12&lt;head&gt; &lt;base href=&quot;/&quot;&gt; 使路由可见组件路由器是一个服务,和其他服务一样,我们需要先导入它,并将它让入providers数组. Angular路由是有由多服务(ROUTER_PROVIDERS),多指令(ROUTER_DIRECTIVES)和一个配置装饰器(RouteConfig)组成,将他们全部导入: app/app.component.ts1import &#123; RouteConfig, ROUTER_DIRECTIVES, ROUTER_PROVIDERS &#125; from &apos;@angular/router-deprecated&apos;; 然后,我们升级directives和providers元数组,让组件包含这些路由成分: 12345directives: [ROUTER_DIRECTIVES],providers: [ ROUTER_PROVIDERS, HeroService] 注意到我们将HeroesComponent从directives数组移除了.AppComponent不再显示英雄;这是路由器的工作,我们很快也会把&lt;my-heroes&gt;从模板移除. 增加配置路由器现在AppComponent还没有包括路由器,我们现在使用@RouteConfig装饰器(a)给组件分配一个路由器(b)使用routes配置路由器. 当用户点击某个连接或者在浏览器输入URL的时候,routes告诉路由器哪个视图是应该对应显示的. app/app.component.ts (RouteConfig): 1234567@RouteConfig([ &#123; path: &apos;/heroes&apos;, name: &apos;Heroes&apos;, component: HeroesComponent &#125;]) @RouteConfig 数组定义了路由,之后会有更多的路由. 这个路由定义只要有三个部分: path: 路由器对浏览器里URL的路径进行匹配(/heroes). name: 路由的正式命名;为了和路径区分,命名必须首字母大写. component: 路由对应的组件名字 深入请翻阅Routing章节 路由器出口如果我们在浏览器输入/heroes对应地址,路由器会匹配Heroes路由并渲染HeroesComponent组件.但在哪里显示?&lt;router-outlet&gt;!我们在应用里导航,路由器会将对应组件显示到&lt;router-outlet&gt;之下. 路由器链接我们并不期望用户直接粘贴URL到浏览器地址栏,我们在模板里增加一个锚标签供用户点击. 12345template: ` &lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt; &lt;a [routerLink]=&quot;[&apos;Heroes&apos;]&quot;&gt;Heroes&lt;/a&gt; &lt;router-outlet&gt;&lt;/router-outlet&gt;`, 注意到[routerLink]绑定到一个锚标签上.我们将RouterLink指令绑定一个路由,当用户点击链接的时候就知道导航的位置. 我们使用链接参数数组定义了路由指示,这个数组在当前示例中,显示一个元素,括号内是路由到组件HeroesComponent的名字Heroes. 更多关于链接数组相关内容请查看路由章节. 刷新浏览器,我们只看到app的title,并没有看到heroes列表,当我们点击Heroes导航链接就发现了英雄列表. app/app.component.ts (v2) 123456789101112131415161718192021222324252627import &#123; Component &#125; from &apos;@angular/core&apos;;import &#123; RouteConfig, ROUTER_DIRECTIVES, ROUTER_PROVIDERS &#125; from &apos;@angular/router-deprecated&apos;;import &#123; HeroService &#125; from &apos;./hero.service&apos;;import &#123; HeroesComponent &#125; from &apos;./heroes.component&apos;;@Component(&#123; selector: &apos;my-app&apos;, template: ` &lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt; &lt;a [routerLink]=&quot;[&apos;Heroes&apos;]&quot;&gt;Heroes&lt;/a&gt; &lt;router-outlet&gt;&lt;/router-outlet&gt; `, directives: [ROUTER_DIRECTIVES], providers: [ ROUTER_PROVIDERS, HeroService ]&#125;)@RouteConfig([ &#123; path: &apos;/heroes&apos;, name: &apos;Heroes&apos;, component: HeroesComponent &#125;])export class AppComponent &#123; title = &apos;Tour of Heroes&apos;;&#125; AppComponent现在关联到了路由器并显示路由的视图.基于这些功能有别于其他组件,我们称这类组件为路由器组件. 增加一个仪表盘当我们有多个视图的时候,路由才有意义.我们需要另外一个视图. app/dashboard.component.ts (v1) 1234567import &#123; Component &#125; from &apos;@angular/core&apos;;@Component(&#123; selector: &apos;my-dashboard&apos;, template: &apos;&lt;h3&gt;My Dashboard&lt;/h3&gt;&apos;&#125;)export class DashboardComponent &#123; &#125; 配置dashboard路由回到app.component.ts配置导航到dashboard的路由. 导入DashboardComponent,在@RouteConfig里定义Dashboard路由. app/app.component.ts 123456&#123; path: &apos;/dashboard&apos;, name: &apos;Dashboard&apos;, component: DashboardComponent, useAsDefault: true&#125;, 最后,增加一个导航链接到模板里: 12345678template: ` &lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt; &lt;nav&gt; &lt;a [routerLink]=&quot;[&apos;Dashboard&apos;]&quot;&gt;Dashboard&lt;/a&gt; &lt;a [routerLink]=&quot;[&apos;Heroes&apos;]&quot;&gt;Heroes&lt;/a&gt; &lt;/nav&gt; &lt;router-outlet&gt;&lt;/router-outlet&gt;`, 刷新浏览器,我们可以在dashboard和heroes之间来回切换了. Dashboard顶级英雄让我们用4个顶级英雄来填充dashboard.将template元数据用templateUrl替换: 123app/dashboard.component.ts (templateUrl)templateUrl: &apos;app/dashboard.component.html&apos;, 我们使用了全路径,这是因为Angular默认不支持相对路径,具体可以查看组件相对路径. 创建文件app/dashboard.component.html,内容如下: 12345678&lt;h3&gt;Top Heroes&lt;/h3&gt;&lt;div class=&quot;grid grid-pad&quot;&gt; &lt;div *ngFor=&quot;let hero of heroes&quot; (click)=&quot;gotoDetail(hero)&quot; class=&quot;col-1-4&quot;&gt; &lt;div class=&quot;module hero&quot;&gt; &lt;h4&gt;&#123;&#123;hero.name&#125;&#125;&lt;/h4&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 我们使用*ngFor来遍历英雄列表并展示英雄名字,我们增加一个额外的&lt;div&gt;元素用于后面进行样式化. 在这里有个(click)绑定到gotoDetail方法上,这个方法我们现在还没有. 共享HeroService我们复用HeroService来获取组件的英雄数组.回顾之前的章节,我们HeroService从HeroesComponent的providers数组移到了最高级的AppComponent组件上.这样就使得HeroService成为一个单例,对所有的应用组件生效.Angular将会注入HeroService,我们就可以在DashboardComponent里使用它. 获取heroes打开dashboard.component.ts,代码如下: 1234567891011121314import &#123; Component, OnInit &#125; from &apos;@angular/core&apos;;import &#123; Hero &#125; from &apos;./hero&apos;;import &#123; HeroService &#125; from &apos;./hero.service&apos;;export class DashboardComponent implements OnInit &#123; heroes: Hero[] = []; constructor(private heroService: HeroService) &#123; &#125; ngOnInit() &#123; this.heroService.getHeroes() .then(heroes =&gt; this.heroes = heroes.slice(1, 5)); &#125; gotoDetail() &#123; /* not implemented yet */&#125;&#125; 和创建HerosComponent类似,在这里我们创建一个heroes数组属性,注入HeroService并将他保存在私有字段heroService里,然后在Angular的ngOnInit生命周期里调用这个服务. 不同的是:我们使用slice挑选了4个英雄(2-5),并将gotoDetail方法打桩,刷新浏览器,我们现在可以看到4个英雄. 导航到英雄详情虽然我们在HeroesComponent底部现实了选择英雄的详情,蛋我们还不能满足以下几种导航需求: 1. 在Dashboard选择英雄 2. 在英雄列表选择英雄 3. 浏览器里输入完成的URl来显示英雄 增加一个HeroDetail路由显然是个好的选择. 路由到英雄详情我们在AppComponent增加一个到HeroDetailComponent的路由.这个路由不同的地方是需要给它指定具体的英雄,这和HeroesComponent,DashboardComponent不同,后者不需要传给他们任何参数. 现在,父组件HeroesComponent将hero属性绑定到一个英雄对象: &lt;my-hero-detail [hero]=&quot;selectedHero&quot;&gt;&lt;/my-hero-detail&gt; 当前的代码还无法正常运行,我们还需要做如下的工作. 路由参数我们可以在URL里增加一个英雄的id,比如路由到一个id是11的英雄,其URL为如下所示: /detail/11 URL的/detail/部分是常量,尾部的数字id根据英雄不同而变化,我们需要配置路由并使用一个变量来便表示它.配置路由参数 12345&#123; path: &apos;/detail/:id&apos;, name: &apos;HeroDetail&apos;, component: HeroDetailComponent&#125;, 路径中的冒号(:)是占位文字,当导航到HeroDetailComponent时用于填充对应的英雄id.现在HeroDetaiComponent代码如下: 1234567891011121314151617181920import &#123; Component, Input &#125; from &apos;@angular/core&apos;;import &#123; Hero &#125; from &apos;./hero&apos;;@Component(&#123; selector: &apos;my-hero-detail&apos;, template: ` &lt;div *ngIf=&quot;hero&quot;&gt; &lt;h2&gt;&#123;&#123;hero.name&#125;&#125; details!&lt;/h2&gt; &lt;div&gt; &lt;label&gt;id: &lt;/label&gt;&#123;&#123;hero.id&#125;&#125; &lt;/div&gt; &lt;div&gt; &lt;label&gt;name: &lt;/label&gt; &lt;input [(ngModel)]=&quot;hero.name&quot; placeholder=&quot;name&quot;/&gt; &lt;/div&gt; &lt;/div&gt; `&#125;)export class HeroDetailComponent &#123; @Input() hero: Hero;&#125; 模板不需要改变,我们以同样的方式显示英雄,但获取英雄的方式变化了.我们现在不从父组件的属性绑定中获取英雄.HeroDetailComponent现在需要从路由器的RouteParams service获得id,并使用这个id从HeroService里获取hero数据. 123import &#123; RouteParams &#125; from &apos;@angular/router-deprecated&apos;;import &#123; HeroService &#125; from &apos;./hero.service&apos;;import &#123; Component, OnInit &#125; from &apos;@angular/core&apos;; 注入RouteParams和HeroService服务: 1234constructor( private heroService: HeroService, private routeParams: RouteParams) &#123;&#125; 在ngOnInit生命挂钩中,从RouteParams获取id参数,并从HeroService获取英雄 12345ngOnInit() &#123; let id = +this.routeParams.get(&apos;id&apos;); this.heroService.getHero(id) .then(hero =&gt; this.hero = hero);&#125; 注意到我们调用RouteParams.get来或得id let id = +this.routeParams.get(&#39;id&#39;); 由于英雄的id是一个数字,而Route得参数都是字符串,所以用JavaScript(+)进行数值转换. 增加HeroService.getHero1234getHero(id: number) &#123; return this.getHeroes() .then(heroes =&gt; heroes.filter(hero =&gt; hero.id === id)[0]);&#125; 返回用户通过选择点击或者URL输入跳转到HeroDetailComponent视图界面后,可以选择返回: 123goBack() &#123; window.history.back();&#125; 在对应模板增加返回点击事件绑定: 12345678910&lt;div *ngIf=&quot;hero&quot;&gt; &lt;h2&gt;&#123;&#123;hero.name&#125;&#125; details!&lt;/h2&gt; &lt;div&gt; &lt;label&gt;id: &lt;/label&gt;&#123;&#123;hero.id&#125;&#125;&lt;/div&gt; &lt;div&gt; &lt;label&gt;name: &lt;/label&gt; &lt;input [(ngModel)]=&quot;hero.name&quot; placeholder=&quot;name&quot; /&gt; &lt;/div&gt; &lt;button (click)=&quot;goBack()&quot;&gt;Back&lt;/button&gt;&lt;/div&gt; 最后,我们的HeroDettailComponent如下: 12345678910111213141516171819202122232425262728import &#123; Component, OnInit &#125; from &apos;@angular/core&apos;;import &#123; RouteParams &#125; from &apos;@angular/router-deprecated&apos;;import &#123; Hero &#125; from &apos;./hero&apos;;import &#123; HeroService &#125; from &apos;./hero.service&apos;;@Component(&#123; selector: &apos;my-hero-detail&apos;, templateUrl: &apos;app/hero-detail.component.html&apos;,&#125;)export class HeroDetailComponent implements OnInit &#123; hero: Hero; constructor( private heroService: HeroService, private routeParams: RouteParams) &#123; &#125; ngOnInit() &#123; let id = +this.routeParams.get(&apos;id&apos;); this.heroService.getHero(id) .then(hero =&gt; this.hero = hero); &#125; goBack() &#123; window.history.back(); &#125;&#125; 选择一个Dashboard英雄当用户从dashboard选择一个英雄,应用将会跳转到HeroDetailComponent视图,并可以编辑英雄. 在dashbaord的模板里,绑定了英雄点击事件到gotoDetail方法里,并将选择的英雄实体传入: &lt;div *ngFor=&quot;let hero of heroes&quot; (click)=&quot;gotoDetail(hero)&quot; class=&quot;col-1-4&quot;&gt; 之前重写DashboardComponent的时候,我们还未完成gotoDetail方法,现在我们将它实现: 1234gotoDetail(hero:Hero) &#123;truelet link = [&apos;HeroDetail&apos;, &#123;id: hero.id&#125;];truethis.router.navigate(link);&#125; 这个gotoDetail方法通过两个步骤导航: 1. 设置一个路由连接参数数组 2. 将该数组传入路由器的navigate方法 link数组有两个元素,目标路由的命名以及路由参数对象,和在AppComponent中的路由配置是相对应的. 12345&#123; path: &apos;/detail/:id&apos;, name: &apos;HeroDetail&apos;, component: HeroDetailComponent&#125;, DashboardComponent还没有路由,我们将其加入: 123456import &#123; Router &#125; from &apos;@angular/router-deprecated&apos;;...constructor( private router: Router, private heroService: HeroService) &#123;&#125; HerosComponent里选择一个英雄123456789101112template: ` &lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt; &lt;h2&gt;My Heroes&lt;/h2&gt; &lt;ul class=&quot;heroes&quot;&gt; &lt;li *ngFor=&quot;let hero of heroes&quot; [class.selected]=&quot;hero === selectedHero&quot; (click)=&quot;onSelect(hero)&quot;&gt; &lt;span class=&quot;badge&quot;&gt;&#123;&#123;hero.id&#125;&#125;&lt;/span&gt; &#123;&#123;hero.name&#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;my-hero-detail [hero]=&quot;selectedHero&quot;&gt;&lt;/my-hero-detail&gt;`, 删除标签,我们不用显示完整的HeroDetailComponent了,它将显示在自己的页面上,同时当用户从列表选择一个英雄,我们将不会进入detail页面,我们先显示一个mini-detail页面,当用户再次点击这个页面的时候,才会导航到完全的详情页. 增加一个mini-detail123456&lt;div *ngIf=&quot;selectedHero&quot;&gt; &lt;h2&gt; &#123;&#123;selectedHero.name | uppercase&#125;&#125; is my hero &lt;/h2&gt; &lt;button (click)=&quot;gotoDetail()&quot;&gt;View Details&lt;/button&gt;&lt;/div&gt; 在点击一个英雄后,用户将会看到以下的页面: 注意到英雄名都是大写,这是UpperCasePipe的效果,(|)是一个管道操作符,管道擅长对格式化一些字符串,金钱符号,日期等数据. 关于管道可以查看管道章节 将内容移除组件文件 我们还需要更新组件类,完成用户点击View Details按钮功能.这个组件文件越来越大,大部分是模板或者CSS样式,很难找到组件的逻辑代码,让我们稍微重构下: 1. 将模板内容移动到hereos.component.html文件 2. 将样式内容移到heroes.component.css文件 3. 分别设置templateUrl和styleUrls为上述两文件 12345@Component(&#123; selector: &apos;my-heroes&apos;, templateUrl: &apos;app/heroes.component.html&apos;, styleUrls: [&apos;app/heroes.component.css&apos;]&#125;) 现在组件的代码比较干净了,可以更清晰的看出其逻辑: 1. 导入router 2. 将router注入构造器 3. 实现gotoDetail方法:调用router.navigate方法传入HeroDetail的链接参数数组. 12345678910111213141516171819app/heroes.component.ts (class)export class HeroesComponent implements OnInit &#123; heroes: Hero[]; selectedHero: Hero; constructor( private router: Router, private heroService: HeroService) &#123; &#125; getHeroes() &#123; this.heroService.getHeroes().then(heroes =&gt; this.heroes = heroes); &#125; ngOnInit() &#123; this.getHeroes(); &#125; onSelect(hero: Hero) &#123; this.selectedHero = hero; &#125; gotoDetail() &#123; this.router.navigate([&apos;HeroDetail&apos;, &#123; id: this.selectedHero.id &#125;]); &#125;&#125; App样式App的功能已经完成了,但是界面还不是很美观,我们的设计师提供了一些CSS文件来优化它. Dashboard样式设计师认为dashboard的英雄们用一组矩阵来显示,他们给了我们可实现响应式的大概60行CSS代码. 在aoo文件夹下面增加一个dashboard.component.css文件,并放入组件元数据styleUrls数组属性里. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162styleUrls: [&apos;app/dashboard.component.css&apos;][class*=&apos;col-&apos;] &#123; float: left;&#125;*, *:after, *:before &#123; -webkit-box-sizing: border-box; -moz-box-sizing: border-box; box-sizing: border-box;&#125;h3 &#123; text-align: center; margin-bottom: 0;&#125;[class*=&apos;col-&apos;] &#123; padding-right: 20px; padding-bottom: 20px;&#125;[class*=&apos;col-&apos;]:last-of-type &#123; padding-right: 0;&#125;.grid &#123; margin: 0;&#125;.col-1-4 &#123; width: 25%;&#125;.module &#123; padding: 20px; text-align: center; color: #eee; max-height: 120px; min-width: 120px; background-color: #607D8B; border-radius: 2px;&#125;h4 &#123; position: relative;&#125;.module:hover &#123; background-color: #EEE; cursor: pointer; color: #607d8b;&#125;.grid-pad &#123; padding: 10px 0;&#125;.grid-pad &gt; [class*=&apos;col-&apos;]:last-of-type &#123; padding-right: 20px;&#125;@media (max-width: 600px) &#123; .module &#123; font-size: 10px; max-height: 75px; &#125;&#125;@media (max-width: 1024px) &#123; .grid &#123; margin: 0; &#125; .module &#123; min-width: 60px; &#125;&#125; 英雄详情界面优化app目录下增加一个hero-detail.component.css文件,内容如下: 1234567891011121314151617181920212223242526272829label &#123; display: inline-block; width: 3em; margin: .5em 0; color: #607D8B; font-weight: bold;&#125;input &#123; height: 2em; font-size: 1em; padding-left: .4em;&#125;button &#123; margin-top: 20px; font-family: Arial; background-color: #eee; border: none; padding: 5px 10px; border-radius: 4px; cursor: pointer; cursor: hand;&#125;button:hover &#123; background-color: #cfd8dc;&#125;button:disabled &#123; background-color: #eee; color: #ccc; cursor: auto;&#125; 导航链接界面优化app目录下增加一个app.component.css文件,内容如下: 12345678910111213141516171819202122232425262728h1 &#123; font-size: 1.2em; color: #999; margin-bottom: 0;&#125;h2 &#123; font-size: 2em; margin-top: 0; padding-top: 0;&#125;nav a &#123; padding: 5px 10px; text-decoration: none; margin-top: 10px; display: inline-block; background-color: #eee; border-radius: 4px;&#125;nav a:visited, a:link &#123; color: #607D8B;&#125;nav a:hover &#123; color: #039be5; background-color: #CFD8DC;&#125;nav a.router-link-active &#123; color: #039be5;&#125; 应用全局样式之前的样式都是组件内有效,我们也可以在应用层面上组件之外创建一个全局样式,比如设计师提供一些基础样式需要在整个应用内有效的. 12345678910111213141516171819202122232425styles.css (app styles excerpt)/* Master Styles */h1 &#123; color: #369; font-family: Arial, Helvetica, sans-serif; font-size: 250%;&#125;h2, h3 &#123; color: #444; font-family: Arial, Helvetica, sans-serif; font-weight: lighter;&#125;body &#123; margin: 2em;&#125;body, input[text], button &#123; color: #888; font-family: Cambria, Georgia;&#125;/* . . . *//* everywhere else */* &#123; font-family: Arial, Helvetica, sans-serif;&#125; 增加一个新的styles.css文件,并在index.html里引用它. &lt;link rel=&quot;stylesheet&quot; href=&quot;styles.css&quot;&gt; 现在我们的app是这个样子了. 小结 我们增加了一个Angular路由组件 我们学习了如何创建导航菜单栏的路由链接. 我们使用路由参数跳转到用户选择英雄的详情页 多组件共享HeroService 分离HTML和CSS文件到各自的文件 uppercase管道来格式化数据 未来之路现在万事俱备,只欠东风了,就是远程数据接入. 下一章,我们将从一个http服务器上来获取英雄数据. Http我们的合伙人对我们的项目进度非常满意,现在他们想要从别的服务器获取英雄数据了,让用户可以增加,编辑,删除英雄,并将改动同步到服务器. 在这个章节,我们将会教大家如何响应和调用一个web服务的api. 在线示例在此. Http准备Http并不是Angular的核心模块,它属于插件,分离在npm包进行管理.不过我们可以直接从@angular/http导入Http,因为systemjs.config已经配置SystemJS加载了这个库. 注册http服务http服务还依赖于其他的services,HTTP_PROVIDERS,我们需要在应用的任意一个位置接入这些服务.所以当启动应用加载根组件AppComponent的时候,需要将这些服务注册到main.ts的bootstrap中. 123456import &#123; bootstrap &#125; from &apos;@angular/platform-browser-dynamic&apos;;import &#123; HTTP_PROVIDERS &#125; from &apos;@angular/http&apos;;import &#123; AppComponent &#125; from &apos;./app.component&apos;;bootstrap(AppComponent, [ HTTP_PROVIDERS ]); 注意到HTTP_PROVIDERS时再一个数组中,这个和@Component的provicer效果类似. 模拟web api我们一般建议将应用级别的服务注册到AppComponent的provicers里,这里我们注册到main里是有特殊的原因的. 我们的应用需要经历很长一段时间的开发测试才能最终发布,那个时候我们甚至没有一个可以处理heroes的web服务,所以我们需要模拟一个,内存服务器,而这个web服务对应用来讲是透明了,它不需要知道这个是模拟环境还是真实环境,所以这部分的配置需要放到AppComponent上层来配置. app/main.ts 1234567891011121314151617// Imports for loading &amp; configuring the in-memory web apiimport &#123; XHRBackend &#125; from &apos;@angular/http&apos;;import &#123; InMemoryBackendService, SEED_DATA &#125; from &apos;angular2-in-memory-web-api&apos;;import &#123; InMemoryDataService &#125; from &apos;./in-memory-data.service&apos;;// The usual bootstrapping importsimport &#123; bootstrap &#125; from &apos;@angular/platform-browser-dynamic&apos;;import &#123; HTTP_PROVIDERS &#125; from &apos;@angular/http&apos;;import &#123; AppComponent &#125; from &apos;./app.component&apos;;bootstrap(AppComponent, [ HTTP_PROVIDERS, &#123; provide: XHRBackend, useClass: InMemoryBackendService &#125;, // in-mem server &#123; provide: SEED_DATA, useClass: InMemoryDataService &#125; // in-mem server data]); in-memory-data.service.ts文件,内容如下: 1234567891011121314151617export class InMemoryDataService &#123; createDb() &#123; let heroes = [ &#123;id: 11, name: &apos;Mr. Nice&apos;&#125;, &#123;id: 12, name: &apos;Narco&apos;&#125;, &#123;id: 13, name: &apos;Bombasto&apos;&#125;, &#123;id: 14, name: &apos;Celeritas&apos;&#125;, &#123;id: 15, name: &apos;Magneta&apos;&#125;, &#123;id: 16, name: &apos;RubberMan&apos;&#125;, &#123;id: 17, name: &apos;Dynama&apos;&#125;, &#123;id: 18, name: &apos;Dr IQ&apos;&#125;, &#123;id: 19, name: &apos;Magma&apos;&#125;, &#123;id: 20, name: &apos;Tornado&apos;&#125; ]; return &#123;heroes&#125;; &#125;&#125; 更多Http内容,查看[Http]章节.记住,in-memory-web api只在开发早期有用. 英雄和Http目前HeroService代码实现: 123getHeroes() &#123; return Promise.resolve(HEROES);&#125; 我们返回一个模拟数据的promise解析数据,我们已经为使用Http客户端异步获取数据做好了准备: 123456getHeroes(): Promise&lt;Hero[]&gt; &#123;return this.http.get(this.heroesUrl) .toPromise() .then(response =&gt; response.json().data) .catch(this.handleError);&#125; Http Promise我们仍然返回的是一个promise,但看上去有点复杂. Angular http.get 返回一个 RxJS的Observable. Observable是一个有效管理异步数据流的方式,稍后我们再详细讲解. 现在,我们往下看,获取Observable之后使用.toPromise()操作符将它转换为Promise.但是Angular的Observable没有toPromise方法,我们需要从RxJS库里引入额外的扩展: import &#39;rxjs/add/operator/toPromise&#39;; 解析数据并回调在promise的then回调里,调用Response的json方法解析数据,json目标有一个data属性,这个data属性里就是调用者想要的英雄数组,所以我们获取这个数组,并以解析的promise值返回.调用者还是和以前一样使用这个promise的英雄数据,它不需要关心这个值是怎么来的,或者从哪里来的. 错误处理.catch(this.handleError); 抓取服务器的错误并将它传入错误处理器进行处理,这个处理函数非常关键!我们必须未雨绸缪: 1234private handleError(error: any) &#123; console.error(&apos;An error occurred&apos;, error); return Promise.reject(error.message || error);&#125; 在这个demo服务里,我们将错误放到控制台,真实应用里,需要设计好日志管理对错误进行记录. 增加,编辑,删除我们很快有了新的需求,需要有增删改的功能. Post我们使用post方法来新增英雄.Post请求相比Get请求需要有更多的设置. 1234567891011// Add new Heroprivate post(hero: Hero): Promise&lt;Hero&gt; &#123; let headers = new Headers(&#123; &apos;Content-Type&apos;: &apos;application/json&apos;&#125;); return this.http .post(this.heroesUrl, JSON.stringify(hero), &#123;headers: headers&#125;) .toPromise() .then(res =&gt; res.json().data) .catch(this.handleError);&#125; Putput 是用来编辑一个指定英雄,但结构和post请求非常的相似. 12345678910111213// Update existing Heroprivate put(hero: Hero) &#123; let headers = new Headers(); headers.append(&apos;Content-Type&apos;, &apos;application/json&apos;); let url = `$&#123;this.heroesUrl&#125;/$&#123;hero.id&#125;`; return this.http .put(url, JSON.stringify(hero), &#123;headers: headers&#125;) .toPromise() .then(() =&gt; hero) .catch(this.handleError);&#125; Deletedelete 用来删除英雄 1234567891011delete(hero: Hero) &#123; let headers = new Headers(); headers.append(&apos;Content-Type&apos;, &apos;application/json&apos;); let url = `$&#123;this.heroesUrl&#125;/$&#123;hero.id&#125;`; return this.http .delete(url, headers) .toPromise() .catch(this.handleError);&#125; Save我们将post和put方法组装成一个save方法,封装了逻辑(id存在就编辑,不存在就新增),让HeroDetailCompnent更加简洁. 123456save(hero: Hero): Promise&lt;Hero&gt; &#123; if (hero.id) &#123; return this.put(hero); &#125; return this.post(hero);&#125; 现在我们的HeroService代码如下: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576import &#123; Injectable &#125; from &apos;@angular/core&apos;;import &#123; Headers, Http &#125; from &apos;@angular/http&apos;;import &apos;rxjs/add/operator/toPromise&apos;;import &#123; Hero &#125; from &apos;./hero&apos;;@Injectable()export class HeroService &#123; private heroesUrl = &apos;app/heroes&apos;; // URL to web api constructor(private http: Http) &#123; &#125; getHeroes(): Promise&lt;Hero[]&gt; &#123; return this.http.get(this.heroesUrl) .toPromise() .then(response =&gt; response.json().data) .catch(this.handleError); &#125; getHero(id: number) &#123; return this.getHeroes() .then(heroes =&gt; heroes.filter(hero =&gt; hero.id === id)[0]); &#125; save(hero: Hero): Promise&lt;Hero&gt; &#123; if (hero.id) &#123; return this.put(hero); &#125; return this.post(hero); &#125; delete(hero: Hero) &#123; let headers = new Headers(); headers.append(&apos;Content-Type&apos;, &apos;application/json&apos;); let url = `$&#123;this.heroesUrl&#125;/$&#123;hero.id&#125;`; return this.http .delete(url, headers) .toPromise() .catch(this.handleError); &#125; // Add new Hero private post(hero: Hero): Promise&lt;Hero&gt; &#123; let headers = new Headers(&#123; &apos;Content-Type&apos;: &apos;application/json&apos;&#125;); return this.http .post(this.heroesUrl, JSON.stringify(hero), &#123;headers: headers&#125;) .toPromise() .then(res =&gt; res.json().data) .catch(this.handleError); &#125; // Update existing Hero private put(hero: Hero) &#123; let headers = new Headers(); headers.append(&apos;Content-Type&apos;, &apos;application/json&apos;); let url = `$&#123;this.heroesUrl&#125;/$&#123;hero.id&#125;`; return this.http .put(url, JSON.stringify(hero), &#123;headers: headers&#125;) .toPromise() .then(() =&gt; hero) .catch(this.handleError); &#125; private handleError(error: any) &#123; console.error(&apos;An error occurred&apos;, error); return Promise.reject(error.message || error); &#125;&#125; 更新组件现在HeroService已经可以满足增删改的要求了,我们需要更新下对应的组件,让它支持这些功能.首先引入这些方法. 1234567import &#123; Component, EventEmitter, Input, OnInit, Output &#125; from &apos;@angular/core&apos;;export class HeroDetailComponent implements OnInit &#123; @Input() hero: Hero; @Output() close = new EventEmitter(); error: any; navigated = false; // true if navigated here 增加/编辑HeroDetailComponent我们已经有了HeroDetailComponent来查看指定英雄的详情.增加和编辑是详情视图的扩展,我们可以服用这个组件.原来这个组件是用于渲染一个存在的数据,现在我们需要考虑当对象为空时如何初始化hero属性. 1234567891011ngOnInit() &#123; if (this.routeParams.get(&apos;id&apos;) !== null) &#123; let id = +this.routeParams.get(&apos;id&apos;); this.navigated = true; this.heroService.getHero(id) .then(hero =&gt; this.hero = hero); &#125; else &#123; this.navigated = false; this.hero = new Hero(); &#125;&#125; 为了区分新增还是编辑,我们通过检查url里的id参数是否存在来判断,如果id不存在,我们将HeroDetailComponent绑定到一个空的Hero对象,如果存在则将渲染这个存在的英雄. 下一步是增加一个HeroDetailComponent方法: 123456789save() &#123; this.heroService .save(this.hero) .then(hero =&gt; &#123; this.hero = hero; // saved hero, w/ id if new this.goBack(hero); &#125;) .catch(error =&gt; this.error = error); // TODO: Display error message&#125; 在保存英雄以后,通过goBack重定向到之前的页面. 1234goBack(savedHero: Hero = null) &#123; this.close.emit(savedHero); if (this.navigated) &#123; window.history.back(); &#125;&#125; 这里我们调用了emit,是为了通知我们刚刚增加或者修改了一个英雄. HeroesComponent监听这个通知信息,并自动刷新英雄列表. HeroesComponent里的增删用户可以通过点击按钮或者输入名字的方式新增英雄. 当用户点击 Add New Hero 按钮,我们展示一个HeroDetailComponent.我们不导航到这个组件里,这样我们就不会获取到id参数,通过前面设计可知,这就表示创建一个空的英雄对象. 增加以下的HTML到heroes.component.html: 1234&lt;button (click)=&quot;addHero()&quot;&gt;Add New Hero&lt;/button&gt;&lt;div *ngIf=&quot;addingHero&quot;&gt; &lt;my-hero-detail (close)=&quot;close($event)&quot;&gt;&lt;/my-hero-detail&gt;&lt;/div&gt; 用户可以通过点击英雄名字下面的删除按钮来删除一个已存在的英雄. 1&lt;button class=&quot;delete-button&quot; (click)=&quot;delete(hero, $event)&quot;&gt;Delete&lt;/button&gt; 现在让我们来修改HeroesComponent让它可以支持增删行为. 我们使用HeroDetailComponent来获取新的英雄嘻嘻,我们不得不导入并在directives数组里引用它的方式来告诉Aangular. 12345678import &#123; HeroDetailComponent &#125; from &apos;./hero-detail.component&apos;;@Component(&#123; selector: &apos;my-heroes&apos;, templateUrl: &apos;app/heroes.component.html&apos;, styleUrls: [&apos;app/heroes.component.css&apos;], directives: [HeroDetailComponent]&#125;) 接着,我们事先增加英雄的点击按钮: 123456789addHero() &#123; this.addingHero = true; this.selectedHero = null;&#125;close(savedHero: Hero) &#123; this.addingHero = false; if (savedHero) &#123; this.getHeroes(); &#125;&#125; 删除的逻辑会稍微复杂点: 12345678910delete(hero: Hero, event: any) &#123; event.stopPropagation(); this.heroService .delete(hero) .then(res =&gt; &#123; this.heroes = this.heroes.filter(h =&gt; h !== hero); if (this.selectedHero === hero) &#123; this.selectedHero = null; &#125; &#125;) .catch(error =&gt; this.error = error); // TODO: Display error message&#125; 让我们来看看现在应用的效果: 应用结构如下:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051angular2-tour-of-heroesapp--app.component.ts--component.css--dashboard.component.css--dashboard.component.html--dashboard.component.ts--hero.ts--hero-detail.component.css--hero-detail.component.html--hero-detail.component.ts--hero.service.ts--heroes.component.css--heroes.component.html--heroes.component.ts--main.ts--hero-data.service.tsnode_modules ...typings ...index.htmlpackage.jsonstyles.csssample.csssystemjs.config.jsontsconfig.jsontypings.json 总结至此本教程结束了,代码打包.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[偷影子的人]]></title>
      <url>http://www.lizorn.com//2016/06/14/Le-voleur-d'ombres/</url>
      <content type="text"><![CDATA[读书笔记 我只是你生活里的一个影子，你却在我的生命里占有重要地位。如果我只是个单纯的过客，为何要让我闯入你的生活？我千百次想过要离开你，但仅凭一己之力我做不到。 人们常常把一些小事抛在脑后，一些生命的片刻烙印在时光尘埃里，我们可以试着忽略，但这些微不足道的小事却一点一滴形成一条链子，将你牢牢与过去连在一起。 我喜欢看着围绕妈妈嘴角与眼周的细纹，我知道她很讨厌它们，但这些细纹却让我觉得心安，我从她脸上读到我们相依为命的痕迹。回到这里，或许我想念 的并不是我的童年，而是妈妈、我们相依的时光、星期六午后的超市生活、一起分享的晚餐、偶尔相对无言却更能感受彼此的亲密，很多夜里她都到我房间陪我，她会靠在我身旁，把手滑进我的发中…光阴转瞬即逝，这些最单纯的瞬间，却隽永地牢牢铭刻在我们心底。 你不能干涉别人的人生，就算是为了对方好。这是他的人生，只有他一个人能决定他的人生。你必须顺应事实，放手成长，你没有必要医治好在成长路上与你擦肩而过的每个人，即使你成为最顶尖的医生，也做不到这样。 生命中某些珍贵的片段，其实都来自于一些微不足道的小事. 青少年时期，我们总梦想着离开父母的一天，而改天，却换成父母离开我们了。于是我们就只能梦想着，能否有一时片刻，重新变回寄居父母屋檐下的孩子，能抱抱他们，不害羞地告诉他们，我们爱他们，为了让自己安心而紧紧依偎在他们身边。 神甫在妈妈的墓前主持弥撒。我听着他讲道，他说人们从来不会失去双亲，即使过世之后，他们还是与你们同在。那些对你们怀有感情，并且把全部的爱都奉献给你们，好让你们替他们活下去，会永远活在你们的心中，不会消失。 我再也不能看到你，再也不能听到你叫我的名字，就像从前每天早上你所做的那样。我再也嗅不到你衣服上适合你的香味，再也不能与你分享我的快乐与忧伤。我们再也不能互相倾诉，你再也无法整理插在客厅花瓶中的含羞草，那是我一月底为你摘来的。你再也不会戴夏天的草帽，不能披秋天第一波寒流来袭时你披在肩上的克什米尔披肩。你再也不会再十二月的雪覆盖花园时点燃壁炉。你在春天还未来临前离去，毫无预警地抛下我。在月台上得知你已不在时，我感觉到一生中前所未有的孤单。 每一个人都有自己的世界,一人一世界,光丽的外表或者强健的体魄并不能表示他人的幸福,每一个人都有自己的悲伤。外表风光强悍的马格,谁能想到他的晚餐没有一家人的陪伴，只有履行任务般的进行。这或许就是一个人光环下的阴影。所以没有一个人是最悲哀的。只是你不了解罢了。 我的白昼如同无止境的黑夜，而我如同行尸走肉肉一般穿越其中 我知道，人一旦开始说谎，就很难不继续下去，但我管不了那么多，每个人都有自己的理由。这一次，我也有我非得如此不可的理由]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[穷爸爸富爸爸]]></title>
      <url>http://www.lizorn.com//2016/06/14/Rich-Dad-Poor-Dad/</url>
      <content type="text"><![CDATA[人过三十,回想过往，在杭州折腾了几年,买房卖房,买车,现在回了自己老家,实在也没什么积蓄,有车有房那是负债,除此之外没有资产，更实现不了财务自由。倒不是觉得自己没有财商，而是缺少教育，缺乏思想的启蒙。这就是书的价值，让你有机会可以接触到优秀的思想，冲击你的价值观，引发自己的思考。我觉得实现财务自由，并不是你一定要有多少钱，而是你是否能够真正的脱离财务来实现自由，来让自己过的更充实，不用疲于上班疲于赚钱疲于那些冠冕堂皇的事业。有些人很富裕，但他的内心很贫瘠，有些人很贫穷，但是他的内心很富足，幸福就是如此吧。 读书笔记 要懂得如何[让钱来替你工作],而不是[为了钱而工作]. 作者不鼓励找一份”稳定的工作”,重要的是要有老板心态,要多想想自己要什么,要成为什么样的人,用老板的眼光思考全局.当你没有面包的时候,要考虑怎么让人给你送上面包,而不是自己上班去赚,饱汉不知饿汉饥,让饿汉去思考还是略难的. 什么是资产?资产是向你口袋送钱的东西.什么是负债?负债就是把钱从你口袋掏出的东西. 首先支付自己，先确保自己的资产,再去偿还负债,这样才能积累财富.比如,每个月拿出固定的资金进行理财和投资,剩余的部分偿还住房按揭,信用卡等等,那不够了怎么办?想办法开源啊. 从长期来看,重要的不是你挣了多少钱,而是要看你能留下多少钱,以及留住多久. 这点非常赞同.有一个同事,外号股神,她老婆就经常控诉他,’结婚没指望上他这笔钱,买房也没指望上他这笔钱,生娃更没指望上他这笔钱’,在股市里赚了再多的钱,不拿出来,那也只是个数字,没有转化到生活价值里,即便他是资产,它也可能会有赔的一天.做生意也一样,有些人大起大落,起的时候风光无限,落的时候一蹶不振,重要的不是你挣了多少钱,而是看你能保住多少留下多少,保住多久留住多久. 金钱从来不是真正的资产，我们唯一的，真正的资产是我们的头脑。 (即：思维方式) 学无止境，不要放弃对求知的渴望.觉得在校读书无用，是因为离开学校后就放弃了学习。最大的投资，就是投资教育，投资自己。 几个步骤,让我们开始行动. 我需要一个超现实的理由:精神的力量. 我们要财务自由 每天作出自己的选择:选择的力量,这是人们希望生活在一个自由国度的主要原因. 多学会思考 慎重的选择朋友–关系的力量。 物以类聚，人以群分 快速学习。 掌握一种模式，吃透它，举一反三，然后快速的学习另外一种。 首先支付自己–自律。 自律是最重要的，如果控制不了自己，就不要想着致富。在资产的支配上，首先支付自己 购买奢侈品。 用消费的欲望来激发并利用理财的天赋去投资 偶像。 对英雄的崇拜，可以借鉴和鞭挞自己，多看看传记 先予后取。 乐善好施是必须的，这就是给予的力量。如果你想获得就要先给予。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Angularjs2 5分钟入门手册(ts)]]></title>
      <url>http://www.lizorn.com//2016/06/06/angularjs2-5-MINUTE-QUICKSTART/</url>
      <content type="text"><![CDATA[译者注:仅是官方文档的翻译.5分钟教程,5分钟入门,过易,本不想译,久未译,遂译. 我们将基于TypeScript来构建一个超级简单的Anglarjs2应用，同时为后续的APP应用开发,搭建好Angularjs2的开发环境. 在线示例在线示例 开始构建APP!前提: 安装 Node.jsnodejs官网 步骤1: 创建和配置工程 (a)创造工程文件夹 (b)增加一个包定义并配置文件 (c)安装包 (a) 创建文件12mkdir angular2-quickstartcd angular2-quickstart (b) 增加包定义和配置文件 package.json NPM的包配置文件, 列举了QuickStart依赖的包并定义了一些有用的脚本. tsconfig.json TypeScript的编译器配置文件 typings.json TypeScript标示定义文件 systemjs.config.js SystemJS配置文件 package.json: 12345678910111213141516171819202122232425262728293031323334353637&#123; &quot;name&quot;: &quot;angular2-quickstart&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;scripts&quot;: &#123; &quot;start&quot;: &quot;tsc &amp;&amp; concurrently \&quot;npm run tsc:w\&quot; \&quot;npm run lite\&quot; &quot;, &quot;lite&quot;: &quot;lite-server&quot;, &quot;postinstall&quot;: &quot;typings install&quot;, &quot;tsc&quot;: &quot;tsc&quot;, &quot;tsc:w&quot;: &quot;tsc -w&quot;, &quot;typings&quot;: &quot;typings&quot; &#125;, &quot;license&quot;: &quot;ISC&quot;, &quot;dependencies&quot;: &#123; &quot;@angular/common&quot;: &quot;2.0.0-rc.2&quot;, &quot;@angular/compiler&quot;: &quot;2.0.0-rc.2&quot;, &quot;@angular/core&quot;: &quot;2.0.0-rc.2&quot;, &quot;@angular/http&quot;: &quot;2.0.0-rc.2&quot;, &quot;@angular/platform-browser&quot;: &quot;2.0.0-rc.2&quot;, &quot;@angular/platform-browser-dynamic&quot;: &quot;2.0.0-rc.2&quot;, &quot;@angular/router&quot;: &quot;2.0.0-rc.2&quot;, &quot;@angular/router-deprecated&quot;: &quot;2.0.0-rc.2&quot;, &quot;@angular/upgrade&quot;: &quot;2.0.0-rc.2&quot;, &quot;systemjs&quot;: &quot;0.19.27&quot;, &quot;core-js&quot;: &quot;^2.4.0&quot;, &quot;reflect-metadata&quot;: &quot;^0.1.3&quot;, &quot;rxjs&quot;: &quot;5.0.0-beta.6&quot;, &quot;zone.js&quot;: &quot;^0.6.12&quot;, &quot;angular2-in-memory-web-api&quot;: &quot;0.0.12&quot;, &quot;bootstrap&quot;: &quot;^3.3.6&quot; &#125;, &quot;devDependencies&quot;: &#123; &quot;concurrently&quot;: &quot;^2.0.0&quot;, &quot;lite-server&quot;: &quot;^2.2.0&quot;, &quot;typescript&quot;: &quot;^1.8.10&quot;, &quot;typings&quot;:&quot;^1.0.4&quot; &#125;&#125; tsconfig.json: 123456789101112&#123; &quot;compilerOptions&quot;: &#123; &quot;target&quot;: &quot;es5&quot;, &quot;module&quot;: &quot;commonjs&quot;, &quot;moduleResolution&quot;: &quot;node&quot;, &quot;sourceMap&quot;: true, &quot;emitDecoratorMetadata&quot;: true, &quot;experimentalDecorators&quot;: true, &quot;removeComments&quot;: false, &quot;noImplicitAny&quot;: false &#125;&#125; typings.json: 1234567&#123; &quot;globalDependencies&quot;: &#123; &quot;core-js&quot;: &quot;registry:dt/core-js#0.0.0+20160317120654&quot;, &quot;jasmine&quot;: &quot;registry:dt/jasmine#2.2.0+20160505161446&quot;, &quot;node&quot;: &quot;registry:dt/node#4.0.0+20160509154515&quot; &#125;&#125; systemjs.config.js: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * System configuration for Angular 2 samples * Adjust as necessary for your application needs. */(function(global) &#123; // map tells the System loader where to look for things var map = &#123; &apos;app&apos;: &apos;app&apos;, // &apos;dist&apos;, &apos;@angular&apos;: &apos;node_modules/@angular&apos;, &apos;angular2-in-memory-web-api&apos;: &apos;node_modules/angular2-in-memory-web-api&apos;, &apos;rxjs&apos;: &apos;node_modules/rxjs&apos; &#125;; // packages tells the System loader how to load when no filename and/or no extension var packages = &#123; &apos;app&apos;: &#123; main: &apos;main.js&apos;, defaultExtension: &apos;js&apos; &#125;, &apos;rxjs&apos;: &#123; defaultExtension: &apos;js&apos; &#125;, &apos;angular2-in-memory-web-api&apos;: &#123; main: &apos;index.js&apos;, defaultExtension: &apos;js&apos; &#125;, &#125;; var ngPackageNames = [ &apos;common&apos;, &apos;compiler&apos;, &apos;core&apos;, &apos;http&apos;, &apos;platform-browser&apos;, &apos;platform-browser-dynamic&apos;, &apos;router&apos;, &apos;router-deprecated&apos;, &apos;upgrade&apos;, ]; // Individual files (~300 requests): function packIndex(pkgName) &#123; packages[&apos;@angular/&apos;+pkgName] = &#123; main: &apos;index.js&apos;, defaultExtension: &apos;js&apos; &#125;; &#125; // Bundled (~40 requests): function packUmd(pkgName) &#123; packages[&apos;@angular/&apos;+pkgName] = &#123; main: &apos;/bundles/&apos; + pkgName + &apos;.umd.js&apos;, defaultExtension: &apos;js&apos; &#125;; &#125; // Most environments should use UMD; some (Karma) need the individual index files var setPackageConfig = System.packageWithIndex ? packIndex : packUmd; // Add package entries for angular packages ngPackageNames.forEach(setPackageConfig); var config = &#123; map: map, packages: packages &#125;; System.config(config);&#125;)(this); (c) 安装依赖包使用npm安装package.json列出的依赖包. npm install 如果typings文件夹没有在npm install后显示,则需手动安装.npm run typings install 步骤2:第一个Aungular组件在工程跟目录下创建一个子文件夹APP mkdir app 增加一个组件文件app/app.component.ts 内容如下: 123456import &#123; Component &#125; from &apos;@angular/core&apos;;@Component(&#123; selector: &apos;my-app&apos;, template: &apos;&lt;h1&gt;My First Angular 2 App&lt;/h1&gt;&apos;&#125;)export class AppComponent &#123; &#125; AppComponent是应用的根组件.每一个Angular应用至少有一个根组件,通常都命名为AppComponent,组件是Angular应用最基础的构建模块.组件通过其关联的模板控制着视图的展示. 本快速入门教程里的示例虽然只是一个超级简单的组件,但已经包含了每一个组件的基本结构要素. import 引用想要的模块. @Component 装饰器告诉Angular这个组件的模板以及如何构建组件 组件类通过模板来控制视图的展示和行为 ImportAngular的应用都是模块化的,他们由许多不同作用的文件组成.Angular本身就是是一个包含构建应用所需功能的模块库. 当我们需要某个模块或者库的时候,就import它. 示例中我们从Angular 2核心模块引入Component,这样就可以使用@Component装饰器了. import { Component } from &#39;@angular/core&#39;; @Component decoratorComponent是一个注释器函数,应用这类元数据对象函数需要在前面加个@符号.@Component是一个装饰器: 1234@Component(&#123; selector: &apos;my-app&apos;, template: &apos;&lt;h1&gt;My First Angular 2 App&lt;/h1&gt;&apos;&#125;) 这个元数据对象有两个属性,selector和template. selector声明了一个简单的CSS选择器用来表示代表组件的HTML元素.这个组件的HTML元素名为my-app,Angular创建AppComponent实例并展示到承载这个组件的HTML的每一个my-app元素里 template声明组件相关的模板,决定了Angular如何渲染组件. 组件类文件的最后是一个AppComponent类. export class AppComponent { } 由于本入门示例中不存在需要做的功能,目前AppComponent类是空的,以后我们想构建应用的时候,需要扩充类的特性和应用逻辑. 步骤3:增加main.ts现在我们需要告诉Angular要加载根组件了,创建app/main.ts,内容如下: 123import &#123; bootstrap &#125; from &apos;@angular/platform-browser-dynamic&apos;;import &#123; AppComponent &#125; from &apos;./app.component&apos;;bootstrap(AppComponent); 要启动应用,我们引入了两样东西: Angular的浏览器bootstrap功能 应用的根组件AppComponent 然后调用bootstrap(AppComponent),Bootstrapping是平台的一个特性. 注意到我们从@angular/platform-browser-dynamic而不是从@angular/core引入bootstrap功能. Bootstrapping不属于核心库,这是因为可能会有多种方式启动Angular应用(没错,移动端/桌面/web端等等).当然,大部分的应用都是从浏览器库调用bootstrap方法的.但也有可能从不同的环境里加载组件,比如从Apache Cordova或者NativeScript加载,并运行在移动设备上.我们也有可能希望从服务器渲染第一个页面来改进性能或者加强SEO.这就需要有不同种类的bootstrap. __为什么要分离main.ts和app组件文件这只是一个简单的入门示例,现在main.ts和app组件文件都很小,我们确实可以灵活的合并或者拆分它们.但我们想阐述一个更合理的Angular应用架构.App引导程序在不同的环境里多种多样,模块化分离文件,可以让测试变的更容易些,可以对某个组件进行单元测试,而不需要启动整个应用. 步骤4:增加index.html在工程根目录里创建一个index.html: 1234567891011121314151617181920212223&lt;html&gt; &lt;head&gt; &lt;title&gt;Angular 2 QuickStart&lt;/title&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;styles.css&quot;&gt; &lt;!-- 1. Load libraries --&gt; &lt;!-- Polyfill(s) for older browsers --&gt; &lt;script src=&quot;node_modules/core-js/client/shim.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;node_modules/zone.js/dist/zone.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;node_modules/reflect-metadata/Reflect.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;node_modules/systemjs/dist/system.src.js&quot;&gt;&lt;/script&gt; &lt;!-- 2. Configure SystemJS --&gt; &lt;script src=&quot;systemjs.config.js&quot;&gt;&lt;/script&gt; &lt;script&gt; System.import(&apos;app&apos;).catch(function(err)&#123; console.error(err); &#125;); &lt;/script&gt; &lt;/head&gt; &lt;!-- 3. Display the application --&gt; &lt;body&gt; &lt;my-app&gt;Loading...&lt;/my-app&gt; &lt;/body&gt;&lt;/html&gt; 这个index.html文件定义了承载这个应用的web页.HTML里的关键部分有: JavaScript库 SystemJS的配置文件,一个导入app模块引用main文件的脚本 在里的标签,这是我们这个应用渲染位置. 库我们加载以下脚本: 12345&lt;!-- Polyfill(s) for older browsers --&gt;&lt;script src=&quot;node_modules/core-js/client/shim.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;node_modules/zone.js/dist/zone.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;node_modules/reflect-metadata/Reflect.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;node_modules/systemjs/dist/system.src.js&quot;&gt;&lt;/script&gt; 首先是core-js,它是一个ES2015(ES6)的shim,这个猴子补丁替换全局上下文(window)的ES6功能要素.接着是Angular2,zone.js,reflect-metadata的plyfills,这样这些功能就可以兼容老的浏览器了.最后是用于模块加载的库SystemJS. SystemJS入门教程使用SystemJS加载应用和库模块.之前我们已经将systemjs.config.js文件加入到了工程根目录了.基本上可以用webpack替换,不过SystemJS已经是个好选择了,最终选择权这个取决于你. 所有的模块加载都需要有配置,所有的加载配置都会随着结构增加或者考虑性能等而变的复杂.我们建议在你精通加载器的配置,SystemJS配置教程. 有了这些意识后,我们看看systemjs.config.js做了些什么?首先,我们创建一个map告诉SystemJS去哪里查找需要引入的模块.然后,将所有的包注册到SystemJS,包括:工程依赖包和应用包,app包.app包告诉SystemJS如何从app/文件目录里请求一个模块.本示例使用TypeScript导入：1import &#123; AppComponent &#125; from &apos;./app.component&apos;; 注意模块名不需要文件扩展名，SystemJS根据配置文件设置文件的默认扩展名为js. System.import告诉SystemJS导入main文件；main是Aangular应用启动入口，我们可以抓取并记录启动时候的错误信息。所有其他的模块都由import导入. Angular调用main.ts里的bootstrap函数，它读取AppComponent的元数据，找到my-app选择器，定位my-app元素标签，并将组件转染到这些标签里. 增加样式样式并不是必须的但样式会让应用更加美观，在index.html里假设有个层级样式styles.css。创建一个styles.css文件在工程根目录，内容如下： 12345678910111213h1 &#123; color: #369; font-family: Arial, Helvetica, sans-serif; font-size: 250%;&#125;body &#123; margin: 2em;&#125; /* * See https://github.com/angular/angular.io/blob/master/public/docs/_examples/styles.css * for the full set of master styles used by the documentation samples */ 步骤5：构建和运行APP！打开一个终端窗口，敲入如下命令：npm start这个命令执行了两条node进程： 及时监控进行TypeScript编 lite-server静态服务器加载index.html到浏览器，当应用文件有修改时实时刷新浏览器 浏览器上就会打开并显示: wrap up我们最终的工程文件结构如下：1234567891011121314151617181920212223--angular2-quickstart----app------app.component.ts------main.ts----node_modules ...----typings ...----index.html----package.json----styles.css----systemjs.config.js----tsconfig.json----typings.json 打包下载 下一步？我们第一个应用没有太多的功能，只是最基础的angular2的”Hello, World”应用。我们写了一个简单的angular组件，构建了一个简单的index.html,并通过一个静态文件服务器加载它.这些就是这个 “Hello, World” app的全部了 后续教程 Tour of Heroes Tutorial!]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[vs code 使用指南]]></title>
      <url>http://www.lizorn.com//2016/04/05/visual-studio-code-user-manual/</url>
      <content type="text"><![CDATA[基础设置字体设置 File-&gt;Preferences-&gt;User Settings 添加 “editor.fontSize”: 16 编码设置 User Settings 查看 Workspace Settings 的 files.encoding 命令面板 CMD+SHIFT+P 打开命令面板 CMD+P 通用命令面板.查找文件或者进行符号查找 ?: 查看命令行列表 #: 查找工程内匹配符号 @: 表示符号查找,接:进行删选符号查找.(CMD+SHIFT+O) !: 显示warnning和error.(CMD+SHIFT+M) CMD+Shift+F:跨文件搜索 CMD+G:跳转到行 CMD+TAB: 历史文件切换 编辑器 CMD+SHIFT+N: 打开新的编辑器窗口 CMD+N: 创建新文件 CMD+\: 分割编辑窗口. ‘Cmd’+ 1/2/3进行切换 CMD+B: 切换侧边栏 快捷键https://code.visualstudio.com/docs/customization/keybindings 智能编辑 CMD+.: 快速修复 更多 重构 OPT+UPARROW/DOWNARROW: 上下移动行 F8: 移动到下一个’Warning’或’Error’ F12/OPTION+F12: 跳转到定义 SHIFT F12: 查找所有的引用 CMD+F2/CMD+D: 匹配选择,本地重构 Click + OPTION: 点击选择,本地重构 F2:文件内重命名 Alt+Shift+F: 格式化 调试Debug快捷键 Continue / Pause F5 Step Over F10 Step Into F11 Step Out Shift+F11 Restart Ctrl+Shift+F5 Stop Shift+F5 更多 版本管理COMMITCMD+SHIFT+G进入git版本管理 CMD+ENTER:输入message后commit 切换分支CMD+P 输入 git checkout * 冲突管理版本库Visual Studio Team Services]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[统计数字会说谎]]></title>
      <url>http://www.lizorn.com//2016/03/12/how-to-lie-with-stastics/</url>
      <content type="text"><![CDATA[序 虽然经验告诉我们’眼见为实’,但眼睛告诉我们的’真想’或许隐瞒了部分事实,或许夸大了事实. 统计这种神秘的语言,在一个靠数字说话的社会里是如此地吸引眼球,但有时它却被人利用,并成为恶意夸大或简化事实,迷惑他人的工具. 该书是一个利用统计数据行骗的入门书籍. 样本偏离统计数字的样本经常存在严重偏离的情况.会接受抽样调查的人,某种意义上已经进行了一部分情景化的过滤.样本碍于情面或者是尊严的问题,未必会说真话. 小结 为了确保结论有价值,根据抽样得出的结论一定要采用具有代表性的样本,这种样本才有可能排除误差 无形的误差和有形的误差一样容易破坏样本的可行度. 最基本的样本是随机样本,它是完全遵循随机原则从总体总选出来的.随机样本的校验方法:总体中的每个名字或每个事物是否具有相同的几率被选进样本? 一般而言,民意调查都具有一定的误差. 精心挑选的平均数 平均数：一组数据的总和除以这组数据个数所得到的商叫这组数据的平均数. 中位数：将一组数据按大小顺序排列,处在最中间位置的一个数叫做这组数据的中位数 . 众数：在一组数据中出现次数最多的数叫做这组数据的众数. 当你看到某个平均收入时,首先问问:是什么的平均?包括了哪些人? 没有披露的数据有时候单凭一个数据,如平均数来描述事物过于简单,起不到作用,不管这个平均数是均值还是中位数,也不管平均数的具体类型是否已知.需要关注其他未披露的数据,才能判断统计数据的准确性. 令人惊奇的图形 最简单的图形是直线图形,在显示趋势时,直线图形非常有用.然而只需要改变纵坐标和横坐标的比例关系,将会产生一张有迷惑作用的统计图形.统计图形具有客观性幻觉. 用图形描述统计事物,具有欺骗性,视觉作用起了非常大的作用.如数字比是2:1,但视觉效果却是4:1,而在大多数时候视觉效果起着决定性的作用. 相关关系的误解 两个事物之间的关联关系并不能用于说明其中一个将引起另外一个的变化. 如何反驳统计资料怎样凭借双眼就能识破虚假的统计资料,并揭开它的老底;同样重要的是,如何在这一大片充满了欺骗性的数据海洋中找出可靠有用的资料,我们只需要问5个问题. 谁说的?学术结论,实验结果以及报道引用都可能产生偏差,这些偏差可能是测量标准的改动造成的,也可能是不正确的测量方法造成的. 查看有意识的偏差. 查找无意识的偏差. 如引用到了权威人士,辨明内容是权威的还是资料是权威的. 它是如何知道的? 看样本是否有偏离. 采样数据是否足够大,观察值是否足够,从而保证结论的可靠性? 遗漏了什么? 很多数据由于没有进行有效的比较而失去意义 有时仅给出百分比却缺少原始数据也会造成欺骗.当看到一个指数时,需要了解它的基数. 遗漏了引起变化的原因,这容易让人认为是其他的因素才应对产生的变化负责. 如报道’最近25年癌症死亡人数增多’,这个结论会有误导性.事实上人口也在增多. 是否有人偷换了概念?数据的概念是否存在欺诈性?需要留心从搜集原始资料到形成结论的整个过程中,是否存在概念的偷换. 这个资料有意义吗?这个问题通常能将一个伪装的很好的统计资料打回原形.让人印象深刻的统计数据也会和实际情况相左. 奇妙的数据与平常的感觉不符 外推法十分有用,特别是预测趋势时.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[渔家傲·塞下秋来风景异]]></title>
      <url>http://www.lizorn.com//2016/03/12/songci-3/</url>
      <content type="text"><![CDATA[【原文】渔家傲·塞下秋来风景异 作者：范仲淹 塞下①秋来风景异，衡阳雁去②无留意。四面边声③连角起，千嶂④里，长烟⑤落日孤城闭。 浊酒一杯家万里，燕然未勒⑥归无计。羌管⑦悠悠霜满地⑧。人不寐，将军白发征夫泪。 【注释】 ①塞下：边地。风景异：指景物与江南一带不同。 ②衡阳雁去：雁去衡阳的倒文。湖南衡阳县南有回雁峰，相传雁至此不再南飞。 ③边声：马嘶风号之类的边地荒寒肃杀之声。角：军中的号角。 ④嶂：像屏障一样并列的山峰。 ⑤长烟：荒漠上的烟。 ⑥燕然未勒：无破敌之功。燕然：山名，即今蒙古境内之杭爱山。勒：刻石记功。东汉窦宪追击北匈奴，出塞三千馀里，至燕然山刻石记功而还。燕然未勒：指边患未平、功业未成。 ⑦羌管：羌笛，因出自羌中，得名。 ⑧霜满地：喻夜深寒重。 【作品简介】这是一首抒怀词。当时范仲淹任陕西经略副使兼知延州（今陕西延安市）。这是当时第一首描写边塞题材的作品，也是宋代最早表现军旅生活的词作。上阕写景。首句顿入，起调突兀，俊骨雄风，已自夺人。千峰连亘如屏障，一座孤城，日未落而城门紧闭。也突出布防将士的备战警惕。下阕抒情。表达将士功业未立，无计归家的责任感，披露爱国衷肠。不愧苍凉感慨的豪士之伟词。这首词开启了苏辛豪放派的先声。 【翻译】边境上秋天一来风景全异，向衡阳飞去的雁群毫无留恋的情意。从四面八方传来的边地悲声随着号角响起。重重叠叠的山峰里，长烟直上落日斜照孤城紧闭。 喝一杯陈酒怀念家乡远隔万里，可是燕然还未刻上平胡的功绩，归期无法预计。羌人的笛声悠扬，寒霜撒满大地。征人不能入睡，将军头发花白，战士洒下眼泪。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Javascript精髓笔记]]></title>
      <url>http://www.lizorn.com//2016/03/12/the-good-parts-of-javascript/</url>
      <content type="text"><![CDATA[语法注释 没有用的注释比没有注释更糟糕. 建议避免使用/* */注释(可能会出现在正则表达式中),使用//. 数字 javascript只有一个数字类型,它在内部表示为64位的浮点数,和double类型一样. 负数可以用 - 加数字构成. NaN是一个数值,它表示一个不能产生正常结果的运算结果.isNaN(number)检测NaN. 字符串 \是转义字符 Unicode是一个16位的字符集,Javascript的所有字符都是16位的. Javascript没有字符类型 字符串是不可变的,可以通过+运算符连接其他字符串来创建一个新字符串. 对象引用 对象通过引用来传递,引用不会复制 原型 每一个对象都有一个原型对象,Object.prototype是Javascript中的标配对象 原型连接在更新时不起作用,对某个对象做出改变时,不会触及该对象的原型 原型连接在检索的时候会用到,属性会从原型链上查找. typeof和hasOwnProperty可以检查属性是否在对象中,后者不会检查原型链 枚举 for in该语句会遍历一个对象中的所有属性名.该枚举过程将会列出原型链上的所有属性,最常用的过滤器是hasOwnProperty方法,以及typeof来排除函数. 123456var name;for (name in sample) &#123; if (typeof sampe[name] !== 'function') &#123; document.writeln(name + ':' + sample[name]); &#125;&#125; 属性名出现的顺序是不确定的,通过for而不是for in才能按顺序获取属性 删除delete 不会删除原型链上的属性. 减少全局变量的污染Javascript可以随意的使用全局变量,全局变量削弱了程序的灵活性,应当避免使用. 函数 JS中函数是对象,每个函数创建的时候会附加两个隐藏属性:函数的上下文和实现函数行为的代码. 方法调用模式当一个函数被保存为一个对象的属性时,我们称之为方法.当一个方法被调用时,this被绑定到该对象 函数调用模式当一个函数并非一个对象的属性时,那么会被当做一个函数来调用,此时this被绑定到了全局变量(设计失误),可以用that方式来解决这个问题. 1234567891011myObject.double = function() &#123; var that = this; var helper = function ( that.value = add(that.value,that.value); ); helper(); //以函数的形式调用&#125;;myObject.double();doucument.writeln(myObject.vale); Apply调用模式因为JS是一门函数式的面向对象的语言,所以函数可以拥有方法. apply方法接收两个参数,第一个绑定给this,第二个是参数数组. 12var array = [3,4]; //构造一个包含两个数字的数组,并将它们相加.var sum = add.apply(null,array); // sum为7 闭包 避免属性被非法更改 省去想函数名字的麻烦 回调回调属于异步调用,执行上不会堵塞,事件驱动模式提高并发量和响应速度,nodejs上大量使用 模块我们可以使用闭包或者函数来构造模块.模块是一个提供接口缺隐藏状态与实现的函数或对象,可以提高程序的复用性. 数组 长度: JS的数组长度无上限 判断一个对象是否是数组: 123 var is_array = function (value) &#123; return Object.prototype.toString.apply(value) === '[object Array]';&#125; 方法:增加一个方法给数组 1234567Array.method('reduce', function (f,value) &#123; var i; for (i = 0; i &lt; this.length; i += 1)&#123; value = f(this[i],value); &#125; return value;&#125;) 制定初始值: 1234567Array.dim = function (dimension, initial) &#123; var a = [], i; for (i = 0; i &lt; dimension; i += 1) &#123; a [i] = initial; &#125; return a;&#125;; 正则表达式Javascript是一个大杂烩,许多特性继承自其他语言,语法继承自java/C,函数借鉴自Scheme,原型继承自Self. 示例1234var parse_url = /^(?:([A-Za-z]+):)?(\/&#123;0,3&#125;)([0-9.\-A-Za-z]+)(?::(\d+))?(?:\/([^?#]*))?(?:\?([^#]*))?(?:#(.*))?$/;var url = "http://www.ora.com:80/goodparts?q#fragment";var result = parse_url1.exec(url); //["http://www.ora.com:80/goodparts?q#fragment", "http", "//", "www.ora.com", "80", "goodparts", "q", "fragment"] ^ : 字符串开始标记. (?:([A-Za-z]+):): ?::非捕获性匹配 +: 匹配一次或多次 ?: 匹配零次或一次 (\/{0,3}):最少匹配0次,最多匹配3次 ([0-9.\-A-Za-z]+): 匹配主机名 (?::(\d+))?: 端口号匹配 (?:\/([^?#]*))?: 匹配出去?和#之外的所有字符. 结构有两个方法来创建一个RegExp对象. 正则表达式字面量. 如上文示例中的正则表达式就是采用字面量的方式. 1var reg=/&lt;%[^%&gt;]%&gt;/g; 使用RegExp构造器. 1var reg=new RegExp('&lt;%[^%&gt;]+%&gt;','g');; 正则表达式标识符 标示 含义 g 全局的(匹配多次) i 大小写不敏感 m 多行 元素构成正则表达式的元素有如下几种 正则表达式分支一个正则表达式分支包含一个或多个正则表达式序列.序列被|字符分隔. 1"into".match(/in|int/) //in匹配成功,不会去匹配int 正则表达式序列一个正则表达式序列包含一个或多个正则表达式因子. 正则表达式因子一个正则表达式因子可以是一个字符,圆括号包含的组,字符类,或者一个转义序列. 1\ / [ ] ( ) &#123; &#125; ? + * | . ^ $ 正则表达式转义 正则表达式分组 捕获型 非捕获型: ?: 向前正向匹配: ?= 向前负向匹配: ‘?!’ 正则表达式字符集: 一种指定一组字符的便利方式. 1(?:a|e|i|o|u) //写成 [aeiou] 正则表达式字符转义:在字符类中需要被转义的特殊字符有 1- / [ \ ] ^ 正则表达式量. 用来决定因子的匹配次数. 如{m,n} 方法Arrayconcat和pushconcat方法产生一个新数组,它包含一份array的浅复制.push和concat不同,push的参数作为单个元素添加到数组,并返回新数组的长度. 1234var a = ['a', 'b', 'c'];var b = ['x', 'y', 'z'];var c = a.concat(b, true);// c is ['a', 'b', 'c', 'x', 'y', 'z', true]var d = a.push(b,true) // a is ['a', 'b', 'c', ['x', 'y', 'z'], true], d is 5; join建议用+,性能更优 pop 和 shift类似stack, 移除最后一个元素,并返回该元素. 123var a = ['a', 'b', 'c'];var c = a.pop( ); // a is ['a', 'b'] &amp; c is 'c'var d = a.shift( ); // a is ['b'] &amp; d is 'a' push 和 unshiftpush将元素插入到数组末尾,unshift相反. 123var a = ['a', 'b', 'c'];var r = a.unshift('?'); // a is ['?', 'a', 'b', 'c'], r is 4var p = a.push('@');// a is ['?', 'a', 'b', 'c', '@'], p is 5 sort 和 reverse123var n = [4, 8, 15, 16, 23, 42,"a","b"];var b = n.sort( ); //n和b 都是 [15, 16, 23, 4, 42, 8, "a", "b"]var b = n.reverse( ); //n和b 都是 ["b", "a", 8, 42, 4, 23, 16, 15] sliceslice方法对array中的一段做浅复制. 1234var a = ['a', 'b', 'c'];var b = a.slice(0, 1); // b is ['a']var c = a.slice(1); // c is ['b', 'c']var d = a.slice(1, 2); // d is ['b'] splicearray.splice(start, deleteCount, item…) : 从start开始删除deleteCount数量的元素,并用item替换 1234var a = ['a', 'b', 'c'];var r = a.splice(1, 1, 'ache', 'bug');// a = ['a', 'ache', 'bug', 'c']// r = ['b'] Functionapplyapply 方法调用function, 产地一个会绑定到this上的对象和一个可选的数组作为参数. 123456789101112131415Function.method('bind', function (that) &#123; // Return a function that will call this function as // though it is a method of that object. var method = this, slice = Array.prototype.slice, args = slice.apply(arguments, [1]); return function ( ) &#123; return method.apply(that, args.concat(slice.apply(arguments, [0]))); &#125;;&#125;);var x = function ( ) &#123; return this.value;&#125;.bind(&#123;value: 666&#125;);alert(x( )); // 666 Number toExponential(fractionDigits):把number转换成一个指数形式的字符串.参数(0-20)控制小数点后的数字位数. 12Math.PI.toExponential() //"3.141592653589793e+0"Math.PI.toExponential(2) //"3.14e+0" toFixed(fractionDigits):把number转换成一个整数形式的字符串.参数(0-20)控制小数点后的数字位数. 123Math.PI.toFixed() //"3"Math.PI.toFixed(2) //"3.14"Math.PI.toFixed(0) //"3" toPrecision(precision):和toFixed类似,参数为精度. 12Math.PI.toPrecision() //"3.141592653589793"Math.PI.toPrecision(2) //"3.1" toString(radix):将number转换成为一个字符串,参数(2-36,默认10)为控制转换进制的基数. 12Math.PI.toString() //"3.141592653589793"Math.PI.toString(2) //"11.001001000011111101101010100010001000010110100011" Object hasOwnProperty(name):查看object是否包含该属性,原型链上不检查. 12345var a = &#123;member: 1&#125;;var b = Object.create(a);var t = a.hasOwnProperty('member'); // t is truevar u = b.hasOwnProperty('member'); // u is falsevar v = b.member; // v is 1 String charAt(pos): 返回string中pos位置的字符. 12var name = 'LZ';var initial = name.charAt(0); // initial is 'L' 实现 123String.method('charAt', function (pos) &#123; return this.slice(pos, pos + 1);&#125;); charCodeAt(pos): 返回pos位置的字符的字符码位. 12var name = 'LZ';var initial = name.charCodeAt(0); // 76 indexOf(searchString,position): 在string内查找从position开始的字符串searchString,并返回起始位. 和一些Regexp相关的方法:’match’,’replace’,’search’ slice,toLowerCase,toUpperCase 代码风格 空格:缩进为4个空格,除了.和[后均跟一个空格 K&amp;R风格,把{放在一行的结尾 毒瘤全局变量JS的全局变量降低了程序的可靠性,全局变量的三种方式: foo = value```1- 直接给全局变量添加一个属性 ```window.foo = value 隐式全局变量 foo = value 作用域Javascript的语法来自C,一个代码块会创造一个作用域.代码块中声明的变量在其外部是不可见的.JS采用这样的块语法,却没有提供块级作用域:代码块中声明的变量在包含此代码块的函数的任何位置都是可见的. 保留字保留字过多,而大部分并不是经常使用. UnicodeJS的Unicode是16位 糟粕请避免使用以下几个方法,使javascript的代码更加的简洁和高效. ==和!= with eval continue switch穿越 缺少块语句.判断语句用{}分隔. ++ --:递增和递减避免使用++,–的方式,使代码更为简洁 位运算符:Javascript没有整数类型,它只有双精度的浮点数,执行位运算的效率较低,要避免使用. void. new]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[木兰花·城上风光莺语乱]]></title>
      <url>http://www.lizorn.com//2016/03/11/songci-2/</url>
      <content type="text"><![CDATA[【原文】木兰花·城上风光莺语乱① 作者：钱惟演 城上风光莺语乱②，城下烟波春拍岸。绿杨芳草几时休，泪眼愁肠先已断。 情怀渐觉成衰晚③，鸾镜④朱颜⑤惊暗换⑥。昔年⑦多病厌芳尊⑧，今日芳尊惟恐⑨浅。 【注释】 ①木花兰：通称《玉楼春》。 ②莺语：指美好的声音。 ③衰晚：衰弱的晚年。 ④鸾镜：厨（ｃｈú）宾王有鸾，三年不鸣。夫人说悬镜照之，鸾见影则鸣。故后世称镜为鸾镜，多借此词表达离愁别恨。 ⑤朱颜：朱，红。红润美好的容颜。南唐 李煜 《虞美人》词：“雕栏玉砌依然在，只是朱颜改。”宋 司马光 《和子华招潞公暑饮》：“闲来高韵浑如鹤，醉里朱颜却变童。”这里都是指容颜的改变。 ⑥暗换：这里指不知不觉的变成了殘颜。 ⑦昔年：一作“划年”，指今年，或者近几年。 ⑧芳尊：酒杯，指饮酒。尊，同“樽”。 ⑨惟恐：惟，只、单，唯一、只有。恐，怕。这里说只怕今天的容颜不好看。不美丽。 【作品简介】《木兰花·城上风光莺语乱》由钱惟演创作，被选入《宋词三百首》。这首词是作者临死前不久的一首伤春之作。上阕由景入情，下阕直抒愁怀。“情怀渐觉”、“衰晚”，一“渐”字，表达出时间的推移催老世人的历程，接着，作者又惊异地发现镜中“朱颜”已“暗换”，进一步表达“衰晚”之感。“今日”虽仍有病，可愁比病更强烈，因而不顾病情而痛饮狂喝，将全词愁绪推向高潮。 【翻译】城上眺望，风光大好，黄莺儿的叫声乱成一片。城下湖面上烟波浩渺，春水烟波浩渺，春水不断地拍打着堤岸。这令人伤怀的青青杨柳如绵绵芳草啊，你们什么时候才能变得没有呢？我眼中充满泪水，愁绪袭来，先就使我肝肠寸断了。 我觉得自己的情怀渐渐像个老人，没有生气了。还吃惊的发现镜子中昔日红润的容颜，在不知不觉中改换了，已变得如此憔悴苍老。往年，我体弱多病，讨厌去碰那美酒金杯，如今杯儿在前，却唯恐酒斟得不满。 【赏析】 这首词是作者临死前不久的一首伤春之作。上阕由景入情，下阕直抒愁怀。“情怀渐觉”、“衰晚”，一“渐”字，表达出时间的推移催老世人的历程，接着，作者又惊异地发现镜中“朱颜”已“暗换”，进一步表达“衰晚”之感。“今日”虽仍有病，可愁比病更强烈，因而不顾病情而痛饮狂喝，将全词愁绪推向高潮。 作者一生仕宦显达，晚年被贬外放，自觉政治生命与人生旅途都到了尽头，因作此词，借悼惜春光抒发他无限的迟暮之悲。词中用清丽的语言描绘了春声、春色，首句的“乱”字用得极好，将春景渲染得十分生动热闹，而群莺乱啼已是暮春天气，这里也暗含春光将尽之意。作者又用明丽的景色来反衬自己凄黯的心情，以及对于年光飞逝、生命无多的感伤。末二句以借酒浇愁来表现他无可奈何的心境，又隐约地显示了他对生命的留恋，尤其传神。整首词情调极其凄婉。 作品中的“芳草”、“泪眼”、“鸾镜”、“朱颜”等意象无不充满绝望后的浓重感伤色彩，反映出宋初纤丽词风的艺术特色。 上片起首两句，从城上和城下两处着墨，声形兼备、富于动感地描绘春景，勾勒出一幅城头上莺语阵阵、风光无限；城脚下烟波浩淼、春水拍岸的图画，使读者隐然感觉到主人公的伤春愁绪，从而为下文的遣怀抒情作好了铺垫。 上片结末两句转而抒情，言绿杨芳草年年生发，而词人已是眼泪流尽，愁肠先断，愁惨之气溢于言表。从表现手法上讲，用绿杨芳草来渲染泪眼愁肠，也就达到了情景相生的效果，情致极为凄婉。此二句由景入情，词意陡转，波澜突起。 过片两句，从精神与形体两方面感叹老之已至，抒写了词人无可奈何的伤感情怀。从中可以窥见，一贬汉东，默默无闻，大势已去，这对于曾经“官兼将相，阶勋、品皆第一”的作者来说，打击是多么巨大。结拍两句将借酒浇愁这一司空见惯的题材赋予新意，敏锐而恰切地扣住词人对“芳尊”态度的前后变化这一细节，形成强烈反差，由景入情，画龙点睛，传神地抒发出一个政治失意者的绝望心情。宋胡仔《苕溪渔隐丛话》卷二云：“侍儿小名录云：‘钱思公谪汉东日（指钱惟演晚年谪随州），撰《玉楼春》词曰：“城上风光莺语乱，城下烟波春拍岸。绿杨芳草几时休，泪眼愁肠先已断。情怀渐变成衰晚，鸾镜朱颜惊暗换。往年多病厌芳樽，今日芳樽惟恐浅。”每酒阑歌之，则泣下。后阁有白发姬，乃邓王歌鬟惊鸿也。遽言：“先王将薨，预戒挽铎中歌《木兰花》（即《玉楼春》）引绋为送。今相公亦将亡乎。”果薨于随州。’”可为此词注脚。 宋仁宗明道二年（1033）三月，垂帘听政的刘太后死。仁宗随即亲政，并迅速清除刘太后党羽。钱惟演是刘太后的姻亲，自然在劫难逃。九月，他因为擅议宗庙罪而被免除平章事的官职，贬为崇信军节度使，谪居汉东。不久，其子钱暖被罢官，姻亲郭皇后被废。该词就写于这个时期，抒发了作者政治失意的绝望之情。作品借丽景抒哀情，首句以一“乱”字，就将暮春之景渲染得有声有色，同时也以此反衬自己年华将逝的凄黯心情，从而形成强烈对比，凄惋动人。 【作者介绍】 钱惟演（977—1034）北宋大臣，西昆体骨干诗人。字希圣，钱塘（今浙江杭州）人。吴越忠懿王钱俶第十四子。从俶归宋，历右神武将军、太仆少卿、命直秘阁，预修《册府元龟》，累迁工部尚书，拜枢密使，官终崇信军节度使，博学能文，所著今存《家王故事》、《金坡遗事》。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jQuery基础]]></title>
      <url>http://www.lizorn.com//2016/03/10/learning-jquery-lesson/</url>
      <content type="text"><![CDATA[选择元素sample12345678910111213141516171819202122&lt;$(document).ready(function() &#123; $('#selected-plays &gt; li').addClass('horizontal'); // Find First top li elements ,add css horizontal $('#selected-plays li:not(.horizontal)').addClass('sub-level'); //Find all li elements without class horizontal $('a[href^="mailto:"]').addClass('mailto');//Find anchor element that href begin with "mailto" $('a[href$=".pdf"]').addClass('pdflink');//href end with ".pdf" $('a[href^="http"][href*="henry"]').addClass('henrylink');//href begin with "http" and has "henry" $('a').filter(function() &#123; //filter the hostname return this.hostname &amp;&amp; this.hostname != location.hostname; &#125;).addClass('external'); $('tr:nth-child(odd)').addClass('alt'); //select all odd child by current parent,start with 1. $('td:contains(Henry)') // Find every cell containing "Henry" .parent() // Select its parent .find('td:eq(1)') // Find the 2nd descendant cell .addClass('highlight') // Add the "highlight" class .end() // Return to the parent of the cell containing "Henry" .find('td:eq(2)') // Find the 3rd descendant cell .addClass('highlight'); // Add the "highlight" class &#125;); 给位于嵌套列表第二个层次的所有&lt;li&gt;元素添加special类；1234$(document).ready(function() &#123; $('#selected-plays li li').addClass('special'); &#125;); 给位于表格第三列的所有单元格添加year类；123$(document).ready(function() &#123; $('td:nth-child(3)').addClass("year") &#125;); 为表格中包含文本Tragedy的第一行添加special类；123$(document).ready(function() &#123; $('td:contains(Tragedy)').first().addClass('special'); &#125;); 选择包含链接（&lt;a&gt;）的所有列表项（&lt;li&gt;元素），为每个选中的列表项的同辈列表项元素添加afterlink类；123$(document).ready(function() &#123; &lt;span style="font-family: monospace; white-space: pre; background-color: rgb(240, 240, 240);"&gt;$('li a').parent().nextAll().addClass('afterlink')&lt;/span&gt;; &#125;); 为与.pdf链接最接近的祖先元素添加tragedy类123$(document).ready(function() &#123; $('a[href$=".pdf"]').closest('ul').addClass('Tragedy');; &#125;); 事件tips:事件冒泡 1.特定元素响应事件需要停止事件传播[.stopPropagation()]2.部分事件处理对象，如锚元素（），需要阻止默认操作[.preventDefault()]3.利用事件冒泡实现事件委托 分析和练习123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124$(document).ready(function() &#123; /*Enable hover effect on the style switcher*/ $('#switcher').hover(function() &#123; $(this).addClass('hover'); &#125;, function() &#123; $(this).removeClass('hover'); &#125;);//绑定悬停效果，在鼠标enters和leaves元素时启用对应样式 /*Allow the style switcher to expand and collapse.*/ var toggleSwitcher = function(event) &#123; if (!$(event.target).is('button')) &#123; $('#switcher button').toggleClass('hidden'); &#125; &#125;;//是否包含button标签，toggleClass根据类是否存在而添加或删除类 $('#switcher').on('click', toggleSwitcher);//注册click事件 /* Simulate a click so we start in a collaped state.*/ $('#switcher').click(); /* The setBodyClass() function changes the page style. The style switcher state is also updated.*/ var setBodyClass = function(className) &#123; $('body').removeClass().addClass(className); $('#switcher button').removeClass('selected'); $('#switcher-' + className).addClass('selected'); $('#switcher').off('click', toggleSwitcher); if (className == 'default') &#123; $('#switcher').on('click', toggleSwitcher); &#125; &#125;; /*begin with the switcher-default button "selected"*/ $('#switcher-default').addClass('selected'); /*Map key codes to their corresponding buttons to click*/ var triggers = &#123; D: 'default', N: 'narrow', L: 'large' &#125;; // Call setBodyClass() when a button is clicked. $('#switcher').click(function(event) &#123; if ($(event.target).is('button')) &#123; var bodyClass = event.target.id.split('-')[1]; setBodyClass(bodyClass); &#125; &#125;); // Call setBodyClass() when a key is pressed. $(document).keyup(function(event) &#123; var key = String.fromCharCode(event.which); if (key in triggers) &#123; setBodyClass(triggers[key]); &#125; &#125;); /*Enable hover effect on the style switcher*/ $('#header div').hover(function() &#123; $(this).addClass('hover'); &#125;, function() &#123; $(this).removeClass('hover'); &#125;); //(1) 在Charles Dickens被单击时，给它应用selected样式 $('#header div').click(function(event) &#123; $('#header div').removeClass().addClass('selected'); &#125;); //(2) 双击章标题（&lt;h3 class="chapter-title"&gt;）时，切换章文本的可见性 $('div.chapter').click(function(event) &#123; if ($(event.target).is('h3')) &#123; $(event.target).parent().find('p').toggleClass('hidden'); &#125; &#125;); //(3) 用户按下向右方向键时，切换到下一个body类 $(document).keyup(function(event) &#123; if (event.keyCode == 39) &#123; var curBodyClass=$('body').attr('class'); switch(curBodyClass) &#123; case 'default': setBodyClass('narrow'); break; case 'narrow': setBodyClass('large'); break; case 'large': setBodyClass('default'); break; default: setBodyClass('narrow'); break; &#125; &#125; &#125;); /*(4) 使用console.log()函数记录在段落中移动的鼠标的坐标位置。（注意：console.log() 可以在Firefox的firebug扩展、Safari的Web Inspector或Chrome、IE中的Developer Tools中使 用。*/ $('p').mousemove(function(e)&#123; console.log("mouseXY:"+ e.pageX+","+ e.pageY); &#125;); /*(5) 使用.mousedown()和.mouseup()跟踪页面中的鼠标事件。如果鼠标按键在按下 它的地方被释放，则为所有段落添加hidden类。如果是在按下它的地方之下被释放的， 删除所有段落的hidden类。*/ var mousedownY $(document).mousedown(function(e)&#123; mousedownY = e.pageY &#125;); $(document).mouseup(function(e)&#123; console.log("mousedownY:"+ mousedownY+","+ e.pageY); if (e.pageY == mousedownY)&#123; $('p').addClass('hidden'); &#125; else if (e.pageY &gt; mousedownY)&#123; $('p').removeClass('hidden') &#125; &#125;); &#125;); 样式和动画 1.position:relative; 相对定位，元素”相对于”它的原始起点进行移动。（相对定位时，无论是否进行移动，元素仍然占据原来的空间。因此，移动元素会导致它覆盖其他框）。2.position:absolute; 绝对定位，位置将依据浏览器左上角开始计算。3.父容器使用相对定位，子元素使用绝对定位后，子元素的位置相对于父容器左上角。4.相对定位和绝对定位需要配合top、right、bottom、left使用来定位具体位置。这四个属性同时只能使用相邻的两个，即上和下，左和右不能同时使用。 code view&amp;课后练习:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114$(document).ready(function() &#123; var $speech = $('div.speech'); var defaultSize = $speech.css('fontSize'); $('#switcher button').click(function() &#123; var num = parseFloat($speech.css('fontSize')); switch (this.id) &#123; case 'switcher-large': num *= 1.4; break; case 'switcher-small': num /= 1.4; break; default: num = parseFloat(defaultSize); &#125; $speech.animate(&#123;fontSize: num + 'px'&#125;, 'slow'); &#125;);//switch button function--larg/small speech var $firstPara = $('p').eq(1); $firstPara.hide(); $('a.more').click(function() &#123; $firstPara.animate(&#123; opacity: 'toggle', height: 'toggle' &#125;, 'slow'); var $link = $(this); if ($link.text() == 'read more') &#123; $link.text('read less'); &#125; else &#123; $link.text('read more'); &#125; return false; &#125;);//展开/隐藏，注意toggle的使用 $('div.label').click(function() &#123; var paraWidth = $('div.speech p').outerWidth(); var $switcher = $(this).parent(); var switcherWidth = $switcher.outerWidth(); $switcher .css(&#123;position: 'relative'&#125;) .fadeTo('fast', 0.5) .animate(&#123; left: paraWidth - switcherWidth &#125;, &#123; duration: 'slow', queue: false &#125;) .fadeTo('slow', 1.0) .slideUp('slow', function() &#123; $switcher.css(&#123;backgroundColor: '#f00'&#125;); &#125;) .slideDown('slow'); &#125;);//多效果并行和队列 $('p').eq(2) .css('border', '1px solid #333') .click(function() &#123; var $clickedItem = $(this); $clickedItem.next().slideDown('slow', function() &#123; $clickedItem.slideUp('slow'); &#125;); &#125;);//回调机制，实现队列效果 $('p').eq(3).css('backgroundColor', '#ccc').hide(); /*1) 修改样式表，一开始先隐藏页面内容，当页面加载后，慢慢地淡入内容*/ $('#container').hide(); $('#container').fadeIn("slow"); /*(2) 在鼠标悬停到段落上面时，给段落应用黄色背景*/ var rgb = $('p').css('backgroundColor'); $('p').hover(function() &#123; $(this).css(&#123;backgroundColor:'#FFFF00'&#125;); &#125;,function()&#123; $(this).css(&#123;backgroundColor:rgb&#125;) &#125;); /*(3)单击标题（&lt;h2&gt;）使其不透明度变为25%，同时添加20px的左外边距，当这两个效果完 成后，把讲话文本变成50%的不透明度；*/ $('h2').click(function() &#123; $(this) .animate(&#123; opacity:0.25, marginLeft: "20px" //左外距 &#125;); $('div.speech p').fadeTo('slow',0.5); &#125;); /*(4)按下方向键时，使样式转换器向相应的方向平滑移动20像素*/ $(document).keyup(function(event) &#123; $('#switcher').css(&#123;position:'relative'&#125;); $switcher = $('#switcher') switch (event.keyCode)&#123; case 37: $switcher.animate(&#123; left:"-=20px" &#125;); break; case 38: $switcher.animate(&#123; top:"-=20px" &#125;); break; case 39: $switcher.animate(&#123; left:"+=20px" &#125;); break; case 40: $switcher.animate(&#123; top:"+=20px" &#125;); break; default: break; &#125; &#125;); &#125;); DOM操作 code view和练习：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970$(document).ready(function () &#123; // Use attr() to add an id, rel, and title. $('div.chapter a[href*="wikipedia"]').attr(&#123; rel : 'external', title : function () &#123; return 'Learn more about ' + $(this).text() + ' at Wikipedia.'; &#125;, id : function (index, oldValue) &#123; return 'wikilink-' + index; &#125; &#125;); // Add "back to top" links. //(1) 修改添加back to top链接的代码，以便这些链接只从第四段后面才开始出现 $('&lt;a href="#top"&gt;back to top&lt;/a&gt;').insertAfter('div.chapter p:gt(2)'); $('&lt;a id="top"&gt;&lt;/a&gt;').prependTo('body'); //(2) 在单击back to top链接时，为每个链接后面添加一个新段落，其中包含You were here字样。确保链接仍然有效。 $('.chapter a[href*="top"]').click(function () &#123; $('&lt;p&gt;you were here&lt;/p&gt;').insertAfter($(this)); &#125;); //(3) 在单击作者名字时，把文本改为粗体（通过添加一个标签，而不是操作类或CSS属性）。 //(4) 在随后单击粗体作者名字时，删除之前添加的&lt;b&gt;元素（也就是在粗体文本与正常文本之间切换）。 $('#f-author').click(function () &#123; if ($(this).parent().is('b')) &#123; $(this).unwrap('111'); &#125; else &#123; $(this).wrap('&lt;b&gt;&lt;/b&gt;'); &#125; &#125;); //(5) 为正文中的每个段落添加一个inhabitants类，但不能调用.addClass()方法。确保不影响现有的类。 $('div.chapter p').wrapInner('&lt;div class="inhabitants"&gt;&lt;/div&gt;'); // Create footnotes. var $notes = $('&lt;ol id="notes"&gt;&lt;/ol&gt;').insertBefore('#footer'); //fooer之前创建插入有序列表 $('span.footnote').each(function (index) &#123; //遍历脚注，使用each的回调函数处理 $(this) .before([ '&lt;a href="#footnote-', index + 1, '" id="context-', index + 1, '" class="context"&gt;', '&lt;sup&gt;', index + 1, '&lt;/sup&gt;&lt;/a&gt;' ].join('')) //创建了一个包含指向脚注的链接和脚注编号的&lt;sup&gt;元素，insertBefore反向插入正文， .appendTo($notes) //将footnote加入到脚注 .append([ ' (&lt;a href="#context-', index + 1, '"&gt;context&lt;/a&gt;)' ].join('')) //创建指向上文脚注标签 .wrap('&lt;li id="footnote-' + (index + 1) + '"&gt;&lt;/li&gt;'); //warp 将匹配元素包裹在元素或内容中 &#125;); // Style pull quotes. $('span.pull-quote').each(function (index) &#123; var $parentParagraph = $(this).parent('p'); $parentParagraph.css('position', 'relative'); //设置css样式相对定位 var $clonedCopy = $(this).clone(); //复制 $clonedCopy .addClass('pulled') .find('span.drop') .html('…') //修改 .end() .text($clonedCopy.text()) //将text内容存文本化 .prependTo($parentParagraph); &#125;); &#125;); AJAX code view和练习123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195$(document).ready(function () &#123; $('#letter-a a').click(function (event) &#123; event.preventDefault(); $.ajaxSetup(&#123; url : 'a.html', type : 'POST', dataType : 'html' &#125;); $.ajax(&#123; type : 'GET', success : function (data) &#123; $('#dictionary').html(data); &#125; &#125;); &#125;); $('#letter-b a').click(function (event) &#123; event.preventDefault(); $.getJSON('b.json', function (data) &#123; var html = ''; $.each(data, function (entryIndex, entry) &#123; html += '&lt;div class="entry"&gt;'; html += '&lt;h3 class="term"&gt;' + entry.term + '&lt;/h3&gt;'; html += '&lt;div class="part"&gt;' + entry.part + '&lt;/div&gt;'; html += '&lt;div class="definition"&gt;'; html += entry.definition; if (entry.quote) &#123; html += '&lt;div class="quote"&gt;'; $.each(entry.quote, function (lineIndex, line) &#123; html += '&lt;div class="quote-line"&gt;' + line + '&lt;/div&gt;'; &#125;); if (entry.author) &#123; html += '&lt;div class="quote-author"&gt;' + entry.author + '&lt;/div&gt;'; &#125; html += '&lt;/div&gt;'; &#125; html += '&lt;/div&gt;'; html += '&lt;/div&gt;'; &#125;); $('#dictionary').html(html); &#125;); &#125;); $('#letter-c a').click(function (event) &#123; event.preventDefault(); $.getScript('c.js'); &#125;); $('#letter-d a').click(function (event) &#123; event.preventDefault(); $.get('d.xml', function (data) &#123; $('#dictionary').empty(); $(data).find('entry').each(function () &#123; var $entry = $(this); var html = '&lt;div class="entry"&gt;'; html += '&lt;h3 class="term"&gt;' + $entry.attr('term'); html += '&lt;/h3&gt;'; html += '&lt;div class="part"&gt;' + $entry.attr('part'); html += '&lt;/div&gt;'; html += '&lt;div class="definition"&gt;'; html += $entry.find('definition').text(); var $quote = $entry.find('quote'); if ($quote.length) &#123; html += '&lt;div class="quote"&gt;'; $quote.find('line').each(function () &#123; html += '&lt;div class="quote-line"&gt;'; html += $(this).text() + '&lt;/div&gt;'; &#125;); if ($quote.attr('author')) &#123; html += '&lt;div class="quote-author"&gt;'; html += $quote.attr('author') + '&lt;/div&gt;'; &#125; html += '&lt;/div&gt;'; &#125; html += '&lt;/div&gt;'; html += '&lt;/div&gt;'; $('#dictionary').append($(html)); &#125;); &#125;); &#125;); $('#letter-e a').click(function (event) &#123; event.preventDefault(); var requestData = &#123; term : $(this).text() &#125;; $.get('e.php', requestData, function (data) &#123; $('#dictionary').html(data); &#125;).fail(function (jqXHR) &#123; $('#dictionary') .html('Sorry, but an error occurred: ' + jqXHR.status) .append(jqXHR.responseText); &#125;); &#125;); $('#letter-f form').submit(function (event) &#123; event.preventDefault(); var formValues = $(this).serialize(); $.get('f.php', formValues, function (data) &#123; $('#dictionary').html(data); &#125;); &#125;); var url = 'http://examples.learningjquery.com/jsonp/g.php'; $('#letter-g a').click(function (event) &#123; event.preventDefault(); $.getJSON(url + '?callback=?', function (data) &#123; var html = ''; $.each(data, function (entryIndex, entry) &#123; html += '&lt;div class="entry"&gt;'; html += '&lt;h3 class="term"&gt;' + entry.term + '&lt;/h3&gt;'; html += '&lt;div class="part"&gt;' + entry.part + '&lt;/div&gt;'; html += '&lt;div class="definition"&gt;'; html += entry.definition; if (entry.quote) &#123; html += '&lt;div class="quote"&gt;'; $.each(entry.quote, function (lineIndex, line) &#123; html += '&lt;div class="quote-line"&gt;' + line + '&lt;/div&gt;'; &#125;); if (entry.author) &#123; html += '&lt;div class="quote-author"&gt;' + entry.author + '&lt;/div&gt;'; &#125; html += '&lt;/div&gt;'; &#125; html += '&lt;/div&gt;'; html += '&lt;/div&gt;'; &#125;); $('#dictionary').html(html); &#125;); &#125;); $('#letter-h a').click(function (event) &#123; event.preventDefault(); $('#dictionary').load('h.html .entry'); &#125;); var $loading = $('&lt;div id="loading"&gt;Loading...&lt;/div&gt;') .insertBefore('#dictionary'); $(document).ajaxStart(function () &#123; $loading.show(); &#125;).ajaxStop(function () &#123; $loading.hide(); &#125;); $('body').on('click', 'h3.term', function () &#123; $(this).siblings('.definition').slideToggle(); &#125;); //(1) 页面加载后，把exercises-content.html的主体（body）内容提取到页面的内容区域 $('#dictionary').load('exercises-content.html'); //(2)请为左侧的字母列表创建“提示条”，当用户鼠标放到字母上时，从exercises-content.html中加载与该字母有关的内容。 //(3) 为页面加载添加错误处理功能，在页面的内容区显示错误消息。修改脚本，请求does-notexist.html而不是exercises-content.html，以测试错误处理功能。 $('.letter').mouseenter(function (e) &#123; e.preventDefault(); $('#dictionary').load('exercises-content.html #' + this.id, function (response, status, jqXHR) &#123; if (status == 'error') &#123; $('#dictionary') .html('An error occurred: ' + jqXHR.status) .append(jqXHR.responseText); &#125; &#125;); &#125;).mouseleave(function () &#123; $('#dictionary').html(''); &#125;); /* $('.letter').mouseenter(function (e) &#123; $('#dictionary') .load('does-not-exist.html #' + this.id); &#125;) .fail(function (jqXHR) &#123; $('#dictionary') .html('sorry An error occurred: ' + jqXHR.status) .append(jqXHR.responseText); &#125;) */ /*(4) 页面加载后，向GitHub发送一个JSONP请求，取得某个用户代码库的列表。把每 个代码库的名称和URL插入到页面的内容区。取得jQuery项目代码库的URL是https://api. github.com/users/jquery/repos。 githubUrl = 'https://api.github.com/users/jquery/repos' $.getJSON(githubUrl + '?callback=?', function (data) &#123; var html = ''; $.each(data, function (entryIndex, entry) &#123; $.each(entry, function (itemIndex, item) &#123; html += '&lt;div class="entry"&gt;'; html += '&lt;div class="name"&gt;' + item.name + '&lt;/div&gt;'; &#125; &#125;); &#125;); */ &#125;);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[邮件管理,outlook的邮箱设置]]></title>
      <url>http://www.lizorn.com//2016/03/10/email_management/</url>
      <content type="text"><![CDATA[性格决定了命运，你的努力，选择，耐心都可能影响你的一生，如何为人处世是个大命题，这里不扯这些，仅聊一聊专注力的事情，如何屏蔽干扰。现在育儿都很注重一点，就是专注力。我女儿在认真玩耍的时候，有人尝试去逗她玩，我都会及时阻止， 这个时候你去打扰她会影响她的专注力 这还包括成年人，当今社会信息和诱惑都非常的多，人的想法也时时刻刻都在发生改变，生活的琐事也随着经历的增长而增长，专注于一件事情会越来越难。 在大部分企业办公,电子邮件是最大的干扰之一，如何有效控制电子邮件的使用，整合大量的碎片时间？ 关闭电子邮件通知功能人脑并不擅长并发处理，左右互搏不是人人都会的，一次性专注批量的处理事情会大大提高效率。特别是像我这种有强迫症的人，如果电子邮件弹框通知，我随时都会打开查看，如果电子邮件过多，整一天会让我不厌其烦。 需要关闭电子邮件通知，outlook options-&gt;mail-&gt;Message arrival,关闭桌面通知和声音提示。 定期批量的处理邮件每隔一个小时，或者一天4次，批量专注的处理你的邮件。 保持即时通信工具的畅通，然后定期的查看电子邮件，变相的告诉对方，如果有急事，可以通过即时工具联系，提高沟通效率。 处理邮件后将邮件归档归档阅读完一份邮件第一件事情 处理完毕后，将其归档 To do,设置标记后，将其归档 分类创建分类文件夹，如： 1234567events：公司的一些通告/事件等垃圾邮件 customer:领导，需求，VPM等 members：组内成员 projects:项目分类 todo:代办的事情，通常是客户/考勤异常/manpower等等 bug:issue追踪 RES:一些资源 创建规则，移动或阻止邮件,保持inbox内的邮件数量：右击邮件-&gt;Rules-&gt;移动到各个文件夹下。 其他设置拼音检查 Outlook settings-&gt;Mail-&gt;ABC 勾上拼音检查 设置回执功能(若对方是预览打开，则无回执) Outlook settings-&gt;Mail-&gt;ABC 勾上read receipt confirming 签名： Outlook settings-&gt;Mail-&gt; 创建签名，如： 1234Best Regards!姓名/公司/部门Office: 联系电话/短号其他联系工具]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[FusionCharts Suite XT去水印]]></title>
      <url>http://www.lizorn.com//2016/03/10/fusioncharts_cracker/</url>
      <content type="text"><![CDATA[闲来无事，挖掘了下单位的测试数据，分析生成pareto，用于持续改进,发现Fusioncharts有现成的模块可以用，向来不想重复造轮子，下载开袋即食，见有水印，遂去之，再此奉上。 拿来主义点此 授人以鱼不如授人以渔。 打开fusioncharts.js 搜索fusioncharts.com -&gt; 12&lt;span style="white-space:pre"&gt;&lt;/span&gt;Q="http://www.fusioncharts.com?BS=FCHSEvalMark&amp;utm_source=FCS_trial&amp;pver="+m.escape(d.core.version) 置空-&gt;Q=”” 搜索Trial-&gt; 12&lt;span style="white-space:pre"&gt;&lt;/span&gt;CREDIT_STRING:"FusionCharts XT Trial" 置空-&gt;CREDIT_STRING:””]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[宴山亭·北行见杏花]]></title>
      <url>http://www.lizorn.com//2016/03/10/songci-1/</url>
      <content type="text"><![CDATA[【原文】《宴山亭·北行见杏花》 作者：宋徽宗(赵佶) 裁剪冰绡，轻叠数重，淡著胭脂匀注。新样靓妆，艳溢香融，羞杀蕊珠宫女。易得凋零，更多少无情风雨。愁苦。问院落凄凉，几番春暮。 凭寄离恨重重，这双燕，何曾会人言语。天遥地远，万水千山，知他故宫何处。怎不思量，除梦里有时曾去。无据。和梦也新来不做。 【注释】 宴山亭：词牌名。“宴”通“燕”。 冰绡：洁白如冰的丝织品，绡（xiāo）：生丝。 生丝织物：～头（古代束发的头巾）。冰销，洁白的绸。此处比喻杏花的花瓣。 靓（jìng、liàng）妆：妆饰艳丽。 （古代靓字读jìng） 蕊珠宫：道教传说中的仙宫。 凭寄：凭谁寄，托谁寄。 者：同这 会：理解，懂得。 无据：不可靠。 和：连。 【作品简介】 《宴山亭·北行见杏花》由宋徽宗(赵佶)创作，被选入《宋词三百首》。《宴山亭》这首词曾被王国维称为“血书”。这首词是赵佶被人掳掠北去途中，见杏花而怀念故国的伤怀之作。开头描绘杏花的形态色彩，接着以杏花的美丽妆饰与天上宫女对比，透过此花，人们能看到曾为帝王、现为囚徒的作者及今日的后宫佳丽憔悴飘零的落魄之态。下阕由上阕写杏花转为写人。题意是“北上见杏花”，并非专咏物，所以“凭寄离恨重重”承上启下。“离恨”为点睛之笔。借对梦的期待，委婉表达，此刻的作者伤心到连梦也不做了！相思极苦，衷情哽咽，令人不忍多听。 【翻译】 剪裁好白色的丝绸，轻轻叠成数层，又将淡淡的胭脂均匀的涂抹，时髦的漂亮衣服，艳丽的色彩融入四溢的清香，简直羞杀了天上的蕊珠宫女。红颜易凋零，更何况，经历了多少无情的风雨 ，面对愁苦的情景，扣问凄凉的院落，还要经受几番春暮。 谁帮我寄去重重的离愁，这双飞的燕子哪里懂得人间的苦痛。天遥地迵，万水千山阻隔，哪里知道故园今在何处？只有在梦中有时曾去。就连梦也难做成，因我痛苦的彻夜难眠。 【赏析】 此词为北宋徽宗皇帝在1127年覆国被掳往北方五国城，北行途中见杏花而托物兴感而作。上片摹写杏花以寄意。“裁剪”三句写杏花之花质冰洁如白绸剪裁剪，花瓣簇绽轻柔重叠，花色淡雅似胭脂匀染。“新样”三句以拟人手法将杏花比喻为“靓妆”新颖，艳香流融的美女，直令天界蕊珠宫仙女为之羞惭汗颜。“易得凋零”，笔势陡转，写尽杏花遭受风雨摧折之凄凉愁苦。下片由感叹杏花凋落，转入自掳离恨。双燕不解人语，故宫天遥地远，怀乡思国，只有求之梦寐，如今梦亦不成，凄楚之至。借杏花之凋落，伤江山之陆沉；以归梦之难成，寓复国之绝望。全词托物咏怀，抒写故国沦亡之悲慨，幽咽委曲，伤感无奈，对故国沦亡一句悔恨与反思，又显见其情虽真而骨力乏弱。 【作者介绍】 宋徽宗，名赵佶（公元108211月2日～1135年6月4日），神宗11子，哲宗弟，是宋朝第八位皇帝。赵佶先后被封为遂宁王、端王。哲宗于公元1100年正月病死时无子，向皇后于同月立他为帝。第二年改年号为“建中靖国”。宋徽宗在位25年（1100年2月23日—1126年1月18日），国亡被俘受折磨而死，终年54岁，葬于永佑陵（今浙江省绍兴县东南35里处）。 他自创一种书法字体被后人称之为“瘦金书”，另外，他在书画上的花押是一个类似拉长了的“天”字，据说象征“天下一人”。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Ubuntu的爱]]></title>
      <url>http://www.lizorn.com//2016/03/06/ubuntu_env/</url>
      <content type="text"><![CDATA[今年听闻ubuntu要发布16 LTS，于是win10弃坑，兜兜转转还是再次用回了自由的ubuntu系统，环境记录下。几个ide在ubuntu依然是不尽人意的，要解放鼠标还是得定制，得折腾，最终还不如使用mac或者emacs/vim等。 基础设置设置快捷键 System Settings -&gt; Keyboard -&gt; Shortcuts -&gt; Launcher -&gt; Launcher terminal，设成Super(Win) + R. 设置字体 System Settings——》Universal Access——》Large Text——》on 输入法方式1. 自带的ibus中文输入不是很好用，使用搜狗输入法：http://pinyin.sogou.com/linux/在Language Support将输入法系统切换到fcitx，在text entry中隐藏掉ibus界面。 方式2. emacs /etc/apt/sources.list.d/ubuntukylin.list文件，加入ubuntu kylin的apt源 123deb http://archive.ubuntukylin.com:10006/ubuntukylin trusty mainsudo apt-get updatesudo apt-get install sogoupinyin 浏览器wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb 安装迅雷：XwareDesktop 压缩工具sudo apt-get install unrar 安装jdk1234sudo add-apt-repository ppa:webupd8team/javasudo apt-get update sudo apt-get install oracle-java8-installersudo update-alternatives --config java 安装CMakersudo apt-get install cmake qtcreator pythonalternatives机制实现python2和pyhton3的共享和切换 123sudo apt-get install python3-pipsudo update-alternatives --install /usr/bin/python python /usr/bin/python2 100sudo update-alternatives --install /usr/bin/python python /usr/bin/python3 150 默认使用python3可能会导致ubuntu软件中心异常，此时需要切换到python2. 其他ruby etc. 1234sudo apt-get install ruby rakegem sources --remove https://rubygems.org/gem sources -a http://ruby.taobao.org/gem install jekyll rdiscount IDE现在编译器之多，眼花缭乱，曾几何时一直都是捧着source insight，一做就是6年，呜呼哀哉. emacssudo apt-get install emacs24配置 sublime text涉猎的语言太多(c/c++/java/python/php/ruby/javascript/c#/swift/lisp etc.)，实施的机会又越来越少.痛定思痛，决定梳理专精一门。 安装123sudo add-apt-repository ppa:webupd8team/sublime-text-3 sudo apt-get update sudo apt-get install sublime-text 配置 package control.安装包管理器，view-&gt;show console执行以下代码. 1import urllib2,os;pf='Package Control.sublime-package';ipp=sublime.installed_packages_path();os.makedirs(ipp) if not os.path.exists(ipp) else None;open(os.path.join(ipp,pf),'wb').write(urllib2.urlopen('http://sublime.wbond.net/'+pf.replace(' ','%20')).read()) 以下的插件均用ctrl+shift+p安装。 SublimeREPL SideBarEnhancements 扩展了侧边栏中菜单选项的数量，从而提升你的工作效率 Anaconda Anaconda 是一个终极 Python 插件。它为 ST3 增添了多项 IDE 类似的功能，例如： Autocompletion 自动完成，该选项默认开启，同时提供多种配置选项。Code linting 使用支持 pep8 标准的 PyLint 或者 PyFlakes。因为我个人使用的是另外的 linting 工具，所以我会在 Anaconda 的配置文件 Anaconda.sublime-settings 中将 linting 完全禁用。操作如下: Sublime &gt; Preferences &gt; Package Settings &gt; Anaconda &gt; Settings – User： {“anaconda_linting”: false} McCabe code complexity checker 让你可以在特定的文件中使用 软件复杂度检查. Goto Definitions 能够在你的整个工程中查找并且显示任意一个变量，函数，或者类的定义。 Find Usage 能够快速的查找某个变量，函数或者类在某个特定文件中的什么地方被使用了。 Show Documentation： 能够显示一个函数或者类的说明性字符串 Djaneiro Django. SublimeLinter 代码静态检查工具框架(linter),对于 Python 的代码静态检查器，我使用 SublimeLinter-pep8。其他还有SublimeLinter-jshint, SublimeLinter-pyyaml, SublimeLinter-csslint，SublimeLinter-html-tidy，以及 SublimeLinter-json。 PEP8 Autoformat 按PEP8自动格式化代码的。快捷键 CTRL+SHIFT+R 自动格式化python代码.常用配置 1234567891011121314151617&#123; &quot;auto_complete&quot;: false, &quot;caret_style&quot;: &quot;solid&quot;, &quot;ensure_newline_at_eof_on_save&quot;: true, &quot;find_selected_text&quot;: true, &quot;font_size&quot;: 11.0, &quot;highlight_modified_tabs&quot;: true, &quot;line_padding_bottom&quot;: 0, &quot;line_padding_top&quot;: 0, &quot;scroll_past_end&quot;: false, &quot;show_minimap&quot;: false, &quot;tab_size&quot;: 4, &quot;translate_tabs_to_spaces&quot;: true, &quot;trim_trailing_white_space_on_save&quot;: true, &quot;wide_caret&quot;: true, &quot;word_wrap&quot;: true,&#125; GitGutter Emmet 大名鼎鼎的Emmet Markdown Preview markdown 预览 atom下载, github血统，偶尔用来写markdown(shift + ctrl + m) pycharm下载，python全栈ide.注册时选择 License server, 填写http://idea.lanyus.com]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[人月神话]]></title>
      <url>http://www.lizorn.com//2016/03/06/the-mythical-man-month/</url>
      <content type="text"><![CDATA[编程行业满足我们内心深处的创造渴望和愉悦 编程乐趣 创建事物的快乐 开发他人有用的东西的快乐 组装的快乐 面对不重复的任务，不断学习的快乐 工作在具体物质介质上的快乐 编程的苦恼 追求完美，然而却无法完美 良好的烹饪需要时间，某些任务无法在不损坏结果的情况下加快速度 编程人员都比较乐观，‘一切都会好起来’，所以职责需要分开 bug是避免不了的 工作量和项目进度无法太清晰 沟通成本是经常被忽略的东西 1/3计划，1/6编码，1/4构建测试，1/4集成测试 软件开发没有银弹，过于复杂无法数据估计 码农何去何从？]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[国家为什么会失败]]></title>
      <url>http://www.lizorn.com//2016/03/04/why_nations_fail/</url>
      <content type="text"><![CDATA[该书列举了几个实例，反驳了国家为什么会失败的几个假说，通过对历史的层层剖析，道出了自己的命题：制度是国家为什么会失败的主要原因。 假说地理假说 目前比较贫穷的国家集中在非洲，然而根据历史表明，这些地区的国家也曾富裕过，气候并不是决定国家失败的原因。 热带疾病是造成许多非常人饱受病痛之苦，但它们不是非洲贫穷的原因，而是贫穷的结果。 动物和植物物种可能性的差异制造了农业发展程度的差异，导致不同大陆间的技术发展与富裕程 文化血统假说 宗教改革和信仰，价值和伦理是驱动国家贫富的关键。 优秀的欧洲文化传承也许就是富裕的根源。然则，无法解释阿根廷和乌拉圭欧裔很多但依然不富裕的事实。 北纬38°假说北韩和南韩差距巨大，从文化，地理，无知角度都无法解释，我们必须从制度上去寻求答案。 制度经济制度广纳式需要安全的财产权和经济机会，不只是给菁英，也要开放给社会的各领域。 榨取式这类制度的设计是为了向社会的一部分人榨取收入和财富，以使另一部分人获利。榨取式经济制度发展受限原因： 缺乏创造性破坏和创新 不只制造出更低的效率，还往往反转既有的政治集权，有时候甚至导致治安完全崩溃而陷于混乱 罗马帝国衰亡：从共和到元首制，及至后来到帝国的转变，原本具有部分广纳性的政治制度曾是经济成功的基石，播下了衰亡的种子。 政治制度经济制度对决定国家的贫穷或富裕极其重要，而决定国家经济制度的是政治和政治制度。 足够集中化和多元化的政治制度称为广纳式政治制度.如果这两种条件有任何一种付之阙如，我们会把这套制度称为榨取式政治制度。 容许自由的媒体繁荣发展，但回过头来，自由的媒体也比较能够让有害于广纳式制度的威胁曝光并广为人知，促使社会对之采取抗拒行动。相对地，在榨取式政治制度、专制政权或独裁统治下，这类的自由根本就不可能，因为它们动辄压制反对力量的形成。 广纳式经济制度强化财产权，打造公平的游戏平台，鼓励新科技与新技术的投资，助长经济成长，不像榨取式经济制度则是少数人榨取多数人资源的体系，既无法保障财产权，也不为经济活动提供诱因。 广纳式经济制度与广纳式政治制度互相支持。 在政治权力分配上， 广纳式政治制度倾向于多元，且能达到某种程度的政治集权，并以此建立法治，为财产权及广纳式市场经济奠定基础。同样的，榨取式经济制度与榨取式政治制度也是互相支援。在权力分配上，榨取式政治制度将权力集中于少数人手中，这些人因此有动机为谋取私利维持和发展榨取式经济制度，并运用所得的资源巩固自己的政治权力 “要维持党在改革中的领导地位，有三个原则必须把握：党要控制军队；党要控制党员；党要控制新闻。”]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[创业维艰]]></title>
      <url>http://www.lizorn.com//2016/02/24/the_hard_thing_about_hard_things/</url>
      <content type="text"><![CDATA[此书使我对CEO的角色有了更深入的了解，多年从事技术领域，所接触的问题都比较单纯，而CEO要面临的问题和挑战，更艰难和复杂得多。此书也使我对创业有了初步的认识：苦逼，挑战，挣扎，life is struggle。 以下是本书的笔记，纪录的非常片面，还是自己去看书吧。 挣扎之苦 不要扛下所有的责任。适当的放权，责任下放，可以提高参与感，提高团队的凝聚力。 只要坚持下去，总有转机。 不要过分苛责自己。正确评估自己，过分苛责自己于事无补。 要实话实说，对公司出现的问题做透明化处理很重要，涉及到以下三点原因。 信任。没有了信任，沟通就断了 参与解决问题的人越多越好。 健康的企业文化就像过去的路由信息协议：好事不出门，坏事传千里 人人都是产品经理 产品经理及其了解市场，产品，生产线和竞争情况，凭借自己丰富的经验和充分的自信开展工作 对目标有清晰的定义，即“目标是什么”，并能有效实施这一目标。 好：重要问题以书面形式记录下来（竞争中的良策，艰难的架构选择，艰难的产品决策，攻占或放弃的市场） 差：以口头形式表达自己的意见，抱怨“当权者”不允许他这样做。 好的产品经理考虑向市场推出超值产品，在产品进入市场期间，他们会考虑实现市场占有率和收益目标。 人才是重中之重，招聘是人才的第一步，有几个面试题可以参考： 你上班的第一个月会干什么？ 你觉得这份工作和你目前工作有什么不同？ 你为什么要加入我们小公司？ 债务管理债务： 一山藏二虎。 可能会存在多头管理 两人背负责任等于是卸掉了虎责任 因某一员工得到另一工作机会而对其补偿过度。 缺乏绩效管理机制或员工反馈机制。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[决战大数据]]></title>
      <url>http://www.lizorn.com//2016/02/15/big_data/</url>
      <content type="text"><![CDATA[多算胜，少算不胜，而况于无算乎迂回前进，在运营数据中衡量每一个变动，并通过变动的结论来调整自己的下一个迂回动作。 人人都是数据分析师做好个人的大数据管理： 从小处着眼积累知识 对知识进行标签化管理 让数据的收集变得简单，即时收集。 建立用户的标签：简单的说就是通过数据的分析来对用户的偏好进行描述 建立标签 通过业务规则结合数据分析来建立标签： 通过模型来建立标签。 多个模型组合建立标签。 标签的应用 标签的使用，最核心的是数据中间层和前台业务层的对接： 中间层和业务层的对接。 中间层的易用性。 如何用框架来做决策：数据抽空场景没有任何的意义，数据分析需要和具体场景相结合。 首先确定有什么问题，从解决问题的角度去收集数据，挖掘数据。 把收集到的数据整理好，放入“数据框架”（场景）内,清楚的看到数据与决策之间的关系。 看框架与做决策的关系 数据分类的4大维度 数据再生角度，分为可再生和不可再生数据 按照数据所处的存储层次来看，可分为基础层，中间层和应用层。 按照数据业务归属来看，可以分为各个数据主体（数据仓库）。 按照是否隐私来区分，可以分为隐私数据和非隐私数据。 数据的5大价值能辨别关系，身份的数据是最重要的。在大数据时代，越能够还原用户真是身份和真是行为的数据就越能够让企业在大数据竞争中保持战略优势。 识别与串联价值，唯一能够锁定你目标的数据。 描述价值。 时间价值。 预测价值。 产生数据的价值。 tips 针对性：收集数据要有针对性，最终要为解决某个问题而服务，盲目的收集数据并没有什么用。 养数据：养数据是一种数据战略，是基于深入业务理解的更高层次的商业决策。数据具有成长性，要避免刻舟求剑的场景。 场景与还原并行:前端还原消费者场景，后端还原业务需求 关联性：一个单独的数据是没有意义的，要把数据放在“数据框架”中让数据场景化，才能看出存在的问题，进入做出决策。 存：收集数据不是目的，让收集起来的数据如何产生价值才是最终的目的；管：用数据产品来解决获取及使用数据的问题；用：诗句的分裂和重组，都能做到颠覆性创新； 电商行业成交额指标： 日均UV,浏览转化率（UV到达商品详细页面的转化率），购买转化率（到达商品详细页面的用户到购买商品的页面），比单价（平均每一笔的金额），人均笔数]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Data Crush]]></title>
      <url>http://www.lizorn.com//2016/02/15/data_crush/</url>
      <content type="text"><![CDATA[Data Crush: How the Information Tidal Wave is Driv看完后收获不少 大数据在推动在线数据的增长： 移动性：智能手机和平板电脑会随时随地将人们联系在一起； 虚拟生活：人们会通过互联网加强与朋友和家人之间的互动； 数字商业：购买在线产品和服务的无线选择 在线娱乐：数亿个娱乐渠道和数白万个游戏供选择和娱乐 云计算：将你所有的信息在线化 大数据：在线活动产生的大量数据 商业领导人需要遵循的六大原则： 让一切移动起来：重新定义流程和自动化，充分利用移动和流动劳动力 流程数字化：推行无纸化办公，让流程自动化 业务社交化：推行社交技术和业务流程整合在一起 信息管理自动化：重视自动化管理和运作 挖掘大内容：挖掘大量非结构化的数据，产生新的商业价值 云技术：拆分整体企业运营为单个小型应用 场景化成熟度模型： 0级—没有场景化，匿名交易了，现金支付。企业不知道消费者的具体信息。 1级—消费者使用卡（信用卡，借记卡，会员卡）支付。企业可以了解消费者的场景，不过通常是在对方购买商品之后。 2级—企业有了场景化意识。企业知道消费者在什么时候出现在什么地方，企业能掌握时间和地点数据，这些数据对零售区位的选择非常重要。 3级—企业有了消费者场景模式，能根据消费者的行为进行预测 4级—企业对消费者的习惯有了足够的了解，能根据其社交化媒体数据预测其生活 5级—企业和消费者形成良好的关系，消费者持续购买企业产品，企业和消费者在社交上先行并对消费者造成一定的影响。 社会化成熟度模型： 0级—一无所知 1级—企业可以通过消费者使用会员卡和信用卡的情况，以及消费者在社交网站上为企业点赞等行为记录下他的习惯和喜好。 2级—企业能够对消费者的行为做回应。如企业搜索社交网站上对企业的评价并做出回应。 3级—企业开始主动和消费者建立联系。企业定向追踪消费者在社交化媒体上的行为，形成对消费者的喜好和观点的了解，然后定向推送营销信息，重塑消费者的评价，维护企业和产品的形象。 4级—企业根据消费者的社交化信息进行预见性的营销。 5级—企业和消费者交互增加，创造一种和消费者的共生关系，持续维护和提高企业的品牌知名度和忠诚度。 量化成熟度模型：量化成熟度可以用来判断企业的商业流程结构是否良好，以及是否能够被消费者理解，企业也可以此来判断业务是否适合外包。 应用化成熟度模型： 0级—没有APP. 1级—信息推送。 2级—内容定位，用户定制和选择。 3级—用户参与商业流程，互动更全面。 4级—场景化意识。 5级—既有社交意识，又能根据用户的喜好，人际关系和其他社交标准来运作。 大数据和物联网一样不是一蹴而就，它必然需要经历一个大集成的过程，会有各方利益间的博弈，但相信它就在不远将来。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[2016年书单]]></title>
      <url>http://www.lizorn.com//2016/01/05/book-list/</url>
      <content type="text"><![CDATA[罗列了下今年的书单，部分是家里的藏书，虽喜欢纸质书，但有时翻看确实不如电子书方便。 kindle paperwhite2已被老婆占用了，没想到她看书的兴致也挺高毕竟影视作品是无法替代文字的魅力的。于是又入了个paperwhite3，希望新的一年多抽出时间来看书。 今年对历史和人文比较感兴趣，由于工作需要，仍然需要关注下互联网方面的书籍，参杂一些推理小说和时下的畅销书就当调剂下。书评我是不愿多写的，也可尝试下。 人性中的善良天使一部人类心理进化史，开创性地运用了最前沿的心智理论研究人类历史，以震撼人心的方式剖析促发暴力的人类心理的内外因素。本书的结论必然会引起争论，但这只是一个开端，它将引导我们用全新的角度看人性、看历史、看世界，让我们深思人类社会的未来命运。 国家为什么会失败 为什么有的国家富裕，有的却贫穷？本书用15年的原创性研究，阐释一个跟现代社会高度相关的新政治经济学理论，直面这个旷世难题。 通读了下略有感触,必然会再去读第二遍。 罗马帝国衰亡史 此书太厚，不一定能看完 乌合之众 之前看过几本心理学类的著作，如自私的基因等，也许是自己功力不够并未引起多少共鸣。此本书也看完了，还是感觉学术性稍重了些，论证过少，但还算简洁，对群体有很好的概括，有几个观点显得比较极端，不过个人比较认同： 任何一个人都比“人民群众”更聪明，所以“人民群众”是靠不住的。 任何一个群体更像是一个原始人的乌合之众！ 妇孺言论不可轻信。 群体杜撰历史。 群体的叠加只能增加愚蠢，不存在丝毫智力优势。 群体埋葬了所有的怀疑精神与独立意识，他们只臣服于激烈的言辞，虚假的形象。 群体没有推理能力，只会喊口号以号召起头脑风暴。 偶像崇拜不会消亡，因为群体需要宗教。 任何一桩惨案，总是群众所为。 UNIX编程艺术 KISS的精髓:keep it simple and stupid.不管是编码，设计，还是生活上都应该有这种思想。 Unix系统领域中的设计和开发哲学、思想文化体系、原则与经验，由公认的Unix编程大师、开源运动领袖人物之一Eric S. Raymond倾力多年写作而成。包括Unix设计者在内的多位领域专家也为本书贡献了宝贵的内容。本书内容涉及社群文化、软件开发设计与实现，覆盖面广、内容深邃，完全展现了作者极其深厚的经验积累和领域智慧。 硅谷之谜 看完吴军的浪潮之巅，对我这种刚开始弄潮的人来说有较大的启发。 失控 谷歌是如何运营的 家里有本英文版的纸质书，一直垫在床头未曾翻看，现在中文版也出来了，惭愧惭愧。 已读, 我认为,谷歌之所以能不断的聚集精英为其服务,可以实行扁平化管理,需要企业文化的支撑,也是以太效应的作用结果,不是什么企业都可以模仿的. 创业维坚 笔记在此 S 统计数字会撒谎 通熟易懂,幽默风趣,实例也比较多,推荐一读.笔记在此 Data Crush: How the Information Tidal Wave is Driv 看完后收获不少Data Crush读书笔记 决战大数据 多算胜，少算不胜，而况于无算乎 决战大数据读书笔记]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[禅]]></title>
      <url>http://www.lizorn.com//2016/01/05/chan/</url>
      <content type="text"><![CDATA[当你忘了自己的过去，满意自己的现在，漠视自己的未来，你就站在了生活的最高处 有的人一生也无法到达那个高度。生活与人，不同的人有不同的感悟，相同的人不在不同的阶段也有不同的看法。别人的经验是学不来的，一个人的一生不是规划出来的，生活也不是从别人的故事里讲出来的。 心 竹密岂妨流水过，山高哪阻野云飞 禅者因解脱而自在，而豁达，而空灵，我自认是达不到的，但我可以从认识自我做起，完成几个目标，坚持写几篇博客。 给自己建立一个档案。如blog/个人站，便于更好的认识和总结自己，也有利于技能和经验的积累 登高必自卑，行远必自迩。 列一个目标清单。凡是皆是一步一步完成的,制定大目标,大目标引领自己,将大目标分解为小目标,小目标激励自己 执行 睡觉的时候睡觉，吃饭的时候吃饭. 少说多做，宁要一个开始，也不要千万个梦想，想中彩票得先买一注彩票,如何提高执行力？ 推迟满足感写完作业再玩 自我奖励和激励适当的自我奖励 自律睡觉的时候睡觉，吃饭的时候吃饭 专注 外离相为禅，内不乱为定。外若着相，内心即乱；外若离相，心即不乱。 修行禅定的能力，处在任何时间不被外事干扰。认真做一件事情，不打妄想，扔掉手机，关掉网络，一次专注做一件事情。 宁要一个完成，不要千万个开始: 人脑擅长单线程处理，一次专注于一件事的效率和成功率都会比较高 开始一个新的目标其实不会对你造成什么改变，但是完成一个目标可以 耐心 竹影扫阶尘不动，月底潭底水无痕 离开上家公司的时候我觉得选择很重要，离开后我觉得耐心也很重要。人总是要入一些围城，然后夸大自己了解事物的缺点，放大自己不了解事物的优点，从而带给自己一些期待。 其实是自己还不够豁达，眼睛容不得异物，好比人与人相处，需要缩小自己，开阔胸怀，让自己可以走进别人的心里，而不会刺伤人。 分享 布道 分享的意义 我们为什么要分享？分享的意义是什么？ 分享能够收获友谊，快乐和尊重 分享能提高和完善自己 鞭挞自己去不断的学习 一个饥饿的乞丐是没有资格付出的]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[站在秋末冬至的隘口]]></title>
      <url>http://www.lizorn.com//2011/12/08/stand-by-the-first-winner/</url>
      <content type="text"><![CDATA[站在秋末冬至的隘口 你轻轻的挥手 落叶纷飞在你的额头 落在我的心头 你微微一笑 酿成五十度的酒 一枚叶子的翠绿 绽放在冬天的枝头 你微笑的挥手 我醉在秋末冬至的隘口]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[阴雨.碎季.杂念]]></title>
      <url>http://www.lizorn.com//2009/11/18/my-essays-on/</url>
      <content type="text"><![CDATA[题记不经意看到了以前空间里的文章. 回看自己十年,真是幼稚可笑而可爱. 一也不知道什么时候开始,四季不再分明.想起姥姥屋后那一片池塘,还剩下最后一只落单的候鸟,在这样的天气在如此模糊的视野,能否再飞起来,飞向那潮湿苍白而压抑的天空. 我们和它们一样,就是这么挣扎在这个破碎的季节里的角角落落. 它们又和我们不一样,因为它们的目的更加单纯. 二2009年11月18日,有雨,1-3摄氏度. 杭城还是阴雨一阵,连绵不断的雨,把整个天空洗刷的阴郁而苍凉,而我也从未如此期盼过阳光. 从窗里望着窗外,在这个冷漠的城市里依旧车来车往,想起我那同名异姓的同事,70码,永远躺在那几条雪白的斑马线上. 举起咖啡,咖啡是叫女人从网上买的 &lt;铭咖啡&gt; 超市里是找不到的,大学时代偶尔在超市里买到过,一直念念不忘,味香苦涩而浓郁,不像其他那些袋装速溶咖啡:谈妆浓抹. 三这几天工作还算轻松,听到小潘空间里那首熟悉的歌,&lt;那些花儿&gt;,突然很有感触. &gt;那片笑声让我想起我的那些花儿在我生命每个角落静静为我开着我曾以为我会永远守在他身旁今天我们已经离去在人海茫茫 而我记忆里的那些花儿，也悄悄盛开在那逝去的年华里… 田地,青蛙,田鼠,湿了鞋子 养蚕,烤知了,打弹珠 和龟娃在大学美食城一盘炒面四瓶啤酒 记忆里非典人心惶惶，而我唯恐天下不乱的心情 记忆里在那二娘水饺，每一个烂醉如泥的夜晚… 胖子,猴子 … … 四有人说,生活如同剥洋葱,一层一层把它的皮剥去,眼泪就不受控制地往下流. 我觉得记忆更如同剥洋葱,你越不知疲倦的一层一层的剥,眼睛就越承受不住它的报复. &gt;他们都老了吧?他们在哪里呀?我们就这样各自奔天涯 往事如风,君如花,大家都好吗?]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[土豆和碧月刀]]></title>
      <url>http://www.lizorn.com//2009/03/09/potato-killer/</url>
      <content type="text"><![CDATA[夜,月黑风高,古荡湾新村. 夜,静的可怕. “呲呲” 从一个地方传来,这是一间屋子,屋子里自然住着人. 隐没在黑暗里,如同鬼魅,她不是真的黑,别人却叫她牙膏–”黑妹”牙膏. 没有人敢问为什么,因为她有一双手,一双晶莹的纤纤玉手 没有贪婪的目光敢在这双手上游走，因为她手里握着一把刀. 刀,是一把好刀,碧玉七星刀. 窗外吹起了风,云开见月,一缕月光,照到她的脸上. 她,是一个女人,一个敏感的女人,有着一张任何男人都会惊叹的脸. 雪肤,明眸,朱唇,皓齿. 而此时,他站在她面前,她却浑然不知.因为除了碧玉刀,她还握着一个豆,一个土豆. “呲呲”声,就来自刀下的土豆. “你来了”,她没有抬头，仿佛一切都在她的掌握之中. “是” “我原以为你不会来” “我来了” “你不该现在来” “我已经来了” 沉默……男人放下他的外套， “我原本以为已经好了” “还没有” “天已经这么黑了” “正在削” “可我饿太久了” 对视……片刻,她幽幽的叹了口气. “好吧，你要什么” “土豆牛肉” “什么！”她心中一惊，脸上笼了一层寒气. “土──豆──牛──肉！”他缓慢地，却异常清晰地吐出四个字. “是谁告诉你的?” “朋友” “你就这么相信朋友?” “我原来也不太相信，可我现在信了” “为什么” “你的眼睛告诉了我答案” “可是还要牛肉” “我知道” “那你为什么还要” “因为你在这里，牛肉也在桌上” “这么说来你一定要吃” “是” “没有商量的余地？” “是” “能不吃吗” 她抛去一个醉人的笑,足以迷倒十个彪形大汉.她有这个自信,可是这次她失算了,她没看透面对的是一个什么样的人. 在他的眼中,只有土豆. “不能” 沉默,又是沉默… 终于,她又回复了冷静. “好吧,但需要时间” “我会等” 是夜,漆黑一片 夜,静的可怕 “呲呲” 从一个地方传来,这是一间屋子,屋子里,两个人,一把刀,一包土豆…]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[anonymity]]></title>
      <url>http://www.lizorn.com//2007/05/16/anonymity-2007/</url>
      <content type="text"><![CDATA[How many days have I lost, how can I get back to the place where I started. I’m outside the house,try to find my way in,but it’s locked,and the blines are down,and I lost the key,I cann’t remember what the rooms look like and where I put anything.And if I dare go inside,i wonder,was I able to find my way out. If I go back to the beginning,i could start it over again,I can go line by line,try to find the order way,I can try to make it,better…]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[绝望中的虚妄(2005)]]></title>
      <url>http://www.lizorn.com//2005/10/05/hope-lost/</url>
      <content type="text"><![CDATA[世界忘了呼吸 飓风狂妄地吞没了世界 整个的… 忘情地呼啸着 穿透了空间的每一个角落 那凛冽的 从脸孔里直灌入血液 如同千把刃向心脏里钻去 仿佛听到薄冰碎裂的声音 随着脉络的跳动 寒冷一点一点地蚕食掉血肉 终于 叫嚣出崩溃前安静而隆重的一声哀嚎 灵魂上升到苍穹的高度… …… 谁丢掉了呼吸? 就像默然欣赏着一幅恍如隔世的油画 那华丽的生命分裂时悲壮的诀别 然后顷刻间 风 忽然死了 于是垂直的雨水惊心动魄地打落在这个桀骜的生命上 双手合十 似乎感受到灵魂从眼眸里溶化的热度 穹壁上掉下的泪水 完美地交缠于粘稠的血液 一片不规则的血红里盛放着星星点点的水晶 泪水从哪里一直一直地迸涌 两边倾斜的街道疯狂地都向后奔跑 城市里的霓虹灯不断跳动 冷漠地丢开世界最后的一点热度 所有的一切都毫无挽留地向那一端里去 那一端无边的黑暗里去 凝固了的猩红的泪水不断不断地泛滥了世界 被淹没在血腥下的城市 越来越静 越来越静 鸦雀无声… …… 谁的血脉依然在动？ 谁一手扯住了回忆的翅膀？ 那对被模糊了血肉的双手 将溅起的血红都涂抹在白絮一样的因惊恐而颤动的羽翼上 然后将凝聚在眼眸里最后的一点辉煌转化为全身的力量 把羽翼活生生地从记忆上撕裂! 伴随一丝扭曲而狰狞的笑容 血红的玫瑰色遍染天壁 满天的羽毛伴随着苍穹的碎片 翩然地纷纷扬扬… 一起扑向 盛大的死亡]]></content>
    </entry>

    
  
  
</search>
