<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[2018读书笔记]]></title>
    <url>%2F2019%2F01%2F06%2F2018-read-memo%2F</url>
    <content type="text"><![CDATA[系统之美 对于一个系统来说，整体大于部分之和。任何一个系统都包括三种构成要件：要素、连接、功能或目标。它具有适应性、动态性、目的性，并可以自组织、自我保护与演进。 存量是对系统中变化量的一种历史记录。存量会随着时间的变化而不断改变，使其发生变化的就是“流量”。所谓流量，是一段时间内改变的状况。 现代工业文明正慢慢侵蚀着人们的美德表现。 常见的系统陷阱与对策政策阻力（Policy Resistance）陷阱当系统中多个参与者有不同的目标，从而将系统存量往不同方向拉时，结果就是政策阻力。 任何新政策，尤其是当它恰好管用时，都会让存量远离其他参与者的目标，因而会产生额外的抵抗，其结果是大家都不愿意看到的，但每个人都要付出相当的努力去维持它。 对策放弃压制或实现单方面的目标。化阻力为动力，将所有参与者召集起来，用先前用于维持政策刚性的精力，去寻找如何实现所有人的目标，实现“皆大欢喜”，或者重新定义一个更大的、更重要的总体目标，大家愿意齐心协力去实现它。 公地悲剧（The Tragedy of the Commons）陷阱当存在一种公共资源时，每个使用者都可以从这种资源的使用中直接获利，用得越多，收益也越大，但是过度使用的成本却需由所有人来分担。因此，资源的整体状况和单个参与者对资源的使用之间的反馈关联非常弱，结果导致资源的过度使用及耗竭，最终每个人都没有资源可用。 对策对使用者进行教育和劝诫，让他们理解滥用资源的后果。同时，也可以恢复或增强资源的状况及其使用之间的弱反馈连接，有两类做法： 一是将资源私有化，让每个使用者都可以直接感受到对自己那一份资源滥用的后果； 二是对于那些无法分割和私有化的资源，则要对所有使用者进行监管。 目标侵蚀（Drift to Low Performance）陷阱绩效标准受过去绩效的影响，尤其是当人们对过去的绩效评价偏负面，也就是过于关注坏消息时，将启动一个恶性循环，使得目标和系统的绩效水平不断下滑。 对策保持一个绝对的绩效标准。将绩效标准设定为过去的最佳水平，从而不断提高自己的目标，并以此激励自己，追求更高的绩效。 竞争升级（Escalation）陷阱当系统中一个存量的状态是取决于另外一个存量的状态，并试图超过对方时，就构成了一个增强回路，使得系统陷入对抗升级的陷阱，表现为军备竞赛、财富攀比、口水仗、声音或暴力升级等现象。 由于对抗升级以指数形式变化，它能以非常令人惊异的速度导致竞争激化。如果什么也不做，这一循环也不可能一直发展下去，最后的结果将是一方被击倒或两败俱伤。 对策应对这一陷阱的最佳方式是避免陷入这一结构之中。 如果已经深陷其中，一方可以选择单方面让步，从而切断增强回路；或者双方进行协商，引入一些调节回路，对竞争进行一些限制。 富者愈富（Success to the Successful）陷阱如果在系统中，竞争中的赢家会持续地强化其进一步获胜的手段，这就形成了一个增强回路。如果这一回路不受限制地运转下去，赢家最终会通吃，输家则被消灭。 对策 多元化，即允许在竞争中落败的一方可以退出，开启另外一场新的博弈； 反垄断法，即严格限制赢家所占有的最大份额比例； 修正竞赛规则，限制最强的一些参与者的优势，或对处于劣势的参与者给予一些特别关照，增强他们的竞争力（例如施舍馈赠、税赋调节、转移支付等）； 对获胜者给予多样化的奖励，避免他们在下一轮竞争中争夺同一有限的资源，或产生偏差。 转嫁负担（Shifting the Burden to the Intervenor）陷阱当面对一个系统性问题时，如果采用的解决方案根本无助于解决潜在的根本问题，只是缓解（或掩饰）了问题的症状时，就会产生转嫁负担、依赖性和上瘾的状况。不管是麻痹个人感官的物质，还是把潜在麻烦隐藏起来的政策，人们选择的干预行动都不能解决真正的问题。 如果选择并实施的干预措施，导致系统原本的自我调适能力萎缩或受到侵蚀，就会引发一个破坏性的增强回路。 系统自我调适能力越差，就需要越多的干预措施；而这会使得系统的自我调适变得更差，不得不更多地依赖外部干预者。 对策应对这一陷阱最好的办法是提前预防，防止跌入陷阱。 一定要意识到，只缓解症状或掩饰信号的政策或做法，都不能真正地解决问题。因此，要将关注点从短期的救济转移到长期的结构性重建上来。 规避规则（Rule Beating）陷阱“上有政策，下有对策”。任何规则都可能会有“漏洞”或“例外情况”，因而也会存在规避规则的行为。也就是说，虽然一些行为在表面上遵守或未违背规则，但实质上却不符合规则的本意，甚至扭曲了系统。 对策设计或重新设计规则，从规避规则的行为中获得创造性反馈，使其发挥积极的作用，实现规则的本来目的。 目标错位（Seeking the Wrong Goal）陷阱系统行为对于反馈回路的目标特别敏感。如果目标定义不准确或不完整，即使系统忠实地执行了所有运作规则，其产出的结果却不一定是人们真正想要的。 对策恰当地设定目标及指标，以反映系统的真正福利。一定要特别小心，不要将努力与结果混淆，否则系统将只产出特定的努力，而不是你期望的结果。 系统世界的生存法则1.跟上系统的节拍。2.把你的心智模式展现在阳光下。3.相信、尊重并分享信息。4.谨慎地使用语言，并用系统的概念去丰富语言。5.关注重要的，而不只是容易衡量的。6.为反馈系统制定带有反馈功能的政策。7.追求整体利益。8.聆听系统的智慧。9.界定系统的职责。10.保持谦逊，做一名学习者。11.庆祝复杂性。12.扩展时间的范围。13.打破各种清规戒律。14.扩大关切的范围。15.不要降低“善”的标准。 AI·未来 目前，人工智能革命分为四波浪潮：互联网智能化（Internet AI）、商业智能化（business AI）、实体世界智能化（perception AI）、自主智能化（autonomous AI）。每一波浪潮都将以不同方式利用人工智能的力量，颠覆不同产业，让人工智能更深层次地融入我们的生活。 今日简史：人类命运大议题 人类思考用的是故事，而不是事实、数据或方程式，而且故事越简单越好。 宇宙有三个基本现实：一切事物都会不断改变（诸行无常），一切事物都没有永恒的本质（诸法无我），没有什么能永远令人满意（诸漏皆苦）。 人类之所以能征服世界，是靠创造和相信虚构故事的能力。但也因此，人类特别拙于判断虚构和现实的差异。毕竟我们要无视两者的差异，才能得以生存，过于计较，就会受苦。因为，世界上最真实的东西就是痛苦。 创造的本源 “艺术能真实体现出我们现在的样子和过去的样子；体现我们现在的生活方式和过去的生活方式；能生动地体现出我们作为一个个活生生的人，被各种动力和情感所左右。但是艺术并不能真实地反映出人类的集体实体或社会学范式。” 娱乐至死 钟表是怎样使人变成遵守时间的人、节约时间的人和现在被拘役于时间的人。在这个过程中，我们学会了漠视日出日落和季节更替，因为在一个由分分秒秒组成的世界里，大自然的权威已经被取代了。 “到处是水却没有一滴水可以喝” 生命3.0 我们可以根据生命设计自身的能力，把生命的发展分成三个阶段： 生命1.0（生物阶段）：靠进化获得硬件和软件； 生命2.0（文化阶段）：靠进化获得硬件，但大部分软件是由自己设计的； 生命3.0（科技阶段）：自己设计硬件和软件。 我读过也听说过很多思想家的伦理观点，这些观点都十分迷人。我认为，大多数人的观点都可以归入以下4个原则： 功利主义：积极的意识体验应当被最大化，而痛苦应当被最小化； 多样化：多样化的积极体验比重复单一的积极体验更好，即使后者被认为是所有可能性中最积极的体验； 自主性：有意识的实体／社会应当拥有追寻自己目标的自由，除非与某些重要原则相违背； 遗产：符合当今大多数人认为幸福的情景，不符合当今几乎所有人认为糟糕的情景。 第一定律：一个有意识的实体有思考、学习、交流、拥有财产、不被伤害或不被毁灭的自由； ◦ 第二定律：在不违反第一定律的情况下，一个有意识的实体有权做任何事。 进击的智人 匮乏的环境下，人类祖先通常只能以粗糙低质的食物为生，于是他们不得不依赖强壮的咬合肌以保证进食，后来基因的突变使得他们的咬合肌减弱了，一部分人不得不使用工具对坚硬的食物进行预处理以缓冲匮乏的压力，这同时使得他们的脑容量增大。头部尺寸的增大使得母亲的生育变得困难，同时采集食物的效率降低，形成了新的匮乏，为了缓冲新的匮乏，更长寿的外祖母被筛选了出来，帮助自己的女儿养育孩子，于是筛选出了更长寿、更晚熟的基因，使得人类的生长进度被拉长，形成了更大的体格。]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[技术采用模型]]></title>
    <url>%2F2019%2F01%2F03%2Ftechnology-acceptance-model%2F</url>
    <content type="text"><![CDATA[技术采用生命周期 按照创新寿命周期模型，各个阶段存在不同的用户群体：创新者、早期采用者、早期大众、后期大众、落后者，不同的用户群体有不同的心理特征，产品需要快速迭代去满足不同的需求。 跨越死亡之井 早期采用者向实用主义为主的早期大众过度是最难的。2C&amp;2B。 2B：饥饿感更强的公司进行合作，他们更有突破感。2C：把创新技术直接卖给C端用户。 在早期采用者和早期大众间（也就是第2和第3个阶段间）存在一个被称为死亡之井的地带。一个技术创新产品在获得早期采用者之后，能否得到早期大众的认可是具有一定难度的。 用户群体的异同点。创新者群体特征： 他们往往是新技术应用的创造者 他们是新技术创新的狂热信徒 他们对技术创新有着非常敏感的触觉 主动的获取信息，并积极的参与进来 他们通常都有着旺盛的好奇心和关联性很强的经验和知识 这是一群在创新初期具有巨大价值的专业人事，找到他们并聆听意见，可以让产品在初期拥有更多的进化选择，从而让创新的深度和强度得以增加。 早期采用者群体特征： 他们有自己的专业知识和经验判断，通常是意见领袖 他们不是创新产品的真正使用者，而是创新产品的验证者和把关人 他们是实用主义者，以一个判官的身份去尽可能发掘其是否真的具有商业价值 主动的获取信息，并积极的参与进来 可以把这一类人看做是产品在消费大众中的自愿测试者。通过一定的宣传渠道，将信息传递给这个人群后，他们就会自然而然的产生对产品试用的需求，哪怕需要支付费用。 早期大众这一阶段的用户，才称为真正的产品使用者。只有这一类人群加入，才能获得真正想获得的利润和生命力。 群体特征： 他们不认为应该去购买不成熟的或者自己认为不确定是否实用的产 他们并不想去测试产品 有别于第二阶段的用户，他们没有对新事物探索和验证的需求 务实的群体，只考察产品是否满足需求 他们通常从第二阶段人群验证的结果里获取信息，来判断自己是否真的应该发生购买行为 他们对过早的产品周期根本就不感兴趣 这一阶段的用户往往是实用性用户群体，只要你的技术或者产品能够抓住并解决他们的痛点，他们就会参与进来。 后期大众群体特征： 这类用户群体本质上和3阶段用户的需求基本一致 他们的思维方式更加的保守，是市场中的保守者 他们对新产品更替可能带来的机会风险更加敏感 他们需要更加充足的理由来去促使其产生对技术的采用，这种理由仅仅来自意见领袖的主张是不够的 他们还会考虑技术在中长期应用过程中是否会出现不良反应 他们对价格敏感，也很挑剔,不希望为新的技术支付更高的购买和使用成本 这类人群很可能是在技术采用达到一定规模，而成本下降后加入进来的。或者陈旧技术出现不可逆转的被淘汰的趋势的时候，他们认为新技术的采用更加保险后，才加入进来的。 落后者群体特征： 这类群体是技术的落伍者，充满怀疑和敌视的态度 他们通常对新技术并不感兴趣，并且对改变现有的方式具有负面的心情 他们可能是懒人，或者是一群愚蠢的自作聪明的家伙 他们乐于站在一边，看新技术如何死去,让他们开心 他们不是目标用户群。他们会在你的技术真正走进千家万户，成为普通技术的时候，才加入进来。而这个时候，你会发现，这一技术的生命周期已经接近完结了。]]></content>
      <categories>
        <category>思维</category>
      </categories>
      <tags>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[技术创新过程中的十大矛盾]]></title>
    <url>%2F2019%2F01%2F02%2Ften-contradictions-in-the-process-of-innovation%2F</url>
    <content type="text"><![CDATA[有些人因为相信而看见，有些人因为看见才相信。人类社会的进步，永远都需要前者。 科学 VS 艺术 用户需求的不仅是功能，而是情感. 经验 VS 创新 经验可能是增值的利器，也有可能是创新的绊脚石 自上而下 VS 自下而上 技术创新-&gt;市场需求 VS 市场需求 -&gt; 技术创新 领导-&gt;员工 VS 员工-&gt;领导 打破乘法效应，创新才不会被埋没。 坚持 VS 变化 在多变的轨迹当中，记住原点。在悲喜的过程中，勿忘初心。 艰难 VS 舒服 做正确的选择，而不是做容易的选择。 逻辑 VS 脾气 逻辑大于脾气是所有成功企业和个人的共同特征。不要让别人的节奏影响了自己的步伐。 独立 VS 开放 开放的心态，独立的判断。 长期 VS 短期 既要埋头干活，也要抬头看路。既要仰望星空，也要脚踏实地。 结果 VS 目标 Stay focused on what really matters. 噪音 VS 决心 永远都会有人怀疑新鲜的事物，重要的是自己清楚什么是正确的方向并且持之以恒。]]></content>
      <categories>
        <category>创新</category>
      </categories>
      <tags>
        <tag>鸡汤</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[智能化变革下的商业模式思考模型]]></title>
    <url>%2F2018%2F12%2F30%2Fnew_economic%2F</url>
    <content type="text"><![CDATA[商业模式思维模型 新经济公司如何估值？123产品价值：产品+产能客户价值：活跃客户+买家+客单价平台价值：参考商业模式思维模型 新零售模式下的收入构成？1收入构成 = 流量 * 内容 * 营销方案]]></content>
      <categories>
        <category>商业模式</category>
      </categories>
      <tags>
        <tag>新零售</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Scratch编程卡片]]></title>
    <url>%2F2018%2F12%2F29%2Fscratch-cards%2F</url>
    <content type="text"><![CDATA[开始教女儿编程，主要参考官方以及DK的教程，先记录，后整理。 改变颜色卡片 目的通过学习，熟悉“按键”、“特效”。 掌握事件按键监听 掌握外观特效的概念 分解 事件：当按下*键 外观：将*特效增加* 设计 导入角色“蝴蝶” 编写代码 思考 尝试其他的特效，如马赛克，旋转,像素化等. 生活中的事物是如何在计算机表现出来的？ 数字化。 动起来卡片 目的通过学习，熟悉“前进”、“倒退”、“声音”、“造型切换”。 掌握运动“移动”方法 掌握造型切换 熟悉控制语句 分解 运动：移动*步 外观：下一个造型 控制：重复执行 设计 导入角色“Cassy” 编写代码 思考 如何让Cassy更有律动？ 尝试改变“造型”。 按键移动卡片 目的通过学习，熟悉“面向”、“移动”和“造型切换”，懂得如何按自己的想法控制角色。 掌握事件“按键”监听 掌握运动“面向”方法 掌握造型切换 分解 运动：面向*方向、移动*步 事件：当按下*键 外观：下一个造型 设计 导入“老鼠”角色 编写代码 思考如何让老鼠“动”起来？ 帧动画的实现原理是不断切换视觉内图片内容,利用视觉滞留生理来实现连续播放的动画效果。我们通过切换老鼠的造型（下一个造型）来实现这一功能。 猫抓老鼠卡片 目的通过学习，熟悉“面向鼠标指针“,”碰撞侦测“，”运算“等基础操作。 掌握运动：面向鼠标指针。 掌握侦测：碰到* 掌握控制：如果*那么 了解”运算“的随机值。 设计导入角色“猫”和老鼠 编写代码猫 老鼠 思考 如何在猫碰到老鼠的时候，老鼠说一句话?比如：”救命啊！！“。 能否做到让猫自动抓老鼠？]]></content>
      <categories>
        <category>少儿编程</category>
      </categories>
      <tags>
        <tag>少儿编程</tag>
        <tag>scratch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[中美贸易战感想]]></title>
    <url>%2F2018%2F08%2F24%2Ftrade-war%20%2F</url>
    <content type="text"><![CDATA[18年多灾多难，中美贸易战经过几个回合，美国牛市依旧，A股一地鸡毛。国内的媒体对双方和解还抱有很大的希望，一致唱多，我觉得这次战斗无法避免，除非中国做到真正的全面开放。 中美会有冲突原因有很多，中美的意识形态本来就不一样，价值观和世界观都不一致的人很难成为朋友。美国又是由传教士建国，有传教士的基因，喜欢散播自己的理念，理念和他近就是盟友，远就是敌人。 中美虽然意识不和，但之前的40年存在政治基础，这个基础来自于邓小平时代。他交了一份投名状：打越南，背后捅苏联，搞市场经济。这些，都投了美国人的喜好，中美才开始正在意义上的建交。苏联解体后，怕美国盯上中国，邓的指示是”韬光养晦”，所以可以看到中国在国际社会的不怎么发声。 在美国的支持下，中国加入WTO，中国凭着人口优势，在没有任何经济基础的情况下和各个富有大国展开了商务来往，凭着中国人的聪明才智，中国经济开始腾飞。但中国的改革开放其实就是加入WTO而已，是对内开放，现在一晃40年过去了，中国的市场经济还是一团糟，国际资本很难进入，而自己的企业还可以靠政府输血不断的去收购国外的企业。 中美贸易战在第一回合的谈判中，美国就直接提出了要求中国开放金融服务业市场准入这样触及底线的要求，并提出在关税、市场准入、知识产权等问题上的全面对等，还提出了关于互联网全面开放的要求。 所以已经谈崩了，在几次交锋当中我们已经节节败退，嘴上不老实，身体很诚实（降低汽车进口税、放开保险准入、取消中资银行外资持股比例限制…）。 现实的来说，如果没有美国高科技和知识产权的帮助，中国的产业升级和2025规划是很难实现的，中国离不开美国。 那么，中国的筹码是什么呢？ 近代中国除了人多、收收垃圾、做做衣服和毛绒玩具，对世界没有太多的贡献，中国的这种低端出口都有其他的替代品。我们最重要的核心筹码其实是我们自己：中国将是未来全球最大的消费升级市场。 然而，最令人痛心的是，这个消费升级的市场却面临着一个刻不容缓的难题：房地产。 当给房子赋予了金融属性后，房地产开始绑架中国的经济，开始绑架中国的内需，开始绑架创新，开始绑架未来。政府借着房价问题去了自己的杠杆，却把杠杆加到了老百姓的头上。望着高高的房价，消费升级是痴人说梦。 房价会是压垮中国经济的最后一根稻草吗？ 川普眼光毒辣而且非常有魄力和执行力，贸易战将是一个漫长的过程，我也希望借此可以看到中国的改变，因为… 美元是他们的货币,但却是我们的难题]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>贸易战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python spider intruduce]]></title>
    <url>%2F2018%2F05%2F22%2Fpython-spider-intruduce%2F</url>
    <content type="text"><![CDATA[爬虫入门简单，精通也不易。虽然爬虫是Python的看家本领，网上也有大量的教程，但是大部分文章所涉及的内容都的粗浅，没有系统性的介绍，也不具备工程实战性。遂系统性的梳理一下。 什么是爬虫爬虫（又被称为网页蜘蛛，网络机器人，在FOAF社区中间，更经常的称为网页追逐者），是一种按照一定的规则，自动地抓取万维网信息的程序或者脚本。另外一些不常使用的名字还有蚂蚁、自动索引、模拟程序或者蠕虫。 如果把互联网比喻成一个蜘蛛网，Spider就是一只在网上爬来爬去的蜘蛛。网络爬虫就是根据网页的地址来寻找网页的，也就是URL。Google、baidu就是最大的爬虫，搜索引擎的数据内容都是由网络蜘蛛爬去网络而来。 什么是URLURL:统一资源定位符(Uniform Resource Locator)，一般格式如下： protocol ://hostname[port]/path/[parameters][?query]#fragment URL的格式由三部分组成： protocol：协议，通讯协议。一般使用TCP/IP应用层协议，例如http/https/ftp/smb等等； hostname[:port]：主机名[端口号]; path: 资源在主机中的具体地址，如目录和文件名等。 通常，爬虫使用URL来获取(Request)资源信息，并对返回内容(Response)做对应的解析和处理。返回的内容比较多样，比如文本、图片、excel/csv、json/xml、html等。大部分人只知道html爬虫也就是通常意义上的web spider，因为它需求广泛而且解析较简单。 内容解析方式爬虫获取的数据是多样的，Response可能是一堆字符串也有可能是一个二进制文件，这取决于文本的编码方式；Response可能是结构化的（数据库、json）也有可能是非结构化的（比如图片、视频），这取决于资源的组织形式。 解析非结构化的数据，一般需要耗费大量的资源，然后训练出一个相对拟合的、结构化的模型，最后用这个模型分析返回的数据，并且这一过程可能是不断迭代的，直到达到真正的价值转移。 这里我们只找软柿子捏。解析软柿子一般有以下几种形式： XML/JSON/CSV这类数据已经是非常结构化的数据了，并且有大量的第三方库支持，它们是烂柿子，这里就不捏了。 XML libxml lxml JSON: json CSV: csv excel 文本正则表达式正则表达式是一个特殊的字符序列，它能帮助你方便的检查一个字符串是否与某种模式匹配。 目的给定一个正则表达式和另一个字符串，我们可以达到如下的目的： 给定的字符串是否符合正则表达式的过滤逻辑（称作“匹配”）： 可以通过正则表达式，从字符串中获取我们想要的特定部分。特点 正则表达式的特点是： 灵活性、逻辑性和功能性非常强； 可以迅速地用极简单的方式达到字符串的复杂控制。 对于刚接触的人来说，比较晦涩难懂。 python RE Module123&gt;&gt;&gt; text = "He was carefully disguised but captured quickly by police."&gt;&gt;&gt; re.findall(r"\w+ly", text)['carefully', 'quickly'] 几个特殊字符要注意:1、. 匹配任意除换行符“\n”外的字符；2、表示匹配前一个字符0次或无限次；3、+或后跟？表示非贪婪匹配，即尽可能少的匹配，如？重复任意次，但尽可能少重复；4、 .? 表示匹配任意数量的重复，但是在能使整个匹配成功的前提下使用最少的重复。 12345678In [1]: s = 'aabab'In [2]: import reIn [3]: re.findall(r'a\w+b',s)Out[3]: ['aabab']In [4]: re.findall(r'a\w+?b',s)Out[4]: ['aab']In [5]: re.findall(r'a\w*?b',s)Out[5]: ['aab', 'ab'] 其他内容见官网正则表达式 HTMLHTML:超文本标记语言，标准通用标记语言下的一个应用。“超文本”就是指页面内可以包含图片、链接，甚至音乐、程序等非文字元素。网络爬虫主要处理的就是这种格式的文本。在python体系中，有很多自带的方法和丰富的第三方库来处理这类数据。 htmlparser BeautifulSoup XPath什么是 XPath? XPath 使用路径表达式在 XML 文档中进行导航 XPath 包含一个标准函数库 XPath 是 XSLT 中的主要元素 XPath 是一个 W3C 标准 总之XPath 是一门在XML文档中查找信息的语言，它使用路径表达式来选取XML文档中的节点或节点集。 XML是HTML的超集合。我们也可以使用xpath语法来解析html。 路径表达式 表达式 描述 nodename 选取此节点的所有子节点。 / 从根节点选取。 // 从匹配选择的当前节点选择文档中的节点，而不考虑它们的位置。 . 选取当前节点。 .. 选取当前节点的父节点。 @ 选取属性。 示例html.parserhtmlParser是python自带的库，可以方便的对html结构的数据做解析。 1234567891011121314151617181920212223242526272829303132333435from html.parser import HTMLParserfrom html.entities import name2codepointclass MyHTMLParser(HTMLParser): def handle_starttag(self, tag, attrs): print("Start tag:", tag) for attr in attrs: print(" attr:", attr) def handle_endtag(self, tag): print("End tag :", tag) def handle_data(self, data): print("Data :", data) def handle_comment(self, data): print("Comment :", data) def handle_entityref(self, name): c = chr(name2codepoint[name]) print("Named ent:", c) def handle_charref(self, name): if name.startswith('x'): c = chr(int(name[1:], 16)) else: c = chr(int(name)) print("Num ent :", c) def handle_decl(self, data): print("Decl :", data)parser = MyHTMLParser()parser.feed('&lt;img src="python-logo.png" alt="The Python logo"&gt;') 爬虫入门抓取网页urllib is a package that collects several modules for working with URLs: urllib.request 打开和读取URLs urllib.error 包含urllib.request产生的错误，可以使用try进行捕捉处理 urllib.parse 解析URLs urllib.robotparser 解析robots.txt文本文件 12345678910# -*- coding: UTF-8 -*-from urllib import requestimport chardetif __name__ == "__main__": response = request.urlopen("https://www.baidu.com/") html = response.read() charset = chardet.detect(html) print(charset) print(html) BeautifulSoupBeautiful Soup 是一个可以从HTML或XML文件中提取数据的Python库.它能够通过你喜欢的转换器实现惯用的文档导航,查找,修改文档的方式.Beautiful Soup会帮你节省数小时甚至数天的工作时间. 12345678910111213141516171819202122232425262728293031323334# coding=utf-8import requestsfrom bs4 import BeautifulSoup# 获取html文档def get_html(url): """get the content of the url""" response = requests.get(url) response.encoding = 'utf-8' return response.text# 获取最新的笑话def get_latest_joker(html): """get the last joke of the html""" soup = BeautifulSoup(html, "html.parser") joke_content = soup.select('div.content')[0].get_text() return joke_content# 获取笑话def get_joke_contents(html): """get the joke of the html""" joke_contents = [] soup = BeautifulSoup(html, "html.parser") for content in soup.select('div.content'): joke_contents.append(content.get_text()) # joke_content = soup.select('div.content')[1].get_text() return joke_contentsif __name__=="__main__": url_joke = "https://www.qiushibaike.com" html = get_html(url_joke) joke_contents = get_latest_joker(html) print(joke_contents) BS解析器 解析器 使用方法 优势 劣势 Python标准库 BeautifulSoup(markup, “html.parser”) Python的内置标准库、执行速度适中、文档容错能力强 Python 2.7.3 or 3.2.2)前 的版本中文档容错能力差 BeautifulSoup(markup, “xml”) BeautifulSoup(markup, “lxml”) 速度快、唯一支持XML的解析器 需要安装C语言库 html5lib BeautifulSoup(markup, “html5lib”) 最好的容错性、以浏览器的方式解析文档、生成HTML5格式的文档 速度慢 爬虫框架ScrapyScrapy，Python开发的一个快速,高层次的屏幕抓取和web抓取框架，用于抓取web站点并从页面中提取结构化的数据。Scrapy用途广泛，可以用于数据挖掘、监测和自动化测试。 架构 引擎(Scrapy)用来处理整个系统的数据流处理, 触发事务(框架核心) 调度器(Scheduler)用来接受引擎发过来的请求, 压入队列中, 并在引擎再次请求的时候返回. 可以想像成一个URL（抓取网页的网址或者说是链接）的优先队列, 由它来决定下一个要抓取的网址是什么, 同时去除重复的网址 下载器(Downloader)用于下载网页内容, 并将网页内容返回给蜘蛛(Scrapy下载器是建立在twisted这个高效的异步模型上的) 爬虫(Spiders)爬虫是主要干活的, 用于从特定的网页中提取自己需要的信息, 即所谓的实体(Item)。用户也可以从中提取出链接,让Scrapy继续抓取下一个页面 项目管道(Pipeline)负责处理爬虫从网页中抽取的实体，主要的功能是持久化实体、验证实体的有效性、清除不需要的信息。当页面被爬虫解析后，将被发送到项目管道，并经过几个特定的次序处理数据。 下载器中间件(Downloader Middlewares)位于Scrapy引擎和下载器之间的框架，主要是处理Scrapy引擎与下载器之间的请求及响应。 爬虫中间件(Spider Middlewares)介于Scrapy引擎和爬虫之间的框架，主要工作是处理蜘蛛的响应输入和请求输出。 调度中间件(Scheduler Middewares)介于Scrapy引擎和调度之间的中间件，从Scrapy引擎发送到调度的请求和响应。 运行流程 引擎从调度器中取出一个链接(URL)用于接下来的抓取 引擎把URL封装成一个请求(Request)传给下载器 下载器把资源下载下来，并封装成应答包(Response) 爬虫解析Response 解析出实体（Item）,则交给实体管道进行进一步的处理 解析出的是链接（URL）,则把URL交给调度器等待抓取 教程无他，官网 示例爬取有品质的网站的数据相对简单（比如知乎、51job、豆瓣等等），它们的前端页面的元素的命名相对比较规范。大厂的页面反而好解析，而且网上有大量的实例，这里我们来爬取一些技术比较落后的网站，比如爬取宁波新楼盘数据。 步骤 创建工程： scrapy startproject tutorial 创建爬虫: 12cd tutorial scrapy genspider nbnewhouse cnnbfdc.com 爬取数据: scrapy crawl nbnewhouse scrapy shell可以在shell内分析网站，将xpath或css语句调试好。1234567scrapy shell https://newhouse.cnnbfdc.com/projects&gt;&gt;&gt; response.xpath(&quot;//div[@class=&apos;views-row&apos;]&quot;)[]&gt;&gt;&gt; response.xpath(&quot;//div[@class=&apos;item-list&apos;]&quot;)[&lt;Selector xpath=&quot;//div[@class=&apos;item-list&apos;]&quot; data=&apos;&lt;div class=&quot;item-list&quot;&gt;&lt;ul class=&quot;faceta&apos;&gt;, &lt;Selector xpath=&quot;//div[@class=&apos;item-list&apos;]&quot; data=&apos;&lt;div class=&quot;item-list&quot;&gt;&lt;ul class=&quot;faceta&apos;&gt;, &lt;Selector xpath=&quot;//div[@class=&apos;item-list&apos;]&quot; data=&apos;&lt;div class=&quot;item-list&quot;&gt;&lt;ul class=&quot;faceta&apos;&gt;, &lt;Selector xpath=&quot;//div[@class=&apos;item-list&apos;]&quot; data=&apos;&lt;div class=&quot;item-list&quot;&gt;&lt;ul class=&quot;faceta&apos;&gt;, &lt;Selector xpath=&quot;//div[@class=&apos;item-list&apos;]&quot; data=&apos;&lt;div class=&quot;item-list&quot;&gt;&lt;ul class=&quot;search&apos;&gt;, &lt;Selector xpath=&quot;//div[@class=&apos;item-list&apos;]&quot; data=&apos;&lt;div class=&quot;item-list&quot;&gt; &lt;ul&gt; &apos;&gt;, &lt;Selector xpath=&quot;//div[@class=&apos;item-list&apos;]&quot; data=&apos;&lt;div class=&quot;item-list&quot;&gt;&lt;ul class=&quot;pager&quot;&apos;&gt;]&gt;&gt;&gt; response.xpath(&quot;//div[@class=&apos;item-list&apos;]&quot;)[5].css(&apos;li&apos;)[&lt;Selector xpath=&apos;descendant-or-self::li&apos; data=&apos;&lt;li class=&quot;views-row views-row-1 views-r&apos;&gt;, &lt;Selector xpath=&apos;descendant-or-self::li&apos; data=&apos;&lt;li class=&quot;views-row views-row-2 views-r&apos;&gt;, &lt;Selector xpath=&apos;descendant-or-self::li&apos; data=&apos;&lt;li class=&quot;views-row views-row-3 views-r&apos;&gt;, &lt;Selector xpath=&apos;descendant-or-self::li&apos; data=&apos;&lt;li class=&quot;views-row views-row-4 views-r&apos;&gt;, &lt;Selector xpath=&apos;descendant-or-self::li&apos; data=&apos;&lt;li class=&quot;views-row views-row-5 views-r&apos;&gt;, &lt;Selector xpath=&apos;descendant-or-self::li&apos; data=&apos;&lt;li class=&quot;views-row views-row-6 views-r&apos;&gt;, &lt;Selector xpath=&apos;descendant-or-self::li&apos; data=&apos;&lt;li class=&quot;views-row views-row-7 views-r&apos;&gt;, &lt;Selector xpath=&apos;descendant-or-self::li&apos; data=&apos;&lt;li class=&quot;views-row views-row-8 views-r&apos;&gt;, &lt;Selector xpath=&apos;descendant-or-self::li&apos; data=&apos;&lt;li class=&quot;views-row views-row-9 views-r&apos;&gt;, &lt;Selector xpath=&apos;descendant-or-self::li&apos; data=&apos;&lt;li class=&quot;views-row views-row-10 views-&apos;&gt;, &lt;Selector xpath=&apos;descendant-or-self::li&apos; data=&apos;&lt;li class=&quot;views-row views-row-11 views-&apos;&gt;, &lt;Selector xpath=&apos;descendant-or-self::li&apos; data=&apos;&lt;li class=&quot;views-row views-row-12 views-&apos;&gt;, &lt;Selector xpath=&apos;descendant-or-self::li&apos; data=&apos;&lt;li class=&quot;views-row views-row-13 views-&apos;&gt;, &lt;Selector xpath=&apos;descendant-or-self::li&apos; data=&apos;&lt;li class=&quot;views-row views-row-14 views-&apos;&gt;, &lt;Selector xpath=&apos;descendant-or-self::li&apos; data=&apos;&lt;li class=&quot;views-row views-row-15 views-&apos;&gt;, &lt;Selector xpath=&apos;descendant-or-self::li&apos; data=&apos;&lt;li class=&quot;views-row views-row-16 views-&apos;&gt;, &lt;Selector xpath=&apos;descendant-or-self::li&apos; data=&apos;&lt;li class=&quot;views-row views-row-17 views-&apos;&gt;, &lt;Selector xpath=&apos;descendant-or-self::li&apos; data=&apos;&lt;li class=&quot;views-row views-row-18 views-&apos;&gt;, &lt;Selector xpath=&apos;descendant-or-self::li&apos; data=&apos;&lt;li class=&quot;views-row views-row-19 views-&apos;&gt;, &lt;Selector xpath=&apos;descendant-or-self::li&apos; data=&apos;&lt;li class=&quot;views-row views-row-20 views-&apos;&gt;, &lt;Selector xpath=&apos;descendant-or-self::li&apos; data=&apos;&lt;li class=&quot;views-row views-row-21 views-&apos;&gt;, &lt;Selector xpath=&apos;descendant-or-self::li&apos; data=&apos;&lt;li class=&quot;views-row views-row-22 views-&apos;&gt;, &lt;Selector xpath=&apos;descendant-or-self::li&apos; data=&apos;&lt;li class=&quot;views-row views-row-23 views-&apos;&gt;, &lt;Selector xpath=&apos;descendant-or-self::li&apos; data=&apos;&lt;li class=&quot;views-row views-row-24 views-&apos;&gt;, &lt;Selector xpath=&apos;descendant-or-self::li&apos; data=&apos;&lt;li class=&quot;views-row views-row-25 views-&apos;&gt;, &lt;Selector xpath=&apos;descendant-or-self::li&apos; data=&apos;&lt;li class=&quot;views-row views-row-26 views-&apos;&gt;, &lt;Selector xpath=&apos;descendant-or-self::li&apos; data=&apos;&lt;li class=&quot;views-row views-row-27 views-&apos;&gt;, &lt;Selector xpath=&apos;descendant-or-self::li&apos; data=&apos;&lt;li class=&quot;views-row views-row-28 views-&apos;&gt;, &lt;Selector xpath=&apos;descendant-or-self::li&apos; data=&apos;&lt;li class=&quot;views-row views-row-29 views-&apos;&gt;, &lt;Selector xpath=&apos;descendant-or-self::li&apos; data=&apos;&lt;li class=&quot;views-row views-row-30 views-&apos;&gt;] code items.py 123456789class TutorialItem(scrapy.Item): # define the fields for your item here like: # name = scrapy.Field() name = scrapy.Field() href = scrapy.Field() lic = scrapy.Field() address = scrapy.Field() developer = scrapy.Field() type = scrapy.Field() nbnewhouse.py 1234567891011121314151617181920212223242526272829# -*- coding: utf-8 -*-import scrapyfrom ..items import TutorialItemclass NbnewhouseSpider(scrapy.Spider): name = 'nbnewhouse' allowed_domains = ['cnnbfdc.com'] start_urls = ['http://cnnbfdc.com/'] base_url = 'https://newhouse.cnnbfdc.com/projects/' def start_requests(self): urls = [] page = 6 for i in range(page): urls.append(NbnewhouseSpider.base_url + 'projects?page=%s' % i) for url in urls: yield scrapy.Request(url=url, callback=self.parse) def parse(self, response): projects = response.xpath("//div[@class='group-right']") for item in projects: tutorialItem = TutorialItem() tutorialItem['name'] = item.xpath("div/a/text()").extract()[0].strip() tutorialItem['href'] = item.xpath('div/a/@href').extract()[0].strip() tutorialItem['lic'] = item.xpath("div[2]/text()").extract()[0].strip() tutorialItem['address'] = item.xpath("div[3]/div/div[1]/span/text()").extract()[0].strip() tutorialItem['developer'] = item.xpath("div[3]/div/div[2]/span/text()").extract()[0].strip() tutorialItem['type'] = item.xpath("div")[-1].xpath('text()').extract() yield tutorialItem Charlotte爬虫框架 安装 数据库安装mysql,默认用户名密码:root/root，对应配置修改Charlotte下的setting.py的DATABASES。 安装库安装python3,然后进入工程根目录，执行: 12git clone https://github.com/LiZoRN/Charlotte.gitpip install -r requirements.txt 迁移数据表 12python manage.py makemigrationspython manage.py migrate 爬取IP代理数据(可选) cd 到 spiders/ProxyIp目录，命令行下执行： scrapy crawl xici cd 到 spiders/tools目录，清晰有效ip数据： python proxyip.py 爬取宁波楼盘信息cd 到 spiders/newhouse目录，命令行下执行： scrapy crawl nbnewhouse 运行api服务运行服务： python manage.py runserver api接口如下： 获取新楼盘列表：api/newhouses/?page=2&amp;page_size=51234567891011121314151617181920212223&#123;&quot;data&quot;: [ &#123; &quot;id&quot;: 768, &quot;name&quot;: &quot;宁波金融服务中心北区E栋二期&quot;, &quot;project_state&quot;: &quot;现房状态&quot;, &quot;address&quot;: &quot;东至鼎泰路北至和济街南至规划路西至规划路&quot;, &quot;districts&quot;: &quot;江东区&quot;, &quot;created&quot;: &quot;2017-05-06T02:46:55.063256Z&quot; &#125;, &#123; &quot;id&quot;: 1024, &quot;name&quot;: &quot;嘉恒广场(西区)&quot;, &quot;project_state&quot;: &quot;现房状态&quot;, &quot;address&quot;: &quot;江东区东部新城混合住用区C2-1地块&quot;, &quot;districts&quot;: &quot;江东区&quot;, &quot;created&quot;: &quot;2017-05-06T02:46:55.063256Z&quot; &#125;],&quot;page&quot;: 2,&quot;total&quot;: 799&#125; 1获取楼盘详情：api/newhouses/1/ {“id”: 1,“name”: “万科云鹭湾Ⅱ-6地块二期”,“supervision_bank”: “中国建设银行股份有限公司宁波江北支行”,“supervision_acount”: “33101983736050512431”,“project_state”: “期房状态”,“address”: “”,“dev_company”: “宁波江北万科置业有限公司”,“license_authority”: “”,“sale_permit”: “商品房预售许可证”,“license_key”: “2016”,“online_saleable_area”: “24198.74”,“online_saleable_flats”: “450.00”,“saleable_area”: “372.24”,“saleable_flats”: “29.00”,“sold_area”: “23826.50”,“sold_flats”: “421.00”,“residential_area”: “0.00”,“residential_flats”: “0.00”,“sold_residential_area”: “21188.42”,“sold_residential_flats”: “214.00”,“reserve_area”: “0.00”,“reserve_flats”: “0.00”,“saleable_parking_amount”: “0.00”,“saleable_garage_amount”: “29.00”,“sold_avg_price”: “12234.12”,“districts”: “江北慈城”,“contact_phone”: “”,“remark”: “”,“created”: “2017-05-06T02:46:55.063256Z”} todolist动态脚本反爬虫分布式搜索引擎]]></content>
      <categories>
        <category>开发者手册</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>python</tag>
        <tag>spider</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[区块链导论:以太坊DAPP（投票应用）]]></title>
    <url>%2F2018%2F05%2F22%2Fblockchain-introduce-ethereum-voting%2F</url>
    <content type="text"><![CDATA[投票DAPP投票智能合约 contracts/Voting.sol 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647pragma solidity ^0.4.18;// We have to specify what version of compiler this code will compile withcontract Voting &#123; /* mapping field below is equivalent to an associative array or hash. The key of the mapping is candidate name stored as type bytes32 and value is an unsigned integer to store the vote count */ mapping (bytes32 =&gt; uint8) public votesReceived; /* Solidity doesn&apos;t let you pass in an array of strings in the constructor (yet). We will use an array of bytes32 instead to store the list of candidates */ bytes32[] public candidateList; /* This is the constructor which will be called once when you deploy the contract to the blockchain. When we deploy the contract, we will pass an array of candidates who will be contesting in the election */ function Voting(bytes32[] candidateNames) public &#123; candidateList = candidateNames; &#125; // This function returns the total votes a candidate has received so far function totalVotesFor(bytes32 candidate) view public returns (uint8) &#123; require(validCandidate(candidate)); return votesReceived[candidate]; &#125; // This function increments the vote count for the specified candidate. This // is equivalent to casting a vote function voteForCandidate(bytes32 candidate) public &#123; require(validCandidate(candidate)); votesReceived[candidate] += 1; &#125; function validCandidate(bytes32 candidate) view public returns (bool) &#123; for(uint i = 0; i &lt; candidateList.length; i++) &#123; if (candidateList[i] == candidate) &#123; return true; &#125; &#125; return false; &#125;&#125; 使用node console调试合约打开ganche，使用web3交互。1234567➜ chapter1 git:(master) ✗ node &gt; Web3 = require(&apos;web3&apos;)&#123; [Function: Web3] providers: &#123; HttpProvider: [Function: HttpProvider], IpcProvider: [Function: IpcProvider] &#125; &#125;&gt; web3 = new Web3(new Web3.providers.HttpProvider(&quot;http://localhost:7545&quot;)); 查看区块账号 1234567891011&gt; web3.eth.accounts[ &apos;0x2fa9da84494be487126a2d96794a69c904acdf17&apos;, &apos;0xfbdb68208934c62e78f7e88089f47d0074298a58&apos;, &apos;0x7fbc15bdc47cae7a6f23f854480053b3f63e8783&apos;, &apos;0x2606d31e26b07f7077971810c8f16ed242969f9d&apos;, &apos;0x90b1320cca7320d914a8cf7a04648ac7ebfcfe66&apos;, &apos;0xd5a5a2f92f88f9ec4e3329200fa2f355e83af553&apos;, &apos;0xb7765e9be2577c73ffe6e87843a3290781b87298&apos;, &apos;0xda22e32e230554fbd33541b0187a9071430dbbf6&apos;, &apos;0x8761a81d0e30ab8117e33e741f1b0ddfdb1b000a&apos;, &apos;0x00448bbe603ab4ceb215b9169f7c4f0118aa7896&apos; ] 读取并编译智能合约 123&gt; code = fs.readFileSync(&apos;Voting.sol&apos;).toString()&gt; solc = require(&apos;solc&apos;)&gt; compiledCode = solc.compile(code) 部署智能合约 12345&gt; abiDefinition = JSON.parse(compiledCode.contracts[&apos;:Voting&apos;].interface)&gt; VotingContract = web3.eth.contract(abiDefinition)&gt; byteCode = compiledCode.contracts[&apos;:Voting&apos;].bytecode&gt; deployedContract = VotingContract.new([&apos;Rama&apos;,&apos;Nick&apos;,&apos;Jose&apos;],&#123;data: byteCode, from: web3.eth.accounts[0], gas: 4700000&#125;)&gt; contractInstance = VotingContract.at(deployedContract.address) - compiledCode.contracts[‘:Voting’].bytecode: 合约二进制代码，用于部署到区块链中. - compiledCode.contracts[‘:Voting’].interface: 智能合约接口模板(abi)，告诉合约用户可使用的接口. 调用合约方法123456789&gt; contractInstance.totalVotesFor.call(&apos;Rama&apos;)BigNumber &#123; s: 1, e: 0, c: [ 0 ] &#125;&gt; &gt; contractInstance.voteForCandidate(&apos;Rama&apos;, &#123;from: web3.eth.accounts[0]&#125;)&apos;0xb78beb95dce55f946fe9d3bbe06f3ed588749e2714fa2834e4f0a59f6a2d55d6&apos;&gt; contractInstance.voteForCandidate(&apos;Rama&apos;, &#123;from: web3.eth.accounts[0]&#125;)&apos;0xf0b6291f6eca6e6d314e0c246ec863e74506656c5da70a88f583f80be9dc119b&apos;&gt; contractInstance.totalVotesFor.call(&apos;Rama&apos;).toLocaleString()&apos;2&apos; 0xb78beb95dce55f946fe9d3bbe06f3ed588749e2714fa2834e4f0a59f6a2d55d6是每一次交易发生的transaction id 前端页面 index.html 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Hello World DApp&lt;/title&gt; &lt;link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'&gt; &lt;link href='https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css' rel='stylesheet' type='text/css'&gt;&lt;/head&gt;&lt;body class="container"&gt; &lt;h1&gt;A Simple Hello World Voting Application&lt;/h1&gt; &lt;div class="table-responsive"&gt; &lt;table class="table table-bordered"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;Candidate&lt;/th&gt; &lt;th&gt;Votes&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;Rama&lt;/td&gt; &lt;td id="candidate-1"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Nick&lt;/td&gt; &lt;td id="candidate-2"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Jose&lt;/td&gt; &lt;td id="candidate-3"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;input type="text" id="candidate" /&gt; &lt;a href="#" onclick="voteForCandidate()" class="btn btn-primary"&gt;Vote&lt;/a&gt;&lt;/body&gt;&lt;script src="https://cdn.rawgit.com/ethereum/web3.js/develop/dist/web3.js"&gt;&lt;/script&gt;&lt;script src="https://code.jquery.com/jquery-3.1.1.slim.min.js"&gt;&lt;/script&gt;&lt;script src="./index.js"&gt;&lt;/script&gt;&lt;/html&gt; index.js 1234567891011121314151617181920212223web3 = new Web3(new Web3.providers.HttpProvider("http://localhost:7545"));abi = JSON.parse('[&#123;"constant":false,"inputs":[&#123;"name":"candidate","type":"bytes32"&#125;],"name":"totalVotesFor","outputs":[&#123;"name":"","type":"uint8"&#125;],"payable":false,"type":"function"&#125;,&#123;"constant":false,"inputs":[&#123;"name":"candidate","type":"bytes32"&#125;],"name":"validCandidate","outputs":[&#123;"name":"","type":"bool"&#125;],"payable":false,"type":"function"&#125;,&#123;"constant":true,"inputs":[&#123;"name":"","type":"bytes32"&#125;],"name":"votesReceived","outputs":[&#123;"name":"","type":"uint8"&#125;],"payable":false,"type":"function"&#125;,&#123;"constant":true,"inputs":[&#123;"name":"x","type":"bytes32"&#125;],"name":"bytes32ToString","outputs":[&#123;"name":"","type":"string"&#125;],"payable":false,"type":"function"&#125;,&#123;"constant":true,"inputs":[&#123;"name":"","type":"uint256"&#125;],"name":"candidateList","outputs":[&#123;"name":"","type":"bytes32"&#125;],"payable":false,"type":"function"&#125;,&#123;"constant":false,"inputs":[&#123;"name":"candidate","type":"bytes32"&#125;],"name":"voteForCandidate","outputs":[],"payable":false,"type":"function"&#125;,&#123;"constant":true,"inputs":[],"name":"contractOwner","outputs":[&#123;"name":"","type":"address"&#125;],"payable":false,"type":"function"&#125;,&#123;"inputs":[&#123;"name":"candidateNames","type":"bytes32[]"&#125;],"payable":false,"type":"constructor"&#125;]')VotingContract = web3.eth.contract(abi);// nodejs console中contractInstance.address获得的地址contractInstance = VotingContract.at('0xf7f433a4a2f9bf3f364bb96abe6a07778a61e095');candidates = &#123;"Rama": "candidate-1", "Nick": "candidate-2", "Jose": "candidate-3"&#125;function voteForCandidate() &#123; candidateName = $("#candidate").val(); contractInstance.voteForCandidate(candidateName, &#123;from: web3.eth.accounts[0]&#125;, function() &#123; let div_id = candidates[candidateName]; $("#" + div_id).html(contractInstance.totalVotesFor.call(candidateName).toString()); &#125;);&#125;$(document).ready(function() &#123; candidateNames = Object.keys(candidates); for (var i = 0; i &lt; candidateNames.length; i++) &#123; let name = candidateNames[i]; let val = contractInstance.totalVotesFor.call(name).toString() $("#" + candidates[name]).html(val); &#125;&#125;); 以上是不使用框架的智能合约的开发应用。 voting优化创建truffle工程123mkdir votingcd votingtruffle unbox webpack 创建合约植入代码。 migrations/2_deploy_contracts.js12345var VotingContract = artifacts.require(&quot;./Voting.sol&quot;);module.exports = function(deployer) &#123; deployer.deploy(VotingContract,[&apos;Rama&apos;, &apos;Nick&apos;, &apos;Jose&apos;], &#123;gas: 6700000&#125;);&#125;; DAPP前端代码 app/javasripts/app.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// Import the page's CSS. Webpack will know what to do with it.import "../stylesheets/app.css";// Import libraries we need.import &#123; default as Web3&#125; from 'web3';import &#123; default as contract &#125; from 'truffle-contract'import voting_artifacts from '../../build/contracts/Voting.json'var Voting = contract(voting_artifacts);let candidates = &#123;"Rama": "candidate-1", "Nick": "candidate-2", "Jose": "candidate-3"&#125;window.voteForCandidate = function(candidate) &#123; let candidateName = $("#candidate").val(); try &#123; $("#msg").html("Vote has been submitted. The vote count will increment as soon as the vote is recorded on the blockchain. Please wait.") $("#candidate").val(""); /* Voting.deployed() returns an instance of the contract. Every call * in Truffle returns a promise which is why we have used then() * everywhere we have a transaction call */ Voting.deployed().then(function(contractInstance) &#123; contractInstance.voteForCandidate(candidateName, &#123;gas: 140000, from: web3.eth.accounts[0]&#125;).then(function() &#123; let div_id = candidates[candidateName]; return contractInstance.totalVotesFor.call(candidateName).then(function(v) &#123; $("#" + div_id).html(v.toString()); $("#msg").html(""); &#125;); &#125;); &#125;); &#125; catch (err) &#123; console.log(err); &#125;&#125;$( document ).ready(function() &#123; if (typeof web3 !== 'undefined') &#123; console.warn("Using web3 detected from external source like Metamask") // Use Mist/MetaMask's provider window.web3 = new Web3(web3.currentProvider); &#125; else &#123; console.warn("No web3 detected. Falling back to http://localhost:8545. You should remove this fallback when you deploy live, as it's inherently insecure. Consider switching to Metamask for development. More info here: http://truffleframework.com/tutorials/truffle-and-metamask"); // fallback - use your fallback strategy (local node / hosted node + in-dapp id mgmt / fail) window.web3 = new Web3(new Web3.providers.HttpProvider("http://localhost:8545")); &#125; Voting.setProvider(web3.currentProvider); let candidateNames = Object.keys(candidates); for (var i = 0; i &lt; candidateNames.length; i++) &#123; let name = candidateNames[i]; Voting.deployed().then(function(contractInstance) &#123; contractInstance.totalVotesFor.call(name).then(function(v) &#123; $("#" + candidates[name]).html(v.toString()); &#125;); &#125;) &#125;&#125;); app/index.html 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Hello World DApp&lt;/title&gt; &lt;link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'&gt; &lt;link href='https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css' rel='stylesheet' type='text/css'&gt;&lt;/head&gt;&lt;body class="container"&gt; &lt;h1&gt;A Simple Hello World Voting Application&lt;/h1&gt; &lt;div id="address"&gt;&lt;/div&gt; &lt;div class="table-responsive"&gt; &lt;table class="table table-bordered"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;Candidate&lt;/th&gt; &lt;th&gt;Votes&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;Rama&lt;/td&gt; &lt;td id="candidate-1"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Nick&lt;/td&gt; &lt;td id="candidate-2"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Jose&lt;/td&gt; &lt;td id="candidate-3"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;div id="msg"&gt;&lt;/div&gt; &lt;/div&gt; &lt;input type="text" id="candidate" /&gt; &lt;a href="#" onclick="voteForCandidate()" class="btn btn-primary"&gt;Vote&lt;/a&gt;&lt;/body&gt;&lt;script src="https://code.jquery.com/jquery-3.1.1.slim.min.js"&gt;&lt;/script&gt;&lt;script src="app.js"&gt;&lt;/script&gt;&lt;/html&gt; 编译部署智能合约:123456789101112131415161718➜ voting git:(master) ✗ truffle compile➜ voting git:(master) ✗ truffle migrate➜ voting git:(master) ✗ truffle consoletruffle(development)&gt; Voting.deployed().then(function(contractInstance) &#123;contractInstance.voteForCandidate(&apos;Rama&apos;).then(function(v) &#123;console.log(v)&#125;)&#125;)undefinedtruffle(development)&gt; &#123; tx: &apos;0xe2ef29e4a6d02ff1217148e3038ba3edcf815840d4400dd8895a5c2497a6e239&apos;, receipt: &#123; transactionHash: &apos;0xe2ef29e4a6d02ff1217148e3038ba3edcf815840d4400dd8895a5c2497a6e239&apos;, transactionIndex: 0, blockHash: &apos;0x19066839d607b6a7f842c026a11fe130474dce2b62f5d0e9c9f2f2d48d286963&apos;, blockNumber: 5, gasUsed: 43411, cumulativeGasUsed: 43411, contractAddress: null, logs: [], status: &apos;0x01&apos;, logsBloom: &apos;0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000&apos; &#125;, logs: [] &#125; 运行应用npm run dev 登录metamask进行应用访问： 代码12git clone https://github.com/LiZoRN/BlockChain.gitgit checkout v1.0 投票v2版本一般在选举中，每一个选民只能投出一票给候选人。但假设你是一家公司的股东，你可能需要会有这样的要求：票数按拥有的股票数来定。 项目目标 学习使用数据类型Struct用来组织和存储区块链上的数据 学习票据(tokens)的概念并应用到本项目 功能说明 票据(tokens):表示可用于投票的总票数 每一个选民使用货币（eth）来购买票据用于投票 你可以查看投票信息： 每个候选人拥有多少tokens 自己所投的token情况 候选人不再指定，从整条链上获取。 智能合约123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133pragma solidity ^0.4.18; //We have to specify what version of the compiler this code will usecontract Voting &#123; // We use the struct datatype to store the voter information. struct voter &#123; address voterAddress; // The address of the voter uint tokensBought; // The total no. of tokens this voter owns uint[] tokensUsedPerCandidate; // Array to keep track of votes per candidate. /* We have an array of candidates initialized below. Every time this voter votes with her tokens, the value at that index is incremented. Example, if candidateList array declared below has ["Rama", "Nick", "Jose"] and this voter votes 10 tokens to Nick, the tokensUsedPerCandidate[1] will be incremented by 10. */ &#125; /* mapping is equivalent to an associate array or hash The key of the mapping is candidate name stored as type bytes32 and value is an unsigned integer which used to store the vote count */ mapping (address =&gt; voter) public voterInfo; /* Solidity doesn't let you return an array of strings yet. We will use an array of bytes32 instead to store the list of candidates */ mapping (bytes32 =&gt; uint) public votesReceived; bytes32[] public candidateList; uint public totalTokens; // Total no. of tokens available for this election uint public balanceTokens; // Total no. of tokens still available for purchase uint public tokenPrice; // Price per token /* When the contract is deployed on the blockchain, we will initialize the total number of tokens for sale, cost per token and all the candidates */ function Voting(uint tokens, uint pricePerToken, bytes32[] candidateNames) public &#123; candidateList = candidateNames; totalTokens = tokens; balanceTokens = tokens; tokenPrice = pricePerToken; &#125; function totalVotesFor(bytes32 candidate) view public returns (uint) &#123; return votesReceived[candidate]; &#125; /* Instead of just taking the candidate name as an argument, we now also require the no. of tokens this voter wants to vote for the candidate */ function voteForCandidate(bytes32 candidate, uint votesInTokens) public &#123; uint index = indexOfCandidate(candidate); require(index != uint(-1)); // msg.sender gives us the address of the account/voter who is trying // to call this function if (voterInfo[msg.sender].tokensUsedPerCandidate.length == 0) &#123; for(uint i = 0; i &lt; candidateList.length; i++) &#123; voterInfo[msg.sender].tokensUsedPerCandidate.push(0); &#125; &#125; // Make sure this voter has enough tokens to cast the vote uint availableTokens = voterInfo[msg.sender].tokensBought - totalTokensUsed(voterInfo[msg.sender].tokensUsedPerCandidate); require(availableTokens &gt;= votesInTokens); votesReceived[candidate] += votesInTokens; // Store how many tokens were used for this candidate voterInfo[msg.sender].tokensUsedPerCandidate[index] += votesInTokens; &#125; // Return the sum of all the tokens used by this voter. function totalTokensUsed(uint[] _tokensUsedPerCandidate) private pure returns (uint) &#123; uint totalUsedTokens = 0; for(uint i = 0; i &lt; _tokensUsedPerCandidate.length; i++) &#123; totalUsedTokens += _tokensUsedPerCandidate[i]; &#125; return totalUsedTokens; &#125; function indexOfCandidate(bytes32 candidate) view public returns (uint) &#123; for(uint i = 0; i &lt; candidateList.length; i++) &#123; if (candidateList[i] == candidate) &#123; return i; &#125; &#125; return uint(-1); &#125; /* This function is used to purchase the tokens. Note the keyword 'payable' below. By just adding that one keyword to a function, your contract can now accept Ether from anyone who calls this function. Accepting money can not get any easier than this! */ function buy() payable public returns (uint) &#123; uint tokensToBuy = msg.value / tokenPrice; require(tokensToBuy &lt;= balanceTokens); voterInfo[msg.sender].voterAddress = msg.sender; voterInfo[msg.sender].tokensBought += tokensToBuy; balanceTokens -= tokensToBuy; return tokensToBuy; &#125; function tokensSold() view public returns (uint) &#123; return totalTokens - balanceTokens; &#125; function voterDetails(address user) view public returns (uint, uint[]) &#123; return (voterInfo[user].tokensBought, voterInfo[user].tokensUsedPerCandidate); &#125; /* All the ether sent by voters who purchased the tokens is in this contract's account. This method will be used to transfer out all those ethers in to another account. *** The way this function is written currently, anyone can call this method and transfer the balance in to their account. In reality, you should add check to make sure only the owner of this contract can cash out. */ function transferTo(address account) public &#123; account.transfer(this.balance); &#125; function allCandidates() view public returns (bytes32[]) &#123; return candidateList; &#125;&#125; migrations/2_deploy_contracts.js1deployer.deploy(Voting, 1000, web3.toWei(&apos;0.1&apos;, &apos;ether&apos;), [&apos;Rama&apos;, &apos;Nick&apos;, &apos;Jose&apos;]); 重新部署智能合约12truffle compiletruffle migrate --reset 启动工程:npm run dev 完成代码12git clone https://github.com/LiZoRN/BlockChain.gitgit checkout v2.0]]></content>
      <categories>
        <category>开发者手册</category>
      </categories>
      <tags>
        <tag>区块链</tag>
        <tag>blockchain</tag>
        <tag>Ethereum</tag>
        <tag>以太坊</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[区块链导论:以太坊DAPP（宠物店应用）]]></title>
    <url>%2F2018%2F05%2F22%2Fblockchain-introduce-ethereum-pet-shop%2F</url>
    <content type="text"><![CDATA[宠物领养应用是Truffle自带的一个教程应用，通过本教程你将学到以下内容： 使用Truffle Box来创建Truffle工程 编写智能合约 编译部署智能合约 测试智能合约 创建一个可与智能合约交互的用户接口 浏览器内访问DAPP 使用Truffle Box来创建Truffle工程1mkdir pet-shop 编写和测试智能合约 创建文件contracts/Adoption.sol 1234567891011121314151617pragma solidity ^0.4.17;contract Adoption &#123; address[16] public adopters; // 领养宠物 function adopt(uint petId) public returns (uint) &#123; require(petId &gt;= 0 &amp;&amp; petId &lt;= 15); adopters[petId] = msg.sender; return petId; &#125; // Retireving the adopters function getAdopters() public view returns (address[16]) &#123; return adopters; &#125;&#125; 编写测试代码,’test/TestAdoption.sol’ 123456789101112131415161718192021222324252627pragma solidity ^0.4.17;import &quot;truffle/Assert.sol&quot;;import &quot;truffle/DeployedAddresses.sol&quot;;import &quot;../contracts/Adoption.sol&quot;;contract TestAdoption &#123; Adoption adoption = Adoption(DeployedAddresses.Adoption()); // Testing the adopt() function function testUserCanAdoptPet() public &#123; uint returnedId = adoption.adopt(8); uint expected = 8; Assert.equal(returnedId, expected, &quot;Adoption of pet ID 8 should be recorded.&quot;); &#125; // Testing retrieval of all pet owners function testGetAdopterAddressByPetIdInArray() public &#123; // Expected owner is this contract address expected = this; // Store adopters in memory rather than contract&apos;s storage address[16] memory adopters = adoption.getAdopters(); Assert.equal(adopters[8], expected, &quot;Owner of pet ID 8 should be recorded.&quot;); &#125;&#125; Assert.sol：单元测试的assert方法,具体查看 DeployedAddresses.sol: 执行truffle测试用例，truffle会部署一个新的合约用力到区块链中，这个合约用户获得被部署的合约 执行测试。12345678910111213141516➜ pet-shop-tutorial truffle testUsing network &apos;development&apos;.Compiling ./contracts/Adoption.sol...Compiling ./test/TestAdoption.sol...Compiling truffle/Assert.sol...Compiling truffle/DeployedAddresses.sol... TestAdoption ✓ testUserCanAdoptPet (197ms) ✓ testGetAdopterAddressByPetId (165ms) ✓ testGetAdopterAddressByPetIdInArray (333ms) 3 passing (2s) 构建前端应用页面 打开/src/js/app.js，替换replace me代码段。 initWeb3 12345678// Is there an injected web3 instance?if (typeof web3 !== &apos;undefined&apos;) &#123; App.web3Provider = web3.currentProvider;&#125; else &#123; // If no injected web3 instance is detected, fall back to Ganache App.web3Provider = new Web3.providers.HttpProvider(&apos;http://localhost:7545&apos;);&#125;web3 = new Web3(App.web3Provider); 判断web3实例是否存在(Mist或者MentaMask)，如果存在则返回实例，不存在就新建。 initContract 1234567891011$.getJSON(&apos;Adoption.json&apos;, function(data) &#123; // 获取合约文件并使用truffle-contract方法实例化 var AdoptionArtifact = data; App.contracts.Adoption = TruffleContract(AdoptionArtifact); // 将智能合约实例加载到服务容器中，此处是web3Providers App.contracts.Adoption.setProvider(App.web3Provider); // 使用合约来获取和标记被领养的宠物 return App.markAdopted();&#125;); markAdopted 123456789101112131415var adoptionInstance;App.contracts.Adoption.deployed().then(function(instance) &#123; adoptionInstance = instance; return adoptionInstance.getAdopters.call();&#125;).then(function(adopters) &#123; for (i = 0; i &lt; adopters.length; i++) &#123; if (adopters[i] !== &apos;0x0000000000000000000000000000000000000000&apos;) &#123; $(&apos;.panel-pet&apos;).eq(i).find(&apos;button&apos;).text(&apos;Success&apos;).attr(&apos;disabled&apos;, true); &#125; &#125;&#125;).catch(function(err) &#123; console.log(err.message);&#125;); 使用getAdopters方法获得所有被领养的宠物，并将对应领养按钮设为disable。 handleAdopt 123456789101112131415161718var adoptionInstance;web3.eth.getAccounts(function(error, accounts) &#123; if (error) &#123; console.log(error); &#125;// 获取当前账户var account = accounts[0]; App.contracts.Adoption.deployed().then(function(instance) &#123; adoptionInstance = instance; // Execute adopt as a transaction by sending account return adoptionInstance.adopt(petId, &#123;from: account&#125;); &#125;).then(function(result) &#123; return App.markAdopted(); &#125;).catch(function(err) &#123; console.log(err.message); &#125;);&#125;); 运行web server1npm run dev 完整代码pet-shop issue 修改DAPP的index.html，将&lt;script src=&quot;https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js&quot;&gt;&lt;/script&gt;替换为https://cdn.bootcss.com/jquery/1.12.4/jquery.min.js]]></content>
      <categories>
        <category>开发者手册</category>
      </categories>
      <tags>
        <tag>区块链</tag>
        <tag>blockchain</tag>
        <tag>Ethereum</tag>
        <tag>以太坊</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[区块链导论:以太坊（Ethereum）]]></title>
    <url>%2F2018%2F05%2F22%2Fblockchain-introduce-2%2F</url>
    <content type="text"><![CDATA[以太坊（Ethereum）是一个开源的有智能合约功能的公共区块链平台。通过其专用加密货币以太币（Ether）提供去中心化的虚拟机（“以太虚拟机” Ethereum Virtual Machine）来处理点对点合约。 关于以太坊（Ethereum）的概念网上有很多资料可以查询，本文只上干货，主要目的如下： 搭建Ethereum的开发环境 熟悉Ethereum DAPP开发框架:Truffle Truffle DAPP开发和调试 以太坊开发环境搭建安装区块链仿真环境(ganache)、solidity编译器、web3、truffle。 1npm install -g ganache-cli solc web3 truffle IDE Atom 安装linter-solidity插件。 12$ apm install linter$ apm install linter-solidity ethereum客户端这里使用Metamask,下载对应的浏览器版本，安装到浏览器的插件里。 选择Custom RPC加入本地ganche私有链-“http://127.0.0.1:7545&quot;。 开启环境 开启仿真环境ganache metamask连接私有链Customer Rpc -&gt; http://127.0.0.1:7545 TruffleTruffle是一个世界级的开发环境，测试框架，以太坊的资源管理通道，致力于让以太坊上的开发变得简单，Truffle有以下功能： 内置的智能合约编译，链接，部署和二进制文件的管理。 快速开发下的自动合约测试。 脚本化的，可扩展的部署与发布框架。 部署到不管多少的公网或私网的网络环境管理功能 使用EthPM&amp;NPM提供的包管理，使用ERC190标准。 与合约直接通信的直接交互控制台（写完合约就可以命令行里验证了）。 可配的构建流程，支持紧密集成。 在Truffle环境里支持执行外部的脚本。 Truffle 开发部署合约 创建工程 123mkdir fibonaccicd fibonaccitruffle init 工程目录结构如下：app/ - 你的应用文件运行的默认目录。这里面包括推荐的javascript文件和css样式文件目录，但你可以完全决定如何使用这些目录。contract/ - Truffle默认的合约文件存放地址。migrations/ - 存放发布脚本文件test/ - 用来测试应用和合约的测试文件truffle.js - Truffle的配置文件 编写一个基础智能合约 创建一个合约contracts/Fibonacci.sol: 12345678910111213141516pragma solidity ^0.4.22;contract Fibonacci &#123;uint[] fibseries; // n = how many in the series to return function generateFib(uint n) public &#123; // set 1st and 2nd entries fibseries.push(1); fibseries.push(1); // generate subsequent entries for (uint i=2; i &lt; n ; i++) &#123; fibseries.push(fibseries[i-1] + fibseries[i-2]); &#125; &#125;&#125; generateFib:生成Fibonacci（斐波纳契）数列，公式fib(n)=fib(n-1)+fib(n-2)。 创建一个新的部署文件migrations/2_deploy_contracts.js。 12345var Fibonacci = artifacts.require("Fibonacci");module.exports = function(deployer) &#123; deployer.deploy(Fibonacci);&#125;; 启动Ganache 修改工程目录下的truffle.js 123456789module.exports = &#123; networks: &#123; development: &#123; host: &quot;127.0.0.1&quot;, port: 7545, network_id: &quot;*&quot; &#125; &#125;&#125;; 编译并植入合约12345678910111213141516171819truffle compiletruffle migrateUsing network &apos;development&apos;.Running migration: 1_initial_migration.js Deploying Migrations... ... 0x97f35c60501091e10315febe0d2f1d8a59cb413c38cc7c2b3538263a7c67d0bf Migrations: 0xf7f433a4a2f9bf3f364bb96abe6a07778a61e095Saving successful migration to network... ... 0x17b700e3a580ddd28d7bb7110c33f5a8c94b8875c99138d466f8625056a47cd9Saving artifacts...Running migration: 2_deploy_contracts.js Deploying Fibonacci... ... 0xd1f02be04a76df173456b48777d740f65248cd5870c4e22c058cc6f658dc2f9e Fibonacci: 0xc9554c5818dac7e79dc398d85c4789b90618c5b7Saving successful migration to network... ... 0xb987be952d829ca21a909e2f558abdae84cf6afe0c83c2070ab2ba8319f79672Saving artifacts... console debug我们可以直接使用remix ide，调试非常的方便。这里我们虐一下自己，使用Truffle Console来进行调试。 进入console truffle console 调用合约 1234567891011121314truffle(development)&gt; Fibonacci.deployed().then(function(instance)&#123;return instance.generateFib(10);&#125;);&#123; tx: &apos;0x0d10a3f875548131fdad0a27f916af5575fcf6ee47085e9d625d695eb2c11583&apos;, receipt: &#123; transactionHash: &apos;0x0d10a3f875548131fdad0a27f916af5575fcf6ee47085e9d625d695eb2c11583&apos;, transactionIndex: 0, blockHash: &apos;0x7596a7239811b8586a2c60a9fad19d41ea8bb3be46e8ed3b8ebbfaf4c477b707&apos;, blockNumber: 5, gasUsed: 298373, cumulativeGasUsed: 298373, contractAddress: null, logs: [], status: &apos;0x01&apos;, logsBloom: &apos;0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000&apos; &#125;, logs: [] &#125; 调试transaction 先attache一条transaction，id为transactionHash值。 1234567891011121314151617truffle(development)&gt; debug 0x0d10a3f875548131fdad0a27f916af5575fcf6ee47085e9d625d695eb2c11583Compiling ./contracts/Fibonacci.sol...Compiling ./contracts/Migrations.sol...Gathering transaction data...Addresses affected: 0xc9554c5818dac7e79dc398d85c4789b90618c5b7 - FibonacciCommands:(enter) last command entered (step next)(o) step over, (i) step into, (u) step out, (n) step next(;) step instruction, (p) print instruction, (h) print this help, (q) quit(b) toggle breakpoint, (c) continue until breakpoint(+) add watch expression (`+:&lt;expr&gt;`), (-) remove watch expression (-:&lt;expr&gt;)(?) list existing watch expressions(v) print variables and values, (:) evaluate expression - see `v` Commands即为调试命令行。 watch（+:）变量,按n逐行进行跟踪。 123456789101112131415161718debug(development:0x0d10a3f8...)&gt; +:i8debug(development:0x0d10a3f8...)&gt; +:fibseries[ 1, 1, 2, 3, 5, 8, 13, 21 ]debug(development:0x0d10a3f8...)&gt; nFibonacci.sol:14: // generate subsequent entries15: for (uint i=2; i &lt; n ; i++) &#123;16: fibseries.push(fibseries[i-1] + fibseries[i-2]); ^ :i 8:fibseries [ 1, 1, 2, 3, 5, 8, 13, 21 ] 异常信息调试 修改以下合约代码 123...for (uint i=1; i &lt; n ; i++) &#123;... 重新编译部署合约 1234567891011121314151617181920212223242526272829303132debug(development:0x65bb45af...)&gt; compile --allTransaction completed successfully.truffle(development)&gt; migrate --resetCompiling ./contracts/Fibonacci.sol...Writing artifacts to ./build/contractsUsing network &apos;development&apos;.Running migration: 1_initial_migration.js Replacing Migrations... ... 0x26fdc5c20b9f44e96e537e0b8474f867d7bd7d27ad7172b004c858d2dceb6f99 Migrations: 0xd0ea55247c6035375c6e284a60946cd35550ced2Saving successful migration to network... ... 0x0ad76d3073b05161327fc1f7dbd1c521360c305af872ff12b7f59befb73dfbd2Saving artifacts...Running migration: 2_deploy_contracts.js Replacing Fibonacci... ... 0x93ee91146a3a5fd23dad1e77249870c0edeb5cf6cd78cb7c9db6aab24f538634 Fibonacci: 0x090b1fd13ee19ec7f8f3175ca54d5165a443c694Saving successful migration to network... ... 0xbeb0d613fa72c67ecf720833a4985244a91b0d0dea1c36fc23195e00e7fd8c18Saving artifacts...truffle(development)&gt; Fibonacci.deployed().then(function(instance)&#123;return instance.generateFib(10);&#125;);Error: VM Exception while processing transaction: invalid opcode at XMLHttpRequest._onHttpResponseEnd (/home/lizorn/.nvm/versions/node/v10.0.0/lib/node_modules/truffle/build/webpack:/~/xhr2/lib/xhr2.js:509:1) at XMLHttpRequest._setReadyState (/home/lizorn/.nvm/versions/node/v10.0.0/lib/node_modules/truffle/build/webpack:/~/xhr2/lib/xhr2.js:354:1) at XMLHttpRequestEventTarget.dispatchEvent (/home/lizorn/.nvm/versions/node/v10.0.0/lib/node_modules/truffle/build/webpack:/~/xhr2/lib/xhr2.js:64:1) at XMLHttpRequest.request.onreadystatechange (/home/lizorn/.nvm/versions/node/v10.0.0/lib/node_modules/truffle/build/webpack:/~/web3/lib/web3/httpprovider.js:128:1) at /home/lizorn/.nvm/versions/node/v10.0.0/lib/node_modules/truffle/build/webpack:/~/truffle-provider/wrapper.js:134:1 at /home/lizorn/.nvm/versions/node/v10.0.0/lib/node_modules/truffle/build/webpack:/~/web3/lib/web3/requestmanager.js:86:1 at Object.InvalidResponse (/home/lizorn/.nvm/versions/node/v10.0.0/lib/node_modules/truffle/build/webpack:/~/web3/lib/web3/errors.js:38:1) 此处由于数组越界，控制窗口并没有返回transaction的ID，我们可以通过查看Ganache的Logs，找到对应的Transaction，然后按之前的方式进行调试。]]></content>
      <categories>
        <category>开发者手册</category>
      </categories>
      <tags>
        <tag>区块链</tag>
        <tag>blockchain</tag>
        <tag>Ethereum</tag>
        <tag>以太坊</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python&数据库]]></title>
    <url>%2F2018%2F05%2F11%2Fpython-database-develop%2F</url>
    <content type="text"><![CDATA[Sql定义SQL是一种数据库查询和程序设计语言，用于存取数据以及查询、更新和管理关系数据库系统。 特点： 是一种高级的非过程化编程语言，允许用户在高层数据结构上工作。 它不要求用户指定对数据的存放方法，也不需要用户了解具体的数据存放方式。 结构化查询语言语句可以嵌套，这使它具有极大的灵活性和强大的功能。 组成SQL由六个部分组成： 数据查询语言（DQL） 数据操作语言（DML） 事务处理语言（TPL） 数据控制语言（DCL） 数据定义语言（DDL） 针控制语言（CCL） RMDB定义RDBMS（关系型数据库): R, 即 “Relational” (有关系，关联的),是其中内容最丰富的部分. 数据通过 表 (table) 进行组织,每张表都是一些由 类型 (type) 相关联的 列 (column) 构成. 所有表,列及其类的类型被称为数据库的 schema (架构或模式). schema 通过每张表的描述信息完整刻画了数据库的结构. 比如, 一张叫做 Car 的表可能有以下一些列: 12345Make: a stringModel: a stringYear: a four-digit number; alternatively, a dateColor: a stringVIN(Vehicle Identification Number): a string 在一张表中,每个单一的条目叫做一行(row)或者一条记录(record). 为了区分每条记录, 通常会定义一个 主键 (primary key).表中的主键是其中一列, 它能够唯一标识每一行. 在表 Car 中, VIN 是一个天然的主键选择, 因为它能够保证每辆车具有唯一的标识. Schemasschema , 描述了列的名字及其所包含数据的类型。它还包括了其他一些信息， 比如哪些列可以为空， 哪些列不允许有重复值， 以及其他对表中列的所有限制信息。 在任意时刻一张表只能有一个 schema, 并且 表中的所有行必须遵守 schema 的规定 。 如果在传统的关系型数据库中，因为业务的需求需要新增一些字段，就需要变更表-添加新的列，对一个大型数据库做一些改变通常并不是一件小事。DBA需要做大量的schema维护工作。 QueryingSQL 能够让我们通过对数据库进行query (查询)来获取有用的信息.查询简单来说, 查询就是用一个结构化语言向 RDBMS 提问,返回的行就是问题的答案. 我们可以通过在数据库上进行如下的 SQL 查询 : 1SELECT Make, Model FROM Car; 将SQL大致翻译成中文: 向我展示(SELECT)表 Car(FROM) 每一行中 Make 和 Model 的值. 查询特定的表，使用表的主键VIN来标示唯一的一辆车: 1SELECT * FROM Car WHERE VIN = '2134AFGER245267' Relations数据库设计三大范式： 第一范式:确保每列的原子性. 第二范式:确保表中的每列都和主键相关. 确保每列都和主键列直接相关,而不是间接相关. ServiceHistory 表: 1VIN | Make | Model | Year | Color | Service Performed | Mechanic | Price | Date -&gt;Vehicle+ServiceHistory表 1VIN | Make | Model | Year | Color 1VIN | Service Performed | Mechanic | Price | Date 对两表做关联查询，如果数据库没有建立索引(indices),上面的查询就需要进行表扫描(table scan). NOSQLNOSQL数据库分类分类 Examples举例 典型应用场景 数据模型 优点 缺点 分类 Examples举例 典型应用场景 数据模型 优点 缺点 键值 Tokyo Cabinet/Tyrant, Redis, Voldemort, Oracle BDB 内容缓存，主要用于处理大量数据的高访问负载，也用于一些日志系统等等。 Key 指向 Value 的键值对，通常用hash table来实现 查找速度快 数据无结构化，通常只被当作字符串或者二进制数据 列存储数据库 Cassandra, HBase, Riak 分布式的文件系统 以列簇式存储，将同一列数据存在一起 centered $12 文档型数据库 CouchDB, MongoDb，SequoiaDB Web应用（与Key-Value类似，Value是结构化的，不同的是数据库能够了解Value的内容） Key-Value对应的键值对，Value为结构化数据 数据结构要求不严格，表结构可变，不需要像关系型数据库一样需要预先定义表结构 查询性能不高，而且缺乏统一的查询语法。 图形(Graph)数据库 Neo4J, InfoGrid, Infinite Graph 社交网络，推荐系统等。专注于构建关系图谱 图结构 利用图结构相关算法。比如最短路径寻址，N度关系查找等 很多时候需要对整个图做计算才能得出需要的信息，而且这种结构不太好做分布式的集群方案。 RMDB vs NOSQL-DB关系型数据库优点 事务处理—保持数据的一致性； 由于以标准化为前提，数据更新的开销很小（相同的字段基本上只有一处）； 可以进行Join等复杂查询 缺点： 扩展困难：由于存在类似Join这样多表查询机制，使得数据库在扩展方面很艰难; 读写慢：这种情况主要发生在数据量达到一定规模时由于关系型数据库的系统逻辑非常复杂，使得 其 非常容易发生死锁等的并发问题，所以导致其读写速度下滑非常严重; 成本高：企业级数据库的License价格很惊人，并且随着系统的规模，而不断上升; 有限的支撑容量：现有关系型解决方案还无法支撑Google这样海量的数据存储; 非关系型数据库优点： 简单的扩展：比如Cassandra的架构类似于P2P，所以能通过轻松地添加新的节点来扩展这个集群; 快速的读写：比如Redis，由于其逻辑简单，且支持内存，使得其性能非常出色，单节点每秒可以处理超过10万次读写操作; 低廉的成本：这是大多数分布式数据库共有的特点，因为主要都是开源软件，没有昂贵的License成本; 缺点： 不提供对SQL的支持：如果不支持SQL这样的工业标准，将会对用户产生一定的学习和应用迁移成本; 支持的特性不够丰富：现有产品所提供的功能都比较有限，大多数NoSQL数据库都不支持事务，也不像MS SQL和Oracle那样能提供各种附加功能，比如BI和报表等; 现有产品的不够成熟：大多数产品都还处于初创期，和关系型数据库几十年的完善不可同日而语; 主流数据库 ORM定义orm英文全称object relational mapping,就是对象映射关系程序，简单来说我们类似python这种面向对象的程序来说一切皆对象，但是我们使用的数据库却都是关系型的，为了保证一致的使用习惯，通过orm将编程语言的对象模型和数据库的关系模型建立映射关系，这样我们在使用编程语言对数据库进行操作的时候可以直接使用编程语言的对象模型进行操作就可以了，而不用直接使用sql语言。 优点：ORM的核心：隐藏了数据访问细节。它使得我们的通用数据库交互变得简单易行，不用熟悉SQL语句以及数据库的异构性。ORM使我们构造固化数据结构变得简单易行。 缺点：无可避免的，自动化意味着映射和关联管理，代价是牺牲性能。现在的各种ORM框架都在尝试使用各种方法来减轻这块（LazyLoad，Cache），效果还是很显著的。 Python ORM库SQAlchemy安装12pip install SQAlchemypip install pymysql 架构 示例代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152from sqlalchemy import Column, DateTime, String, Integer, ForeignKey, funcfrom sqlalchemy.orm import relationship, backreffrom sqlalchemy.ext.declarative import declarative_baseBase = declarative_base()class Department(Base): __tablename__ = 'department' id = Column(Integer, primary_key=True) name = Column(String(50) )class Employee(Base): __tablename__ = 'employee' id = Column(Integer, primary_key=True) name = Column(String(50)) # Use default=func.now() to set the default hiring time # of an Employee to be the current time when an # Employee record was created hired_on = Column(DateTime, default=func.now()) department_id = Column(Integer, ForeignKey('department.id')) # Use cascade='delete,all' to propagate the deletion of a Department onto its Employees department = relationship( Department, backref=backref('employees', uselist=True, cascade='delete,all'))from sqlalchemy import create_engineengine = create_engine('mysql+pymysql://root:root@localhost:3306/test')from sqlalchemy.orm import sessionmakersession = sessionmaker()session.configure(bind=engine)Base.metadata.create_all(engine)if __name__ == '__main__': # # 创建session对象: session = session() # 创建新User对象: new_user = Employee(id='5', name='Bob') # 添加到session: session.add(new_user) # 提交即保存到数据库: session.commit() # 关闭session: session.close() 练习：写一个轻量级的数据库设计思路： 一个 Python 的 dict 作为主要的数据存储 仅支持 string 类型作为键 (key) 支持存储 integer, string 和 list 简单 TCP/IP 服务器用来传递消息 一些像 INCREMENT, DELETE , APPEND 和 STATS 这样的高级命令 所需支持的命令行123456789101112131415161718192021PUT参数： Key, Value目的： 向数据库中插入一条新的条目GET参数： Key目的： 从数据库中检索一个已存储的值PUTLIST参数： Key, Value目的： 向数据库中插入一个新的列表条目APPEND参数： Key, Value目的： 向数据库中一个已有的列表添加一个新的元素INCREMENT参数： key目的： 增长数据库的中一个整型值DELETE参数： Key目的： 从数据库中删除一个条目STATS参数： 无 (N/A)目的： 请求每个执行命令的 成功/失败 的统计信息 消息结构请求消息一条 请求消息 (Request Message) 包含了一个命令（command），一个键 (key), 一个值 (value), 一个值的类型（type）. 后三个取决于消息类型，是可选项, 非必须。; 被用作是分隔符。即使并没有包含上述可选项， 但是在消息中仍然必须有三个 ; 字符。 12COMMAND; [KEY]; [VALUE]; [VALUE TYPE] COMMAND 是上面列表中的命令之一 KEY 是一个可以用作数据库 key 的 string （可选） VALUE 是数据库中的一个 integer, list 或 string (可选) list 可以被表示为一个用逗号分隔的一串 string, 比如说, “red, green, blue” VALUE TYPE 描述了 VALUE 应该被解释为什么类型 可能的类型值有：INT, STRING, LIST 示例12345678&quot;PUT; foo; 1; INT&quot;&quot;GET; foo;;&quot;&quot;PUTLIST; bar; a,b,c ; LIST&quot;&quot;APPEND; bar; d; STRING&quot;&quot;GETLIST; bar; ;&quot;STATS; ;;INCREMENT; foo;;DELETE; foo;; 响应消息一个 响应消息 (Reponse Message) 包含了两个部分， 通过 ; 进行分隔。第一个部分总是 True|False , 它取决于所执行的命令是否成功。 第二个部分是命令消息 (command message),当出现错误时，便会显示错误信息。对于那些执行成功的命令，如果我们不想要默认的返回值（比如 PUT）, 就会出现成功的信息。 如果我们返回成功命令的值 (比如 GET), 那么第二个部分就会是自身值。 Examples123456True; Key [foo] set to [1]True; 1True; Key [bar] set to [[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]]True; Key [bar] had value [d] appendedTrue; [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;]True; &#123;&apos;PUTLIST&apos;: &#123;&apos;success&apos;: 1, &apos;error&apos;: 0&#125;, &apos;STATS&apos;: &#123;&apos;success&apos;: 0, &apos;error&apos;: 0&#125;, &apos;INCREMENT&apos;: &#123;&apos;success&apos;: 0, &apos;error&apos;: 0&#125;, &apos;GET&apos;: &#123;&apos;success&apos;: 0, &apos;error&apos;: 0&#125;, &apos;PUT&apos;: &#123;&apos;success&apos;: 0, &apos;error&apos;: 0&#125;, &apos;GETLIST&apos;: &#123;&apos;success&apos;: 1, &apos;error&apos;: 0&#125;, &apos;APPEND&apos;: &#123;&apos;success&apos;: 1, &apos;error&apos;: 0&#125;, &apos;DELETE&apos;: &#123;&apos;success&apos;: 0, &apos;error&apos;: 0&#125;&#125; 示例代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192# coding : utf-8import socketimport timeHOST = 'localhost'PORT = 6666SOCKET = socket.socket(socket.AF_INET, socket.SOCK_STREAM)# 状态字典STATS = &#123; 'PUT': &#123; 'success': 0, 'error': 0 &#125;, 'GET': &#123; 'success': 0, 'error': 0 &#125;, 'GETLIST': &#123; 'success': 0, 'error': 0 &#125;, 'PUTLIST': &#123; 'success': 0, 'error': 0 &#125;, 'INCREMENT': &#123; 'success': 0, 'error': 0 &#125;, 'APPEND': &#123; 'success': 0, 'error': 0 &#125;, 'DELETE': &#123; 'success': 0, 'error': 0 &#125;, 'STATS': &#123; 'success': 0, 'error': 0 &#125;,&#125;DATA = &#123;&#125;def parse_message(data): """解析命令行，输出元组(command, key, value).""" try: command, key, value, value_type = map(str.strip, data.strip().split(';')) except: return 'Invalid input! Expected: COMMAND; [KEY]; [VALUE]; [VALUE TYPE]' if value_type: if value_type == 'LIST': value = value.split(',') elif value_type == 'INT': value = int(value) else: value = None return command, key, valuedef update_stats(command, success): """更新命令状态码""" # todo if success: STATS[command]['success'] += 1 else: STATS[command]['error'] += 1def handle_put(key, value): """修改key，value""" DATA[key] = value return (True, 'key [&#123;&#125;] set to [&#123;&#125;]'.format(key, value))def handle_get(key): """根据key获取value""" if key not in DATA: return (False, 'Error: Key [&#123;&#125;] not found'.format(key)) else: return (True, DATA[key])def handle_putlist(key, value): """Return a tuple containing True if the command succeeded and the message to send back to the client""" return handle_put(key, value)def handle_getlist(key): """Return a tuple containing True if the key contained a list and the message to send back to the client.""" return_value = exists, value = handle_get(key) if not exists: return return_value elif not isinstance(value, list): return (False, 'ERROR: Key [&#123;&#125;] contains non-list value ([&#123;&#125;])'.format( key, value)) else: return return_valuedef handle_increment(key): """Return a tuple containing True if the key's value could be incremented and the message to send back to the client.""" return_value = exists, value = handle_get(key) if not exists: return return_value elif not isinstance(value, int): return (False, 'ERROR: Key [&#123;&#125;] contains non-list value ([&#123;&#125;])'.format( key, value)) else: DATA[key] = value + 1 return (True, 'Key [&#123;&#125;] incremented'.format(key, value))def handle_append(key, value): """Return a tuple containing True if the key's value could be appended to and the message to send back to the client.""" return_value = exists, list_value = handle_get(key) if not exists: return return_value elif not isinstance(list_value, list): return (False, 'ERROR: Key [&#123;&#125;] contains non-list value ([&#123;&#125;])'.format( key, list_value)) else: DATA[key].append(value) return (True, 'Key [&#123;&#125;] had value [&#123;&#125;] appended'.format(key, value))def handle_delete(key): """Return a tuple containing True if the key could be deleted and the message to send back to the client.""" if key not in DATA: return ( False, 'ERROR: Key [&#123;&#125;] not found and could not be deleted.'.format(key)) else: del DATA[key] return (True, 'Key [&#123;&#125;] had deleted'.format(key))def handle_stats(): """返回状态字典.""" return (True, str(STATS))# 查找表，将命令和处理命令关联COMMAND_HANDERS = &#123; 'PUT': handle_put, 'GET': handle_get, 'GETLIST': handle_getlist, 'PUTLIST': handle_putlist, 'INCREMENT': handle_increment, 'APPEND': handle_append, 'DELETE': handle_delete, 'STATS': handle_stats,&#125;def main(): """脚本主入口""" SOCKET.bind((HOST, PORT)) SOCKET.listen(1) print('Listening on &#123;&#125;'.format((HOST, PORT))) while 1: connection, address = SOCKET.accept() print('&#123;&#125; New connection from &#123;&#125;'.format( time.strftime(("%Y/%m/%d %H:%M:%S INFO"), time.localtime()), address)) data = connection.recv(4096).decode() command, key, value = parse_message(data) if command == 'STATS': response = handle_stats() elif command in ('GET', 'GETLIST', 'INCREMENT', 'DELETE'): response = COMMAND_HANDERS[command](key) elif command in ( 'PUT', 'PUTLIST', 'APPEND', ): response = COMMAND_HANDERS[command](key, value) else: response = (False, 'Unknown command type &#123;&#125;'.format(command)) update_stats(command, response[0]) data = '&#123;&#125;;\n&#123;&#125;\n'.format(response[0], response[1]) connection.sendall(bytearray(data, 'utf-8')) connection.close()if __name__ == '__main__': main()]]></content>
      <categories>
        <category>开发者手册</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[区块链概述]]></title>
    <url>%2F2018%2F05%2F11%2Fblockchain-introduce-1%2F</url>
    <content type="text"><![CDATA[区块链不是一种新的技术，它是多种技术的结合。区块链主要解决非信任的问题，它将线下的非信任业务场景搬到链上，使用多种技术手段（分布式共识、密码学等）实现信任的价值转移。 什么是区块链http://zfeiyu.com/talks/blockchain/#/intro 应用场景金融服务 银行业 证券交易 众筹 征信权属管理 征信管理 权属管理 音乐版权保 资源共享 共享单车 社会能源共享 电商共享 大数据共享 减少共享的风险 贸易管理 跨境贸易 物流供应链 一带一路 其他 云存储 医疗 通讯软件 电子游戏 投票 示例 Augar 全球预测系统 Slock 全球共享系统 Ujo music 音乐版权 Akasha 社交平台 Ipfs星云存储系统 如何鉴别区块链项目区块链代价 计算成本 存储成本 安全成本 隐私成本 易用性成本 适用场景 有共享通用数据库的需要 流程设计的参与方存在冲突或者彼此不信任 一个数据库有多方参与或者有多个写入者 现在由受信任的第三方参与流程，托管服务、数据提供服务、发放牌照的权威以及公证人 密码学正在被适用或者应当被适用 一个商业流程的数据在整个流程中被导入许多不同的数据库 系统中的参与者受到统一的规则制约 各方的决策是透明的而不是保密的 有对客观、不可更改的历史或者对各方指定的事实的日志的需求 交易频次不超过10000次/秒 不适用场景 业务场景涉及机密数据 业务过程存储大量的静态数据，或者数据非常大 交易规则经常变化 使用外部或者第三发方服务来收集/存储数据 伪区块链项目太多，如果无法由程序（智能合约）来解决问题的场景，一般都不适合使用区块链。]]></content>
      <categories>
        <category>开发者手册</category>
      </categories>
      <tags>
        <tag>区块链</tag>
        <tag>blockchain</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计中的设计]]></title>
    <url>%2F2018%2F04%2F22%2Fthe-designing-design%2F</url>
    <content type="text"><![CDATA[晚上一口气看完这本书，除了书的字太小、书内大量设计插图都是包豪斯风格之外,感受到一股浓浓的日本工匠的气息。作者全书都在阐述，设计是什么？ 理解一个东西不是能够定义它或者描述它，而是把这个我们认为自己已经知道的东西拿过来，让它变得未知，并激起我们对其真实性的新鲜感，从而深化我们对它的理解。 我的想法就是:刚刚泡了杯茶，现在还冒着热气，但随着时间的流逝，茶的温度会趋近环境的温度，这符合热力学第二定律，也符合香农的信息论。熵的增加意味着特质的降低，而设计就是降低熵的过程。 设计让它变得简单，变得平衡，让这壶茶在快节奏的生活和科技迭代的交汇处，保留原本的味道；让它回归事物本身找到属于自己的支点。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[静夜思]]></title>
    <url>%2F2017%2F10%2F11%2Flonging-in-the-night%2F</url>
    <content type="text"><![CDATA[名贱身轻，小口如锋，穿衣噆肤，娇声夜摆迷魂阵。 潜侵鸣镝，夜不能寐，惊回千里梦，已三更。 独自觅蚊影，虫廖廖，窗外雨如雷。 凭栏看落花，人悄悄，决眦入归鸟。 闲来垂钓碧溪上，又挂云帆济沧海。 欲渡黄河冰塞川，多岐路。 小憩涼窗梦惊觉，幽幽回首听叹息。]]></content>
      <categories>
        <category>码农的秘密花园</category>
      </categories>
      <tags>
        <tag>诗歌</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hadoop实战(二)]]></title>
    <url>%2F2017%2F06%2F01%2Fhadoop-in-action-2%2F</url>
    <content type="text"><![CDATA[WordCount统计词频MapReduce实现WordCount.java源码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import java.io.IOException;import java.util.StringTokenizer;import org.apache.hadoop.conf.Configuration;import org.apache.hadoop.fs.Path;import org.apache.hadoop.io.IntWritable;import org.apache.hadoop.io.Text;import org.apache.hadoop.mapreduce.Job;import org.apache.hadoop.mapreduce.Mapper;import org.apache.hadoop.mapreduce.Reducer;import org.apache.hadoop.mapreduce.lib.input.FileInputFormat;import org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;public class WordCount &#123; public static class TokenizerMapper extends Mapper&lt;Object, Text, Text, IntWritable&gt;&#123; private final static IntWritable one = new IntWritable(1); private Text word = new Text(); public void map(Object key, Text value, Context context) throws IOException, InterruptedException &#123; StringTokenizer itr = new StringTokenizer(value.toString()); while (itr.hasMoreTokens()) &#123; word.set(itr.nextToken()); context.write(word, one); &#125; &#125; &#125; public static class IntSumReducer extends Reducer&lt;Text,IntWritable,Text,IntWritable&gt; &#123; private IntWritable result = new IntWritable(); public void reduce(Text key, Iterable&lt;IntWritable&gt; values, Context context) throws IOException, InterruptedException &#123; int sum = 0; for (IntWritable val : values) &#123; sum += val.get(); &#125; result.set(sum); context.write(key, result); &#125; &#125; public static void main(String[] args) throws Exception &#123; Configuration conf = new Configuration(); Job job = Job.getInstance(conf, &quot;word count&quot;); job.setJarByClass(WordCount.class); job.setMapperClass(TokenizerMapper.class); job.setCombinerClass(IntSumReducer.class); job.setReducerClass(IntSumReducer.class); job.setOutputKeyClass(Text.class); job.setOutputValueClass(IntWritable.class); FileInputFormat.addInputPath(job, new Path(args[0])); FileOutputFormat.setOutputPath(job, new Path(args[1])); System.exit(job.waitForCompletion(true) ? 0 : 1); &#125;&#125; 编译12hadoop com.sun.tools.javac.Main WordCount.javajar cf wc.jar WordCount*.class 创建DFS在hdfs上的用户目录下创建输入/输出文件的文件夹. 1hadoop fs -mkdir -p /user/&#123;whoami&#125;/wordcount/input 下本书 123mkdir -p ~/tmp/book/cd ~/tmp/bookwget http://www.gutenberg.org/files/5000/5000-8.txt 将书放到HDFS上 1hadoop fs -put ~/tmp/book/*.txt /user/$&#123;whoami&#125;/wordcount/input 执行MapReduce1hadoop jar wc.jar WordCount /user/$&#123;whoami&#125;/wordcount/input /user/$&#123;whoami&#125;/wordcount/output 查看解析内容1hadoop fs -cat /user/$&#123;whoami&#125;/wordcount/output/part-r-00000 HadoopStreaming实现Hadoop是使用Java语言编写的,所以最直接的方式的就是使用Java语言来实现Mapper和Reducer,然后配置MapReduce Job,提交到集群计算环境来完成计算.hadoop也为其它语言，如C++、Shell、Python、 Ruby、PHP、Perl等提供了支持，这个工具就是Hadoop Streaming. wordcount的python实现mapper.py源码 123456789101112#!/usr/bin/env pythonimport sysdef read_input(file): for line in file: yield line.split()def main(separator=&apos;\t&apos;): data = read_input(sys.stdin) for words in data: for word in words: print &quot;%s%s%d&quot; % (word, separator, 1)if __name__ == &quot;__main__&quot;: main() reducer.py 1234567891011121314151617#!/usr/bin/env pythonfrom operator import itemgetterfrom itertools import groupbyimport sysdef read_mapper_output(file, separator = &apos;\t&apos;): for line in file: yield line.rstrip().split(separator, 1)def main(separator = &apos;\t&apos;): data = read_mapper_output(sys.stdin, separator = separator) for current_word, group in groupby(data, itemgetter(0)): try: total_count = sum(int(count) for current_word, count in group) print &quot;%s%s%d&quot; % (current_word, separator, total_count) except valueError: passif __name__ == &quot;__main__&quot;: main() 运行可以写个sh脚本运行123456hadoop jar $STREAM \-files ./mapper.py,./reducer.py \-mapper ./mapper.py \-reducer ./reducer.py \-input /user/$&#123;whoami&#125;/wordcount/input/ \-output ~/output Spark实现运行spark的python交互式控制台,pyspark. 1234567891011121314151617hadoop@4532e4bdaa51:~$ pysparkPython 2.7.6 (default, Jun 22 2015, 17:58:13)[GCC 4.8.2] on linux2Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.Using Spark&apos;s default log4j profile: org/apache/spark/log4j-defaults.propertiesSetting default log level to &quot;WARN&quot;.To adjust logging level use sc.setLogLevel(newLevel).16/10/28 02:10:51 WARN NativeCodeLoader: Unable to load native-hadoop library for your platform... using builtin-java classes where applicableWelcome to ____ __ / __/__ ___ _____/ /__ _\ \/ _ \/ _ `/ __/ &apos;_/ /__ / .__/\_,_/_/ /_/\_\ version 2.0.1 /_/Using Python version 2.7.6 (default, Jun 22 2015 17:58:13)SparkSession available as &apos;spark&apos;.&gt;&gt;&gt; 使用textFile加载文本到RDD,进行’wordcount’. 12&gt;&gt;&gt; text = sc.textFile(&quot;hdfs://localhost:9000/user/$&#123;whoami&#125;/wordcount/input&quot;)&gt;&gt;&gt; counts = text.flatMap(lambda line: line.split(&quot; &quot;)).map(lambda word: (word,1)).reduceByKey(lambda x,y: x + y) 调用saveAsTextFile,分布式作业开始… 1counts.saveAsTextFile(&quot;hdfs://localhost:9000/wordcount/spark_out&quot;) 可以在工作台输出目录里查看 12345678910hadoop fs -cat hdfs://localhost:9000/wordcount/spark_out/part-00000...(u&apos;Well&apos;, 1)(u&apos;roar,&apos;, 1)(u&apos;Lust&apos;, 1)(u&apos;up-side-down&apos;, 1)(u&apos;sozza&apos;, 1)(u&apos;primus&apos;, 1)(u&apos;expands&apos;, 1)...]]></content>
      <categories>
        <category>开发者手册</category>
      </categories>
      <tags>
        <tag>大数据</tag>
        <tag>hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据平台构建思路]]></title>
    <url>%2F2017%2F05%2F23%2Fhow-to-build-data-platform%2F</url>
    <content type="text"><![CDATA[构建大数据平台思路，企业如何大数据化？ 全面数据化 数据化是一个政/企能够通过深入数据分析，实现自身优化的基础。 政/企采集并存储政务/生产经营中的一切数据，形成自己的数据资产。 整理数据资源、建立数据标准、形成管理规范 通过自顶向下的方式，成立数据委员会。了解数据资源的整体情况并建立数据资源情况更新的流程和规范 数据资源最基本的呈现方式是一个数据目录。企业管理团队至少应该掌握到3级目录，技术团队掌握到4级目录。 （范例）某集团数据资源管理办法第一章 总 则 第一条 为适应集团信息化发展要求,充分利用数据资源为生产、经营、管理和决策服务，保证各类信息合理、有序流动和信息安全，确保集团信息化建设快速协调有序安全发展，根据国家有关法律法规以及《集团信息安全管理办法》（中平〔2013〕188号）、等规定，特制定本管理办法。 第二条 本办法适用于集团各职能部室，直属和特设机构、专业化公司、事业部、区域公司及其所属各单位（以下简称各单位）。 第二章 管理范围 第三条 本办法管理范围包括：各单位与生产、经营、办公、安全等相关的应用系统和数据，以及为其提供支撑的基础设施资源、计算存储资源和办公终端资源等。 第三章 组织机构和工作机制 第四条 集团信息化领导小组是集团数据资源管理体系的最高层，负责审定集团有关数据资源管理的规章、制度、办法，负责审核有关标准、规范、重要需求等。集团信息化领导小组办公室（以下简称集团信息办）负责集团数据管理的监督、检查和考核，指导集团数据管理工作，查处危害集团数据安全的事件。各单位负责本单位数据的采集、传输、使用、安防、备份等管理工作。中国平煤神马集团平顶山信息通信技术开发公司（以下简称信通公司）作为技术支撑及运维部门，负责集团数据中心的运维和运营工作。 第四章 数据分级管理 第五条 根据数据在生产、经营和管理中的重要性，结合有关保密规定，按照集团级应用系统和数据、厂矿级应用系统和数据、区队（车间）级应用系统和数据分别制定管理标准。 第六条 集团级应用系统和数据，技术管理由集团信息办负责，业务管理由相关业务处室负责，运维管理由信通公司负责。厂矿级应用系统和数据由各单位信息管理部门管理，集团需要利用的管理数据和生产数据要同步上传到集团数据中心。区队（车间）级应用系统和数据由各单位信息管理部门管理和维护。 第五章 数据标准管理 第七条 集团信息办负责集团数据编码和接口标准的统一规划和标准制定，负责对集团及各单位应用系统的数据标准管理进行引导和考核。各单位新建应用系统应严格执行集团下发的数据编码和接口标准，在用应用系统应根据自身实际逐步按照集团标准进行完善。 第八条 数据编码和接口标准应符合以下要求： 数据编码应能够保证同一个对象编码的唯一性及上下游管理规范的一致性； 接口应实现对外部系统的接入提供企业级的支持，在系统的高并发和大容量的基础上提供安全可靠的接入； 提供完善的数据安全机制，以实现对数据的全面保护，保证系统的正常运行，防止大量访问，以及大量占用资源的情况发生，保证系统的健壮性； 提供有效的系统可监控机制，使得接口的运行情况可监控，便于及时发现错误并排除故障； 保证在充分利用系统资源的前提下，实现系统平滑的移植和扩展，同时在系统并发增加时提供系统资源的动态扩展，以保证系统的稳定性； 在进行扩容、新业务扩展时，应能提供快速、方便和准确的实现方式。 第六章 数据资源管理 第九条 基础设施资源集中管理。为了避免信息机房等基础设施资源重复投资建设，造成资金浪费、设施利用率低等问题，各单位应充分利用集团数据中心资源，集团信息办负责统一协调集团及各单位的基础设施资源。 各单位未经集团批准不得私自新建、改建、扩建信息机房。 集团数据中心要按照《集团机房建设技术规范》建设，满足各单位应用系统及数据统一到集团数据中心所需的各项使用要求。 各单位现有机房自行管理、统一管控。各级信息管理部门作为主要责任部门，要保证信息机房各项运行指标达到集团要求。 第十条 计算存储资源集中管理。为了消除“信息孤岛”，实现集团数据共享和集成，提升数据安全防护等级，各单位所需计算和存储资源，要统一使用集团数据中心的云计算资源，做到资源集中、高效利用。 现有的集团级应用系统及数据（安全监测系统除外）、各单位应用系统及数据（直接用于生产安全、自动化控制和监测监控的系统除外）要按照在用服务器、存储的服务年限和系统生命周期科学制定迁移到集团数据中心的计划和方案，并报集团信息办批准后实施。 新建应用系统原则上不再购置新的服务器和存储，所需计算和存储资源应使用集团数据中心的云计算资源。各单位如有特殊生产要求，确需购置服务器或存储的，需报请集团领导批准，由集团信息办备案后，按集团采购管理相关规定执行。 对于当前集团网络不具备实施条件的单位，可向集团提出申请建设集团区域性数据分中心，并根据建设进度制定应用系统和数据迁移计划。集团区域性数据分中心建成后，新建系统需要集中部署、分级管理。 第十一条 办公终端资源集中管理。为了提高办公效率、降低办公成本、实现节能降耗，集团级应用系统要统一使用集团数据中心云桌面，并在厂矿和区队（车间）级应用系统中逐步实现全面使用。 各单位新建系统所需计算机和新增办公用计算机要使用集团数据中心云桌面。 原有集团推广的应用系统所使用的计算机，以及各单位在用的计算机，分别由应用系统主管部门和各单位按年度提出云桌面更换计划，逐步完成云桌面更换工作；集团信息办负责协调和监督。 各单位申请云桌面使用，应与信通公司签订租用协议，由信通公司负责云桌面运维，各单位信息管理部门负责本单位云桌面管理。 对于当前集团网络不具备实施云桌面替换条件的单位，应协同集团相关部门接入集团网络或建设集团区域性数据分中心。在网络接入后或集团区域性数据分中心建成后，按计划完成云桌面的部署工作。 第十二条 各单位使用资源应按集团规定支付相关费用。 第七章 数据分析管理 第十三条 数据分析是采取科学合理的方法，利用现代信息技术手段，对计算机应用系统生成的数据进行分析，充分发掘数据中蕴涵的信息，用数据描述现状，预测趋势，规范生产行为，优化管理流程，加强经营监管，提供决策支持。 第十四条 集团信息化领导小组应加强对各单位数据分析的指导，鼓励各单位结合自身实际，充分利用“大数据”技术，自行组织开发业务选题和数据模型，组织经验交流，提高分析水平。集团信息办要做好数据分析引导和管理工作，为集团安全生产、经营管理工作服务。基层各单位要充分挖掘和利用现有数据资源，不断探索和创新数据分析方法，规范数据分析程序，提高数据分析质量，做好本单位各项应用的数据分析工作。 第十五条 集团级数据分析、处室级数据分析和厂矿级数据分析分别由集团信息办、相关业务处室和各基层单位负责策划和实施，集团信息化领导小组负责监督和考核。 第八章 数据应用管理 第十六条 数据应用是指利用数据分析的成果，查找存在问题，开展业务运转状况评估，提出改进措施，提高管理水平，规避管理风险。 第十七条 各级信息管理部门应加强数据应用。集团信息办负责代表集团对各单位以及单位之间数据共享应用的统一规划并制定标准。各单位要严格按部门、按层级落实数据应用工作，对数据进行科学统计、分析、挖掘和应用，为各级领导决策提供依据。 第九章 数据安全管理 第十八条 各级信息管理部门应建立数据安全管理制度及相关措施，主要包括：数据访问的身份验证、权限管理及数据的加密、保密、日志管理、网络安全、容灾备份等。 第十九条 为统一规范操作权限，各单位应明确工作人员的录入权限、访问权限及维护权限的管理部门，任何人不得擅自设立、变更和注销。 第二十条 各级信息管理部门要指定专人负责系统数据及介质资料的安全管理工作。要加强数据库的安全管理，制定和明确管理员用户和数据查询用户的操作权限及规程。 第二十一条 对数据的各项操作至少要建立运行日志，严格监控操作过程，对发现的数据安全问题，要及时处理和上报。管理员应掌握和运用数据库访问审计技术，实现对数据库操作的监测和追溯。 第二十二条 各级信息管理部门要加强用户身份验证管理、网络安全管理，采取严格措施,做好计算机病毒的预防、检测、清除工作，建立针对网络攻击的防范措施，保证数据传输和存储安全。 第二十三条 各级信息管理部门要加强数据的容灾备份工作，建立数据容灾备份机制，保障系统应急恢复和数据溯源。重要数据要上传至集团数据中心备份。 ###第十章 附 则 第二十四条 本办法解释权归集团。 第二十五条 本办法自本文印发之日起执行。 建设数据管理平台 数据管理平台要为政/企量身定做一套数据组织和管理的解决方案。特别是各部门之间数据的共融共通，以及企业数据怎么样进行索引和关联。 其次，数据管理平台是由业务所引导的，要为业务提供直接的支撑。 最后，数据管理平台的建设要量体裁衣，建设未必一次到位，但强调鲁棒性和可扩展性。 数据资源目录和资源交换管理数据资源目录管理是实现政务信息资源共享交换、数据整合和大数据应用的桥梁和基础设施，是提高数据治理、数据管理能力和提高信息标准化服务水平的重要技术手段。 系统要求 符合国家信息资源目录体系及元数据标准，按照统一的标准规范实现对政务信息资源的梳理、元数据采集、描述、编目、分类目录管理和可视化应用展现; 系统支持手工录入及在线连接梳理各种类型的数据资源，包括各种异构关系型数据厍、NoSQL数据库和大数据平台(HBase、Hive、MongoDB等)、以及各种格式化文件如 XML、Jason、CSV、TXT、Excel等资源类型的梳理，为分散异构的政务信息资源提供统一的梳理、元数据管理、目录管理，并提供分类导航、资源搜索和定位等应用服务功能 厂商 synball 易达讯 具备海量数据的深入分析能力建立针对多元异构、跨域关联的海量数据，通过深度分析挖掘获取价值的能力，关键需要具备以下的几点能力。 结构化数据的分析处理能力。 非结构化数据的分析处理能力。 大数据下的机器学习能力。 支持作业类型 ETL：kettle，Sqoop，flume作业管理。 MapReduce：离线处理作业。 Hive：关系型分析查询作业。 Pig：数据清洗，ETL 等脚本作业。 Spark Streaming：基于 Spark 的在线/流式 作业。 Spark MLlib：基于 Spark 的机器学习作业。 Spark GraphX：基于 Spark 的图处理作业。 Spark SQL：基于 Spark 的数据科学交互式作业。作业管理 作业（Hadoop/Spark/Hive/Pig）可任意组合成执行计划。 执行计划可分为立即执行和定时周期执行。 对作业和任务状况进行监控。自动化部署 根据业务量的上升可对集群动态扩容。 自由选择开源大数据生态软件组合和版本，包括 Hadoop 和 Spark。数据挖掘管理 可选择统一数据仓库,封装为统计数据对外开放。 可执行数据挖掘脚本对平台内的制定范围数据进行分析和挖掘。 建立外部数据的战略储备架构需要实际业务来验证。政企除了自身的数据之外，需要引入外部的数据来比对，样本的多样化有助于进一步分析和挖掘现有的数据。 持续建立自己的外部数据战略储备。 如宁波市楼盘数据 深证市住房和建设局开放数据 北京住房和城乡建设委员会 自建具备采集、清洗、存储和索引等功能的自动化系统，自动累计外部数据。 爬虫框架，Charlotte. 通过和数据供应商合作，获得一些数据。 数据堂 推动自身数据的开放与分享 有了大量数据和一定的分析能力后，不故步自封充分借助社会的力量，尽最大可能发挥数据潜藏的价值。 通过数据开放计划，可以学习先进的算法和最具创新的数据应用思路实现自身数据的价值最大化。 数据产业的战略投资布局产业集成。todo 技术集成。todo]]></content>
      <categories>
        <category>开发者手册</category>
      </categories>
      <tags>
        <tag>大数据</tag>
        <tag>hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hadoop实战(一)]]></title>
    <url>%2F2017%2F05%2F22%2Fhadoop-in-action-1%2F</url>
    <content type="text"><![CDATA[Docker形式的HadoopHadoop环境搭建创建hadoop用户增加hadoop用户，授予管理员权限，并登录 1234$ sudo useradd -m hadoop$ sudo passwd hadoop$ sudo adduser hadoop sudo$ sudo su hadoop 安装配置SSH12$ sudo apt-get install openssh-server$ sudo /etc/init.d/ssh start 设置免密码登录，生成私钥和公钥,并将公钥追加到 authorized_keys中，它为用户保存所有允许登录到ssh客户端用户的公钥内容。 123$ ssh-keygen -t rsa -P &quot;&quot;$ cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys$ chmod 0600 ~/.ssh/authorized_keys 在SSH安装之后，对SSH进行测试$ssh localhost 安装Hadhoop安装Java环境sudo apt-get install openjdk-7-jdk 配置 JAVA_HOME， 获取java安装目录 12345hadoop@78dd25fb63f7:/usr/local/hadoop$ update-alternatives --config javaThere is only one alternative in link group java (providing /usr/bin/java): /usr/lib/jvm/java-7-openjdk-amd64/jre/bin/javaNothing to configure.hadoop@78dd25fb63f7:/usr/local/hadoop$ 配置环境变量$ emacs ~/.bashrc并export JAVA_HOME=JDK安装路径 1$ source ~/.bashrc 安装Hadoop2.7123456wget http://mirrors.tuna.tsinghua.edu.cn/apache/hadoop/common/hadoop-2.7.3/hadoop-2.7.3.tar.gzsudo tar xzf hadoop-2.7.3.tar.gzsudo mv hadoop-2.7.3 /usr/local/hadoopsudo chmod 777 /usr/local/hadoopupdate-alternatives --config java 添加以下环境变量: 12345678910111213141516171819#HADOOP VARIABLES STARTexport JAVA_HOME=/usr/lib/jvm/java-7-openjdk-amd64export HADOOP_HOME=/usr/local/hadoopexport HADOOP_INSTALL=$HADOOP_HOMEexport YARN_HOME=$HADOOP_HOMEexport PATH=$PATH:$HADOOP_HOME/binexport PATH=$PATH:$HADOOP_HOME/sbinexport HADOOP_MAPRED_HOME=$HADOOP_HOMEexport HADOOP_COMMON_HOME=$HADOOP_HOMEexport HADOOP_HDFS_HOME=$HADOOP_HOMEexport YARN_HOME=$HADOOP_HOMEexport HADOOP_COMMON_LIB_NATIVE_DIR=$HADOOP_HOME/lib/nativeexport HADOOP_OPTS= &quot;-Djava.library.path=$HADOOP_HOME/lib:$HADOOP_COMMON_LIB_NATIVE_DIR&quot;export STREAM=$HADOOP_HOME/share/hadoop/tools/lib/hadoop-streaming-*.jarexport HADOOP_CLASSPATH=$&#123;JAVA_HOME&#125;/lib/tools.jarexport JAVA_LIBRARY_PATH=$HADOOP_HOME/lib/native#HADOOP VARIABLES END 查看Hadhoop版本，验证是否成功 123456789hadoop versionhadoop@VM-160-8-ubuntu:~$ hadoop versionHadoop 2.7.3Subversion https://git-wip-us.apache.org/repos/asf/hadoop.git -r baa91f7c6bc9cb92be5982de4719c1c8af91ccffCompiled by root on 2016-08-18T01:41ZCompiled with protoc 2.5.0From source with checksum 2e4ce5f957ea4db193bce3734ff29ff4This command was run using /usr/local/hadoop/share/hadoop/common/hadoop-common-2.7.3.jar 运行测试程序步骤 1创建一个临时的Input目录，将需要处理的文件copy到input文件夹下。1234567$ mkdir input$ cp $HADOOP_HOME/*.txt input$ ls -l input-rw-r--r-- 1 root root 15164 Feb 21 10:14 LICENSE.txt-rw-r--r-- 1 root root 101 Feb 21 10:14 NOTICE.txt-rw-r--r-- 1 root root 1366 Feb 21 10:14 README.txt 步骤 2利用Hadoop进行单词计数处理，统计input文件夹中所有文件中含有单词的次数 1hadoop jar /usr/local/hadoop/share/hadoop/mapreduce/hadoop-mapreduce-examples-2.7.3.jar wordcount input output 查看 123456789101112131415161718192021222324252627282930313233343536hadoop@VM-160-8-ubuntu:~$ cat output/*cryptography 1cure 3currently 1customarily 3customary 1d) 1damage 1damages 7damages, 3damages. 2data 3data, 1date 7day 4days 4de 1deal 5declaratory 2decoding 1decompression 4deemed 2defend 2defend, 1defense 1defined 5definition, 4delete 2deleted 2deletion 2deliberate 1den 1dependencies 8depends 13derivative 5...... Hadoop伪分布式安装core-site.xmlcore-site.xml文件中包含Hadoop实例的端口号信息, 文件系统的内存分配信息，存储数据的内存限制，读/写缓冲区的容量等信息。 打开core-site.xml文件，并在, 标签之间添加以下属性信息。cd $HADOOP_HOME/etc/hadoop 123456&lt;configuration&gt; &lt;property&gt; &lt;name&gt;fs.default.name&lt;/name&gt; &lt;value&gt;hdfs://localhost:9000&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; hdfs-site.xmlhdfs-site.xml文件包括本地文件系统中复制数据，主节点路径，数据节点路径等信息，该文件主要储存Hadoop基础设施。 1234567891011121314&lt;configuration&gt; &lt;property&gt; &lt;name&gt;dfs.replication&lt;/name&gt; &lt;value&gt;1&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.name.dir&lt;/name&gt; &lt;value&gt;file:///home/hadoop/hadoopinfra/hdfs/namenode&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.data.dir&lt;/name&gt; &lt;value&gt;file:///home/hadoop/hadoopinfra/hdfs/datanode&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; yarn-site.xml在以上文件中，所有的属性值都是用户定义的，可以通过改变属性值Hadoop基础构架，yarn-site.xml能够配置Hadoop的yarn，打开yarn-site.xml文件，在, 标签之间添加属性。 123456&lt;configuration&gt; &lt;property&gt; &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt; &lt;value&gt;mapreduce_shuffle&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; mapred-site.xmlmapred-site.xml文件说明哪一个MapReduce框架正在被使用。在默认状态下，Hadoop包含一个yarn-site.xml模板。 首先，需要使用cp命令复制mapred-site,xml.template到mapred-site.xml文件。 1$ cp mapred-site.xml.template mapred-site.xml 打开mapred-site.xml文件，并在, 标签之间添加属性。 123456&lt;configuration&gt; &lt;property&gt; &lt;name&gt;mapreduce.framework.name&lt;/name&gt; &lt;value&gt;yarn&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; Hadoop启动建立主节点建立主节点使用hdfs namenode -format命令。 123456$ cd ~$ hdfs namenode -format打开hadoop-env.sh，增加export HADOOP_COMMON_LIB_NATIVE_DIR=$HADOOP_HOME/lib/nativeexport HADOOP_HOME=/usr/local/hadoopexport HADOOP_OPTS=&quot;-Djava.library.path=$HADOOP_HOME/lib:$HADOOP_COMMON_LIB_NATIVE_DIR&quot; 命令正确执行后，可以得到以下的输出结果。 12345678910111213hadoop@VM-160-8-ubuntu:/usr/local/hadoop/etc/hadoop$ hdfs namenode -format17/05/21 12:12:04 INFO namenode.NameNode: STARTUP_MSG:/************************************************************STARTUP_MSG: Starting NameNodeSTARTUP_MSG: host = VM-160-8-ubuntu/127.0.0.1STARTUP_MSG: args = [-format]STARTUP_MSG: version = 2.7.3............17/05/21 12:12:06 INFO namenode.NameNode: SHUTDOWN_MSG:/************************************************************SHUTDOWN_MSG: Shutting down NameNode at VM-160-8-ubuntu/127.0.0.1************************************************************/ 启动Hadoop的dfs文件系统以下命令用来启动dfs，启动Hadoop文件系统。(2.7需将 /etc/hadoop/hadoop-env.sh中的 JAVA_HOME设为绝对路径) 1export JAVA_HOME=/usr/lib/jvm/java-7-openjdk-amd64 123456789hadoop@VM-160-8-ubuntu:~$ start-dfs.sh17/05/21 12:23:54 WARN util.NativeCodeLoader: Unable to load native-hadoop library for your platform... using builtin-java classes where applicableIncorrect configuration: namenode address dfs.namenode.servicerpc-address or dfs.namenode.rpc-address is not configured.Starting namenodes on []localhost: starting namenode, logging to /usr/local/hadoop/logs/hadoop-hadoop-namenode-VM-160-8-ubuntu.outlocalhost: starting datanode, logging to /usr/local/hadoop/logs/hadoop-hadoop-datanode-VM-160-8-ubuntu.outStarting secondary namenodes [0.0.0.0]0.0.0.0: starting secondarynamenode, logging to /usr/local/hadoop/logs/hadoop-hadoop-secondarynamenode-VM-160-8-ubuntu.out17/05/21 12:24:13 WARN util.NativeCodeLoader: Unable to load native-hadoop library for your platform... using builtin-java classes where applicable 启动Yarn脚本以下命令启动yarn script，执行这个命令将会启动yarn daemons程序。 12345$ start-yarn.shhadoop@VM-160-8-ubuntu:~$ start-yarn.shstarting yarn daemonsstarting resourcemanager, logging to /usr/local/hadoop/logs/yarn-hadoop-resourcemanager-VM-160-8-ubuntu.outlocalhost: starting nodemanager, logging to /usr/local/hadoop/logs/yarn-hadoop-nodemanager-VM-160-8-ubuntu.out 通过浏览器访问Hadoop Hadoop默认的端口号是50070，使用以下命令访问Hadoop服务。http://localhost:50070/ 图1-Hadoop服务 启动集群中所有的应用程序默认的端口号8088能够访问所有的应用程序，使用以下url能够访问这个服务。http://localhost:8088/ 图2-Hadoop应用程序 出现以上图片表明Hadoop程序已经完成部署。 Spark安装获取并解压到Hadoop中. 123wget https://d3kbcqa49mib13.cloudfront.net/spark-2.1.1-bin-hadoop2.7.tgztar -xf spark-2.1.1-bin-hadoop2.7.tgzsudo mv spark-2.1.1-bin-hadoop2.7 $HADOOP_HOME/spark2 配置环境变量: 12export SPARK_HOME=$HADOOP_HOME/spark2export PATH=$SPARK_HOME/bin:$PATH 进入Spark安装路径,配置spark环境变量：cp spark-env.sh.template spark-env.sh 加入如下环境变量 12export JAVA_HOME=/usr/lib/jvm/java-7-openjdk-amd64export SPARK_MASTER_IP=10.154.160.8 sbin/start-all.sh启动spark, 8080端口访问spark的web站点]]></content>
      <categories>
        <category>开发者手册</category>
      </categories>
      <tags>
        <tag>大数据</tag>
        <tag>hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Zabbix使用指南]]></title>
    <url>%2F2017%2F05%2F20%2Fzabbix-guide%2F</url>
    <content type="text"><![CDATA[zabbix可监控服务器资源以及数据库资源，同时有开放的api接口可以方便的在它的基础上做二次开发，可作为数据中心建设的备选方案。 Install环境1234ubuntu 14.04mysql-5.6php-5.5zabbix-3.2 安装LAMP安装Apache2和PHP12sudo apt install apache2sudo apt-get install php5 php5-mysql libapache2-mod-auth-mysql 查找date字符串，修改date.timezone及添加后面的字段 1234date.timezone = Asia/Shanghai max_input_time = 600 max_execution_time= 600 post_max_size = 32M 重启apache2 /etc/init.d/apache2 restart 安装mysql12345678sudo apt-get install mysql-serversudo apt isntall mysql-clientsudo apt install libmysqlclient-dev sudo apt-get install phpmyadminsudo apt-get install php-mbstringsudo apt-get install php-gettextsudo ln -s /usr/share/phpmyadmin /var/www/html/phpmyadmin 安装Zabbix增加zabbix用户和组12groupadd zabbixuseradd -g zabbix -m zabbix 安装依赖环境：123456789apt-get updatesudo apt-get install build-essentialsudo apt-get -y install makesudo apt-get -y install gccsudo apt-get -y install libghc-hsql-mysql-devsudo apt-get install libmysqlclient18sudo apt-get -y install libxml2-devsudo apt-get install libcurl3-devsudo apt-get install libsnmp-dev 导入数据1234### 创建zabbix表create database zabbix character set utf8;### 创建mysql帐号：zabbix，密码：zabbix grant all on zabbix.* to &apos;zabbix&apos;@&apos;localhost&apos; identified by &apos;zabbix&apos;; ( 源码包下的路径：zabbix –&gt; database –&gt; mysql –&gt; *.sql ) 123mysql -uzabbix -pzabbix zabbix &lt; schema.sqlmysql -uzabbix -pzabbix zabbix &lt; images.sql mysql -uzabbix -pzabbix zabbix &lt; data.sql 编译安装123./configure --enable-server --enable-agent --with-mysql --enable-ipv6 --with-net-snmp --with-libcurl --with-libxml2make install 安装中文字体1sudo apt-get install language-pack-zh-hans 启动zabbix_server/etc/init.d/zabbix-server start 访问zabbix frontend,用户名密码admin/zabbix 添加Zabbix agent(active模式)监控主机active模式：agent主机主动上报采集数据。 克隆一个模板 修改为Agent active模式 更新监控项 创建主机 选择模板 安装 zabbix agent 将zabbix文件夹解压后放在C：\ C:\zabbix\下 新建一个zabbix_agent.log文件 配置zabbix_agentd.win.conf文件（位于C:\zabbix\conf\），需要修改的地方分别为： 123Logfile= C:\zabbix\zabbix_agent.log Server=X.X.X.X Hostname=X.X.X.X 注： Server是zabbix服务器的IP地址 LogFile为zabbix_agentd.log文件的位置，用于记录事件，这里的zabbix_agentd.log填写你新建log文件的位置 Hostname需要和服务器端配置主机填入的主机名称一致，不然日志中将会报“host{主机名}not found”的错误 打开CMD命令行，注意文件路径执行：12C:\zabbix\bin\win32\zabbix_agentd.exe -c C:\zabbix\conf\zabbix_agentd.win.conf -iC:\zabbix\bin\win32\zabbix_agentd.exe -c C:\zabbix\conf\zabbix_agentd.win.conf -s 查看监控项 数据库监控 oracle监控插件:orabbix mysql：官方自带mysql监控模板，agent端运行mysql监控脚本todo CLItodo]]></content>
      <categories>
        <category>开发者工具</category>
      </categories>
      <tags>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[中文技术文档写作规范]]></title>
    <url>%2F2016%2F11%2F06%2Fdocument-style-guide%2F</url>
    <content type="text"><![CDATA[国外有非常多优秀的技术文档，黑客也大多擅长写作，无奈墙以及国内外文化差异的原因，总是会让你对文档的理解有或多或少的偏差。而国内技术氛围对敏捷开发理解有误，不重视文档。仅有的技术文档，也是挠痒之作。技术类的书，不管是出自翻译，还是由国内技术人员编写，质量普遍不高。 我一直都觉得：中文博大精深，要写出优秀的作品远比英文要难，尤其是技术文档，会有大量中英文的结合，即使是标点符号的运用都是一件烦恼的事情。最近一直在思考如何写出优秀的技术文档，其实技术文档的规范和编码规范差不多：要语法统一、用词精准、多用短句、不应该存在歧义、同样不应该有坏味道。看到这篇出自阮一峰的《中文技术文档的写作规范》，很有启发。该指导文档比较系统，遂摘录，共勉！ 另附上维基百科的各组织的写作要求写作要求。 标题层级标题分为四级。 一级标题：文章的标题 二级标题：文章主要部分的大标题 三级标题：二级标题下面一级的小标题 四级标题：三级标题下面某一方面的小标题 原则 一级标题下，不能直接出现三级标题。 标题要避免孤立编号（即同级标题只有一个）。 下级标题不重复上一级标题的内容。 谨慎使用四级标题，尽量避免出现，保持层级的简单和防止出现过于复杂的章节。如果三级标题下有并列性的内容，建议只使用项目列表（Item list）。 文本字间距全角中文字符与半角英文字符之间，应有一个半角空格。 123错误：本文介绍如何快速启动Windows系统。正确：本文介绍如何快速启动 Windows 系统。 全角中文字符与半角阿拉伯数字之间，有没有半角空格都可，但必须保证风格统一，不能两种风格混杂。 123正确：2011年5月15日，我订购了5台笔记本电脑与10台平板电脑。正确：2011 年 5 月 15 日，我订购了 5 台笔记本电脑与 10 台平板电脑。 半角的百分号，视同阿拉伯数字。 英文单位若不翻译，单位前的阿拉伯数字与单位间不留空格。 123错误：一部容量为 16 GB 的智能手机正确：一部容量为 16GB 的智能手机 半角英文字符和半角阿拉伯数字，与全角标点符号之间不留空格。 123错误：他的电脑是 MacBook Air 。正确：他的电脑是 MacBook Air。 句子 避免使用长句。一个句子建议不超过 100 字或者正文的 3 行。 尽量使用简单句和并列句，避免使用复合句。 写作风格尽量不使用被动语态，改为使用主动语态。 123错误：假如此软件尚未被安装，正确：假如尚未安装这个软件， 不使用非正式的语言风格。 123错误：Lady Gaga 的演唱会真是酷毙了，从没看过这么给力的表演！！！正确：无法参加本次活动，我深感遗憾。 用对“的”、“地”、“得”。 12345678她露出了开心的笑容。（形容词＋的＋名词）她开心地笑了。（副词＋地＋动词）她笑得很开心。（动词＋得＋副词） 使用代词时（比如“其”、“该”、“此”、“这”等词），必须明确指代的内容，保证只有一个含义。 123错误：从管理系统可以监视中继系统和受其直接控制的分配系统。正确：从管理系统可以监视两个系统：中继系统和受中继系统直接控制的分配系统。 名词前不要使用过多的形式词。 123错误：此设备的使用必须在接受过本公司举办的正式的设备培训的技师的指导下进行。正确：此设备必须在技师的指导下使用，且指导技师必须接受过由本公司举办的正式设备培训。 单个句子的长度尽量保持在 20 个字以内；20～29 个字的句子，可以接受；30～39 个字的句子，语义必须明确，才能接受；多于 40 个字的句子，在任何情况下都不能接受。 123错误：本产品适用于从由一台服务器进行动作控制的单一节点结构到由多台服务器进行动作控制的并行处理程序结构等多种体系结构。正确：本产品适用于多种体系结构。无论是由一台服务器（单一节点结构），还是由多台服务器（并行处理结构）进行动作控制，均可以使用本产品。 同样一个意思，尽量使用肯定句表达，不使用否定句表达。 123错误：请确认没有接通装置的电源。正确：请确认装置的电源已关闭。 避免使用双重否定句。 123错误：没有删除权限的用户，不能删除此文件。正确：用户必须拥有删除权限，才能删除此文件。 英文处理英文原文如果使用了复数形式，翻译成中文时，应该将其还原为单数形式。 123英文：⋯information stored in random access memory (RAMs)⋯中文：……存储在随机存取存储器（RAM）里的信息…… 外文缩写可以使用半角圆点(.)表示缩写。 12U.S.A.Apple, Inc. 表示中文时，英文省略号（⋯）应改为中文省略号（……）。 123英文：5 minutes later⋯中文：5 分钟过去了⋯⋯ 英文书名或电影名改用中文表达时，双引号应改为书名号。 123英文：He published an article entitled &quot;The Future of the Aviation&quot;.中文：他发表了一篇名为《航空业的未来》的文章。 第一次出现英文词汇时，在括号中给出中文标注。此后再次出现时，直接使用英文缩写即可。 1IOC（International Olympic Committee，国际奥林匹克委员会）。这样定义后，便可以直接使用“IOC”了。 专有名词中每个词第一个字母均应大写，非专有名词则不需要大写。 123“American Association of Physicists in Medicine”（美国医学物理学家协会）是专有名词，需要大写。“online transaction processing”（在线事务处理）不是专有名词，不应大写。 段落原则 一个段落只能有一个主题，或一个中心句子。 段落的中心句子放在段首，对全段内容进行概述。后面陈述的句子为核心句服务。 一个段落的长度不能超过七行，最佳段落长度小于等于四行。 段落的句子语气要使用陈述和肯定语气，避免使用感叹语气。 段落之间使用一个空行隔开。 段落开头不要留出空白字符。 引用引用第三方内容时，应注明出处。 1One man’s constant is another man’s variable. — Alan Perlis 如果是全篇转载，请在全文开头显著位置注明作者和出处，并链接至原文。 1本文转载自 WikiQuote 使用外部图片时，必须在图片下方或文末标明来源。 1本文部分图片来自 Wikipedia 数值半角数字数字一律使用半角形式，不得使用全角形式。 123错误： 这件商品的价格是１０００元。正确： 这件商品的价格是 1000 元。 千分号数值为千位以上，应添加千分号（半角逗号）。 1XXX 公司的实收资本为 RMB1,258,000。 对于 4 ～ 6 位的数值，千分号是选用的，比如1000和1,000都可以接受。对于7位及以上的数值，千分号是必须的。 多位小数要从小数点后从左向右添加千分号，比如4.234,345。 货币货币应为阿拉伯数字，并在数字前写出货币符号，或在数字后写出货币中文名称。 12$1,0001,000 美元 数值范围表示数值范围时，用～连接。参见《标点符号》一节的“连接号”部分。 带有单位或百分号时，两个数字都要加上单位或百分号，不能只加后面一个。 12345正确：132kg～234kg错误：132～234kg正确：67%～89%错误：67～89% 变化程度的表示法数字的增加要使用“增加了”、“增加到”。“了”表示增量，“到”表示定量。 12345增加到过去的两倍（过去为一，现在为二）增加了两倍（过去为一，现在为三） 数字的减少要使用“降低了”、“降低到”。“了”表示增量，“到”表示定量。 12345降低到百分之八十（定额是一百，现在是八十）降低了百分之八十（原来是一百，现在是二十） 不能用“降低N倍”或“减少N倍”的表示法，要用“降低百分之几”或“减少百分之几”。因为减少（或降低）一倍表示数值原来为一百，现在等于零。 标点符号原则 中文语句的标点符号，均应该采取全角符号，这样可以保证视觉的一致。 如果整句为英文，则该句使用英文/半角标点。 句号、问号、叹号、逗号、顿号、分号和冒号不得出现在一行之首。 句号中文语句中的结尾处应该用全角句号（。）。 句子末尾用括号加注时，句号应在括号之外。 123错误：关于文件的输出，请参照第 1.3 节（见第 26 页。）正确：关于文件的输出，请参照第 1.3 节（见第 26 页）。 逗号逗号，表示句子内部的一般性停顿。 注意避免“一逗到底”，即整个段落除了结尾，全部停顿都使用逗号。 顿号句子内部的并列词，应该用全角顿号(、) 分隔，而不用逗号，即使并列词是英语也是如此。 123错误：我最欣赏的科技公司有 Google, Facebook, 腾讯, 阿里和百度等。正确：我最欣赏的科技公司有 Google、Facebook、腾讯、阿里和百度等。 英文句子中，并列词语之间使用半角逗号（,）分隔。 1例句：Microsoft Office includes Word, Excel, PowerPoint, Outlook and other components. 分号分号；表示复句内部并列分句之间的停顿。 引号引用时，应该使用全角双引号（“ ”），注意前后双引号不同。 1例句：许多人都认为客户服务的核心是“友好”和“专业”。 引号里面还要用引号时，外面一层用双引号，里面一层用单引号（‘ ’），注意前后单引号不同。 1例句：鲍勃解释道：“我要放音乐，可萨利说，‘不行！’。” 圆括号补充说明时，使用全角圆括号（），括号前后不加空格。 1例句：请确认所有的连接（电缆和接插件）均安装牢固。 冒号全角冒号（：）常用在需要解释的词语后边，引出解释和说明。 1例句：请确认以下几项内容：时间、地点、活动名称，以及来宾数量。 表示时间时，应使用半角冒号（:）。 1例句：早上 8:00 省略号省略号……表示语句未完、或者语气的不连续。它占两个汉字空间、包含六个省略点，不要使用。。。或...等非标准形式。 省略号不应与“等”这个词一起使用。 12345错误：我们为会餐准备了香蕉、苹果、梨…等各色水果。正确：我们为会餐准备了各色水果，有香蕉、苹果、梨……正确：我们为会餐准备了香蕉、苹果、梨等各色水果。 感叹号应该使用平静的语气叙述，尽量避免使用感叹号！。 不得多个感叹号连用，比如！！和!!!。 破折号破折号————一般用于做进一步解释。破折号应占两个汉字的位置。 1例句：直觉————尽管它并不总是可靠的————告诉我，这事可能出了些问题。 连接号连接号用于连接两个类似的词。 以下场合应该使用直线连接号（-），占一个半角字符的位置。 两个名词的复合 图表编号 123例句：氧化-还原反应例句：图 1-1 以下场合应该使用波浪连接号（～），占一个全角字符的位置。 数值范围（例如日期、时间或数字） 1例句：2009 年～2011 年 注意，波浪连接号前后两个值都应该加上单位。 波浪连接号也可以用汉字“至”代替。 1例句：周围温度：-20°C 至 -10°C 章节结构软件手册是一部完整的书，建议采用下面的结构。 简介（Introduction）： [必备] [文件] 提供对产品和文档本身的总体的、扼要的说明 快速上手（Getting Started）：[可选] [文件] 如何最快速地使用产品 入门篇（Basics）： [必备] [目录] 又称”使用篇“，提供初级的使用教程 环境准备（Prerequisite）：[必备] [文件] 软件使用需要满足的前置条件 安装（Installation）：[可选] [文件] 软件的安装方法 设置（Configuration）：[必备] [文件] 软件的设置 进阶篇（Advanced)：[可选] [目录] 又称”开发篇“，提供中高级的开发教程 API（Reference）：[可选] [目录|文件] 软件API的逐一介绍 FAQ：[可选] [文件] 常见问题解答 附录（Appendix）：[可选] [目录] 不属于教程本身、但对阅读教程有帮助的内容 Glossary：[可选] [文件] 名词解释 Recipes：[可选] [文件] 最佳实践 Troubleshooting：[可选] [文件] 故障处理 ChangeLog：[可选] [文件] 版本说明 Feedback：[可选] [文件] 反馈方式 范例 Redux 手册 Atom 手册 参考链接 产品手册中文写作规范, by 华为 写作规范和格式规范, by DaoCloud 技术写作技巧在日汉翻译中的应用, by 刘方 简体中文规范指南，by lengoo 文档风格指南, by LeanCloud 豌豆荚文案风格指南, by 豌豆荚 中文文案排版指北，by sparanoid 中文排版需求，by W3C]]></content>
      <categories>
        <category>转</category>
      </categories>
      <tags>
        <tag>写作规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu docker镜像问题]]></title>
    <url>%2F2016%2F11%2F02%2Fdocker-ubuntu-issue%2F</url>
    <content type="text"><![CDATA[起因emacs使用多年,发现spacemacs的配置还算符合胃口,于是想做一个基于Ubuntu16.04的Docker镜像,以后就可以带着这粒胶囊行走天下了. 没想到踩到一个坑… Dockerfile: 12345RUN \ DEBIAN_FRONTEND=noninteractive apt-get update &amp;&amp; \ DEBIAN_FRONTEND=noninteractive apt-get -y install wget curl git emacs&amp;&amp; \ DEBIAN_FRONTEND=noninteractive apt-get -y autoremove &amp;&amp; \ DEBIAN_FRONTEND=noninteractive git clone https://github.com/syl20bnr/spacemacs ~/.emacs.d &amp;&amp; \ 镜像build完成,启动emacs报错:Debugger entered--Lisp error:(Wrong-type-argument stringp nil) 打开--debug-info进行调试,出错的堆栈信息如下: 12345678string-match(&quot;\\(fish\\|t?csh\\)$&quot; nil)exec-path-from-shell--standard-shell-p(nil)exec-path-from-shell-printf(&quot;%S\\000%s&quot; (&quot;$&#123;PATH-ad3306701bb5eb9f528b5c1b34485248&#125;&quot; &quot;$&#123;MANPYTHON-ad3306701bb5eb9f528b5c1b34485248&#125;&quot;))exec-path-from-shell-getenvs((&quot;PATH&quot; &quot;MANPATH&quot;))exec-path-from-shell-copy-envs((&quot;PATH&quot; &quot;MANPATH&quot;))exec-path-from-shell-initialize()(progn (exec-path-from-shell-initialize))... 分析Emacs本质上是个操作系统,它有自己的环境变量. 所以为了让它可以使用宿主的shell,首先需要确保宿主和Emacs自身环境变量的一致性. exec-path-from-shell 就是一这么个GNU Emacs库,它将宿主的关键SHELL环境复制到EMACS的环境变量里,从而确保Emacs可以正常调用宿主机的BASH. 查看exec-path-from-shell-printf的代码: 1234567891011121314151617181920(defun exec-path-from-shell-printf (str &amp;optional args) "Return the result of printing STR in the user's shell. Executes $SHELL as interactive login shell. STR is inserted literally in a single-quoted argument to printf, and may therefore contain backslashed escape sequences understood by printf. ARGS is an optional list of args which will be inserted by printf in place of any % placeholders in STR. ARGS are not automatically shell-escaped, so they may contain $ etc." (let* ((printf-bin (or (executable-find "printf") "printf")) (printf-command (concat printf-bin " '__RESULT\\000" str "' " (mapconcat #'exec-path-from-shell--double-quote args " "))) (shell-args (append exec-path-from-shell-arguments (list "-c" (if (exec-path-from-shell--standard-shell-p (getenv "SHELL")) printf-command (concat "sh -c " (shell-quote-argument printf-command)))))) (shell (getenv "SHELL"))) 结合出错堆栈分析,问题基本可以定位,即: (getenv &quot;SHELL&quot;)去获取”SHELL”的环境变量,返回为空. 接着来查看getenv方法,它通过调用getenv-internal用来获取系统environment的变量. 查看系统环境变量,env|grep SHELL,果然无值. 那么只需要设置Docker-Ubuntu16.04容器的SHELL环境变量到env里就可以了. 12echo &quot;export SHELL=/bin/bash&quot; &gt;&gt; ~/.bashrcsource ~/.bashrc 运行emacs,问题解决.此时Dockerfile可以配置如下: 12345678...RUN \ DEBIAN_FRONTEND=noninteractive apt-get update &amp;&amp; \ DEBIAN_FRONTEND=noninteractive apt-get -y install wget curl git emacs&amp;&amp; \ DEBIAN_FRONTEND=noninteractive apt-get -y autoremove &amp;&amp; \ DEBIAN_FRONTEND=noninteractive git clone https://github.com/syl20bnr/spacemacs ~/.emacs.d &amp;&amp; \ DEBIAN_FRONTEND=noninteractive echo "export SHELL=/bin/bash" &gt;&gt; ~/.bashrc &amp;&amp; \ ... 疑问为什么官方Ubuntu Docker镜像没有将SHELL加到环境变量里? 有一点很明确,Docker不同于虚拟机,它的镜像文件确实需要保持精简,只需为容器保留必要的linux核心功能就可以了. Docker官方也给出了,-env的选项命令,用于自行进行环境变量配置.在Dockerfile中也可以使用ENV进行环境变量的配置,我们的Dockerfile可以写成如下的形式. 12345...RUN \ ... DEBIAN_FRONTEND=noninteractive ENV SHELL /bin/bash ... 那么,这个Docker镜像连$SHELL,$BASH等环境变量都省略了,是否还有其他功能被阉割了呢? 确实是的,问题还很多. 比如Docker下的ubuntu有一个很大的问题,它的PID1是bash! 1234root@0d9e754629e0:/# ps PID TTY TIME CMD 1 ? 00:00:00 bash 37 ? 00:00:00 ps 而完整的系统应该是init 1234lizorn@lizorn:/etc$ ps auxUSER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMANDroot 1 0.0 0.0 185604 6388 ? Ss 10:39 0:01 /sbin/init splashroot 2 0.0 0.0 0 0 ? S 10:39 0:00 [kthreadd] PID1 init是系统所有进程的祖先,同时它还负责接收和处理僵尸进程,the PID 1 zombie reaping problem. 这个问题会导致docker-ubuntu系统有可能产生无法回收的僵尸进程,造成内存孤岛,浪费系统性能.需要额外的补丁程序来完成PID1任务的回收工作,修复该问题的轮子已经具备,你可以直接使用phusion的baseimage来制作Docker基础镜像文件. 附录: linux 环境变量shell变量&amp;用户变量 set:显示当前shell的变量 env:显示当前用户的环境变量 export可将当前shell变量导出成用户变量. set下的环境变量不等同于env下的用户变量,两者是有区分的,因为一个用户可以有多个SHELL,如fish,tsh等. linux shell环境初始化流程Linux系统登录，bash其初始化过程依次加载如下文件(文件不存在就跳过): /etc/profile-&gt;/etc/profile.d~/.bash_profile-&gt;~/.bashrc-&gt;~/.bash_logout /etc/profile: 系统级用户环境变量.当用户第一次登录时,该文件被加载.设置命令行提示符$PS,并从/etc/profile.d目录的配置文件中搜集shell的设置. /etc/bashrc: 系统级用户环境变量.当bash shell被打开时加载. ~/.bash_profile: 用户级环境变量.用户登录时加载,默认情况下,他设置一些环境变量,执行用户的.bashrc文件. ~/.bashrc: 用户级环境变量.该文件包含专用于你的bash shell的bash信息,当登录时以及每次打开新的shell时加载该文件. ~/.bash_logout:当每次退出系统(退出bash shell)时执行该文件.]]></content>
      <categories>
        <category>开发者手册</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>spacemacs</tag>
        <tag>emacs</tag>
        <tag>linux环境变量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[键盘键位映射]]></title>
    <url>%2F2016%2F11%2F01%2Fkeymap%2F</url>
    <content type="text"><![CDATA[自从HHKB键盘败家卖了后,其他键盘一直用着不爽,只能稍微设置下,聊以自慰. 首先,capslock必须死,这么好的位置居然被这废材占据着. linuxcapslock-&gt;ctrlsudo emacs /etc/default/keyboard 修改下面这一行： XKBOPTIONS=&quot;ctrl:nocaps&quot; 重新配置系统键盘，全部选默认： sudo dpkg-reconfigure keyboard-configuration windowscapslock-&gt;ctrlCtrl2Cap maccapslock-&gt;ctrl 打开System Preferences → Keyboard → Modifier Keys]]></content>
      <categories>
        <category>杂货摊</category>
      </categories>
      <tags>
        <tag>keymap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hadoop快速入门]]></title>
    <url>%2F2016%2F10%2F27%2Fhadoop-quick-start%2F</url>
    <content type="text"><![CDATA[什么是hadoop?Hadoop是一个由Apache基金会所开发的分布式系统基础架构，用户可以在不知道底层细节的情况下,将可自己的程序运行在分布式系统上,利用计算机集群对海量数据进行高速的数据运算和存储. 要学习hadoop,首先要了解它的核心设计:MapReduce和HDFS. HDFSHDFS(Hadoop Distributed File System，Hadoop分布式文件系统),是一个具备高度容错性的文件系统,可以部署在廉价的系统上. 基本架构 Block: 块文件,通常是64M. DataNode：用于存储Block块文件. NameNode: 保存整个文件系统的目录,文件和分布信息.指示文件是如何被拆分成block以及这些block都存储到了哪些DateNode节点上.通常只有一台,2.X版本提供了master-slave模式. MapReduceMapReduce是一种编程模型,用于大规模数据集(大于1TB)的并行运算.基本原理就是：分析大数据，然后析分成小块逐个分析，最后再将提取出来的数据汇总分析，最终获得我们想要的内容。 MapReduce操作的都是键值对上,大致流程如下: (input) -&gt; map -&gt; -&gt; combine -&gt; -&gt; reduce -&gt; (output) Apache hadoop家族基础成员 Hadoop Common Hadoop Distributed File System (HDFS™) Hadoop MapReduce 其他成员 Hadoop YARN: 用于工作调度和集群资源管理的框架. Avro™: 是一个数据序列化系统,设计用于支持数据密集型,大批量数据交换的应用.Avro是新的数据序列化格式与传输工具,将逐步取代Hadoop原有的IPC机制. Cassandra™:是一套开源分布式NoSQL数据库系统. Chukwa™: 是一个开源的用于监控大型分布式系统的数据收集系统，它可以将各种各样类型的数据收集成适合Hadoop处理的文件,并保存在HDFS中供Hadoop进行各种MapReduce操作. HBase™: 是一个高可靠性、高性能、面向列、可伸缩的分布式存储系统,利用HBase技术可在廉价PC Server上搭建起大规模结构化存储集群. Hive™: 基于Hadoop的一个数据仓库工具,可以将结构化的数据文件映射为一张数据库表,通过类SQL语句快速实现简单的MapReduce统计,不必开发专门的MapReduce应用,十分适合数据仓库的统计分析. Mahout™: 基于Hadoop的机器学习和数据挖掘的一个分布式框架.Mahout用MapReduce实现了部分数据挖掘算法,解决了并行挖掘的问题。 Pig™: Pig提供更高级的数据流语言，类似SQL的语言(Pig Latin),有效提高MapReduce编写的抽象表现能力. Spark™: 一个新兴的大数据处理引擎,提供了一个集群的分布式抽象模型RDD(Resilient Distributed Dataset).支持的实际应用范围非常广,如:ETL,机器学习,图像处理等. Tez™: 是Apache最新开源的支持DAG作业的计算框架,它直接源于MapReduce框架,核心思想是将Map和Reduce两个操作进一步拆分,即Map被拆分成Input、Processor、Sort、Merge和Output,Reduce被拆分成Input、Shuffle、Sort、Merge、Processor和Output等,这样,这些分解后的元操作可以任意灵活组合,产生新的操作,这些操作经过一些控制程序组装后,可形成一个大的DAG作业. ZooKeeper™: 是一个为分布式应用所设计的分布的、开源的协调服务，它主要是用来解决分布式应用中经常遇到的一些数据管理问题,简化分布式应用协调及其管理的难度,提供高性能的分布式服务. 环境准备docker run -it invain/hadoop hadoop案例:统计词频统计一个文本文件,一本书，或者一个web上各个单词出现的频率. WordCount.java源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import java.io.IOException;import java.util.StringTokenizer;import org.apache.hadoop.conf.Configuration;import org.apache.hadoop.fs.Path;import org.apache.hadoop.io.IntWritable;import org.apache.hadoop.io.Text;import org.apache.hadoop.mapreduce.Job;import org.apache.hadoop.mapreduce.Mapper;import org.apache.hadoop.mapreduce.Reducer;import org.apache.hadoop.mapreduce.lib.input.FileInputFormat;import org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;public class WordCount &#123; public static class TokenizerMapper extends Mapper&lt;Object, Text, Text, IntWritable&gt;&#123; private final static IntWritable one = new IntWritable(1); private Text word = new Text(); public void map(Object key, Text value, Context context) throws IOException, InterruptedException &#123; StringTokenizer itr = new StringTokenizer(value.toString()); while (itr.hasMoreTokens()) &#123; word.set(itr.nextToken()); context.write(word, one); &#125; &#125; &#125; public static class IntSumReducer extends Reducer&lt;Text,IntWritable,Text,IntWritable&gt; &#123; private IntWritable result = new IntWritable(); public void reduce(Text key, Iterable&lt;IntWritable&gt; values, Context context) throws IOException, InterruptedException &#123; int sum = 0; for (IntWritable val : values) &#123; sum += val.get(); &#125; result.set(sum); context.write(key, result); &#125; &#125; public static void main(String[] args) throws Exception &#123; Configuration conf = new Configuration(); Job job = Job.getInstance(conf, "word count"); job.setJarByClass(WordCount.class); job.setMapperClass(TokenizerMapper.class); job.setCombinerClass(IntSumReducer.class); job.setReducerClass(IntSumReducer.class); job.setOutputKeyClass(Text.class); job.setOutputValueClass(IntWritable.class); FileInputFormat.addInputPath(job, new Path(args[0])); FileOutputFormat.setOutputPath(job, new Path(args[1])); System.exit(job.waitForCompletion(true) ? 0 : 1); &#125;&#125; 编译12hadoop com.sun.tools.javac.Main WordCount.javajar cf wc.jar WordCount*.class 创建FS在hdfs上的用户目录下创建输入/输出文件的文件夹. hadoop fs -mkdir -p /user/{whoami}/wordcount/input 下本书 123mkdir -p ~/tmp/book/cd ~/tmp/bookwget http://www.gutenberg.org/files/5000/5000-8.txt 将书放到HDFS上 hadoop fs -put ~/tmp/book/*.txt /user/${whoami}/input 运行程序1hadoop jar wc.jar WordCount /user/$&#123;whoami&#125;/wordcount/input /user/$&#123;whoami&#125;/wordcount/output 查看解析内容hadoop fs -cat /user/${whoami}/wordcount/output/part-r-00000 hadoop steamingHadoop是使用Java语言编写的,所以最直接的方式的就是使用Java语言来实现Mapper和Reducer,然后配置MapReduce Job,提交到集群计算环境来完成计算.hadoop也为其它语言，如C++、Shell、Python、 Ruby、PHP、Perl等提供了支持，这个工具就是Hadoop Streaming. wordcount的python实现mapper.py源码1234567891011121314#!/usr/bin/env pythonimport sysdef read_input(file): for line in file: yield line.split()def main(separator='\t'): data = read_input(sys.stdin) for words in data: for word in words: print "%s%s%d" % (word, separator, 1)if __name__ == "__main__": main() reducer.py1234567891011121314151617181920#!/usr/bin/env pythonfrom operator import itemgetterfrom itertools import groupbyimport sysdef read_mapper_output(file, separator = '\t'): for line in file: yield line.rstrip().split(separator, 1)def main(separator = '\t'): data = read_mapper_output(sys.stdin, separator = separator) for current_word, group in groupby(data, itemgetter(0)): try: total_count = sum(int(count) for current_word, count in group) print "%s%s%d" % (current_word, separator, total_count) except valueError: passif __name__ == "__main__": main() 运行可以写个sh脚本运行 123456hadoop jar $STREAM \-files ./mapper.py,./reducer.py \-mapper ./mapper.py \-reducer ./reducer.py \-input /user/$&#123;whoami&#125;/input/ \-output ~/output]]></content>
      <categories>
        <category>开发者手册</category>
      </categories>
      <tags>
        <tag>大数据</tag>
        <tag>hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker环境]]></title>
    <url>%2F2016%2F10%2F27%2Fdocker-developer-env%2F</url>
    <content type="text"><![CDATA[如今技术革新非常快,搭建环境也日趋繁杂.我是个爱好折腾之人,时不时的总想把玩下新的技术,每天在win10,ubuntu,mac系统间来回切换,感谢Docker,救我于水火. 基础镜像自己裁剪一个baseImage,带emacs编辑器.编写Dockerfile,并编译 123git clone https://github.com/LiZoRN/DockerBaseImage.gitcd DockerBseImagedocker build -t invain/ubuntu . 将镜像文件push到Docker hub docker push invain/ubuntu 其他环境下就可以直接使用 docker pull invain/ubuntu 注意: Docker镜像共享，不建议直接拿Dockerfile build生产, 而应从Docker镜像库里拉,避免镜像Build的过程中引入编译环境差异. Hadoop环境搭建(单站)创建hadoop用户增加hadoop用户，授予管理员权限，并登录 1234$ sudo useradd -m hadoop$ sudo passwd hadoop$ sudo adduser hadoop sudo$ sudo su hadoop 安装并配置SSH安装openssh $ sudo apt-get install openssh-server 启动 $ sudo /etc/init.d/ssh start 设置免密码登录，生成私钥和公钥,并将公钥追加到 authorized_keys中，它为用户保存所有允许登录到ssh客户端用户的公钥内容。 12$ ssh-keygen -t rsa -P ""$ cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys 安装Java环境sudo apt-get install openjdk-7-jdk 获取java安装目录. 1234$ update-alternatives --config javaThere is only one alternative in link group java (providing /usr/bin/java): /usr/lib/jvm/java-7-openjdk-amd64/jre/bin/javaNothing to configure. ~/.bashrc中写入JAVA_HOME路径, 1export JAVA_HOME=JDK安装路径 安装Hadoop安装hadoop,如2.7.3版本 123wget http://mirrors.tuna.tsinghua.edu.cn/apache/hadoop/common/hadoop-2.7.3/hadoop-2.7.3.tar.gzsudo tar xzf hadoop-2.7.3.tar.gzsudo mv hadoop-2.7.3 /usr/local/hadoop 配置Hadoop的环境变量 给你的~/bashrc添加如下内容. 1234567891011121314#HADOOP VARIABLES STARTexport JAVA_HOME=/usr/lib/jvm/java-7-openjdk-amd64export HADOOP_HOME=/usr/local/hadoopexport PATH=$PATH:$HADOOP_HOME/binexport PATH=$PATH:$HADOOP_HOME/sbinexport HADOOP_MAPRED_HOME=$HADOOP_HOMEexport HADOOP_COMMON_HOME=$HADOOP_HOMEexport HADOOP_HDFS_HOME=$HADOOP_HOMEexport YARN_HOME=$HADOOP_HOMEexport HADOOP_COMMON_LIB_NATIVE_DIR=$HADOOP_HOME/lib/nativeexport HADOOP_OPTS="-Djava.library.path=$HADOOP_HOME/lib"export STREAM=$HADOOP_HOME/share/hadoop/tools/lib/hadoop-streaming-*.jarexport HADOOP_CLASSPATH=$&#123;JAVA_HOME&#125;/lib/tools.jar#HADOOP VARIABLES END 验证hadoop是否安装成功 1234567hadoop@8bbae082ad69:~$ hadoop versionHadoop 2.7.3Subversion https://git-wip-us.apache.org/repos/asf/hadoop.git -r baa91f7c6bc9cb92be5982de4719c1c8af91ccffCompiled by root on 2016-08-18T01:41ZCompiled with protoc 2.5.0From source with checksum 2e4ce5f957ea4db193bce3734ff29ff4This command was run using /usr/local/hadoop/share/hadoop/common/hadoop-common-2.7.3.jar 将镜像push到Docker hub 12docker commit 8bbae082ad69 invain/hadoopdocker push invain/hadoop spark运行一个java docker容器. docker run -it invain/java 下载spark包. 123wget http://mirrors.hust.edu.cn/apache/spark/spark-2.0.1/spark-2.0.1-bin-hadoop2.7.tgzsudo tar xzf spark-2.0.1-bin-hadoop2.7.tgzsudo mv spark-2.0.1-bin-hadoop2.7 /usr/local/spark 配置好环境变量. 12export SPARK_HOME=/usr/local/sparkexport PATH=$SPARK_HOME/bin:$PATH 跑个小小示例.创建个文本文件,如hellospark.txt: 12hello world!hello spark! 运行spark的python交互式控制台,pyspark. 123456789101112131415161718hadoop@4532e4bdaa51:~$ pysparkPython 2.7.6 (default, Jun 22 2015, 17:58:13)[GCC 4.8.2] on linux2Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.Using Spark&apos;s default log4j profile: org/apache/spark/log4j-defaults.propertiesSetting default log level to &quot;WARN&quot;.To adjust logging level use sc.setLogLevel(newLevel).16/10/28 02:10:51 WARN NativeCodeLoader: Unable to load native-hadoop library for your platform... using builtin-java classes where applicableWelcome to ____ __ / __/__ ___ _____/ /__ _\ \/ _ \/ _ `/ __/ &apos;_/ /__ / .__/\_,_/_/ /_/\_\ version 2.0.1 /_/Using Python version 2.7.6 (default, Jun 22 2015 17:58:13)SparkSession available as &apos;spark&apos;.&gt;&gt;&gt; 使用textFile加载文本到RDD,进行’wordcount’.12&gt;&gt;&gt; text = sc.textFile("hellospark.txt")&gt;&gt;&gt; counts = text.flatMap(lambda line: line.split(" ")).map(lambda word: (word,1)).reduceByKey(lambda x,y: x + y) 调用saveAsTextFile,分布式作业开始了…1counts.saveAsTextFile(&quot;hellospark_out&quot;) 可以在工作台输出目录里查看12345hadoop@4532e4bdaa51:~$ cat hellospark_out/part-00000(u&apos;&apos;, 1)(u&apos;spark!&apos;, 1)(u&apos;world!&apos;, 1)(u&apos;hello&apos;, 2) tensorflowdocker run -it b.gcr.io/tensorflow/tensorflow Docker hub需要什么库可以从docker hub找. Docker hub是一个类似Github一样的地方,只不过前者是一个镜像仓库. docker可以让你的环境配置异常简单，通常你只需要执行一个命令. Mysql 1$ docker run -p 3306:3306 --name username -e MYSQL_ROOT_PASSWORD=password -d mysql:tag mongo docker run --name some-mongo -d mongo Oracle]]></content>
      <categories>
        <category>开发者手册</category>
      </categories>
      <tags>
        <tag>开发环境</tag>
        <tag>docker</tag>
        <tag>docker base image</tag>
        <tag>hadoop</tag>
        <tag>spark</tag>
        <tag>tesoflow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代码的味道]]></title>
    <url>%2F2016%2F10%2F25%2FTaste-of-code%2F</url>
    <content type="text"><![CDATA[代码的味道你的代码臭不可闻，为什么？ 工期太赶 前任的坑 还是…水平未到？ 很多程序员会给自己的代码找很多借口，我认为糟糕代码的产生除了上述原因外，主要是思想问题，要摒弃糟糕的代码，让代码变得整洁，必须要先弄明白一件事情：大家写程序，你的客户是谁? 代码的表现力 “程序写出来是给人看的,附带能在机器上运行. “ 代码的表现力主要体现在两个方面: 软件的部分功能就是解释自身,为了写出优秀的软件,你必须假定用户对你的软件基本上一无所知. 源代码也应该可以自己解释自己,你需要保证源代码自身的可观赏性. 说白了，编程不是简单的完成一次功能交付，代码的表现形式不仅仅是产品本身，还包括代码自己。也就是说在你充分的实现‘功能客户’的需求的同时，你还需要满足‘code reviewer’的胃口。 我们就需要让代码变的整洁。 什么是整洁的代码?我喜欢优雅和高效的代码.代码逻辑应当直截了当,叫缺陷难以隐藏;尽量减少依赖关系,使之便于维护;依据某种分层战略完善错误处理代码;性能调至最优,省得引诱别人做没规矩的优化,搞出一堆换乱来.整洁的代码只做好一件事. Bjarne ShroustrupC++程序设计语言 C++之父Bjarne认为代码应该是优雅而高效的. 整洁的代码简单直接;整洁的代码如同优美的散文;整洁的代码从不隐藏设计者的意图,充满了干净利落的抽象和直截了当的控制语句. rady Booch面向对象分析与设计 编程是一门技艺，代码是一种艺术，很难有语言表达。我摘录了《clean code》书中‘味道与启发’这一章节部分清单，进行了修整和梳理，清单里的代码会让你非常不舒服，清单的内容需要持续维护和更新。 命名问题命名要具备描述性,避免歧义 名副其实, 好的命名不需要额外的注释 12int d; // 消逝的时间,以日计 ----badint elapsedTimeInDays; // ----good 避免误导 必须避免留下隐藏代码本意的错误线索,避免使用与本意相悖的词,如系统预留字段要尽量避免,歧义的缩写也应当避免.比如用accountList表示一组账号，会有歧义，这是是List类型? 用accountGroup则能更好的表示。 命名要有明显的区别 以下的方法很难区分具体含义：123getActiveCustomer();getActiveCustomers();getActiveCustomerInfo() 命名要具备可读性 命名通常要用于交流和沟通，需要具备基本的口语习惯。12private Date modymdhms; //badprivate Date modificationTimestamp; /good 类名使用名词,方法名使用动词. 名称应与抽象层级相符.1234567public interface Modem &#123; boolean dial(String phoneNumber);//应修改为 boolean connect(String phoneNumber); boolean disconnect(); boolean send(char c); char recv(); String getConnectedPhoneNumber();&#125; 尽可能使用标准命名法. 如果名称基于现有的约定或用法,命名就比较容易理解 命名要遵循专业领域的命名 命名要遵循团队的编码规范 名称的长度应与作用范围的广泛度相关. 对于较小的作用范围,可以用很短的名称,而对于较大作用范围就该用较长的名称. 作用范围在5行之内,i和j之类的变量名没有问题,如果范围变大,需要加长命名长度,用更有意义的命名. 避免编码.不应该在名称中包括类型或者作用范围信息，以下命名方法均可以考虑废弃： 匈牙利标记法: cClass, init,intNUmber; 成员前缀: private String m_member; 接口: 接口已I开头，IInterface 名称应说明附加功能和副作用 命名应该说明函数,变量或类的一切信息,不要用名称掩蔽副作用 不使用简单的动词来描述不止做了一个简单动作的函数. 123456public ObjectOutputStream getOos() throws IOException &#123; if (m_oos == null) &#123; m_oos = new ObjectOutputStream(m_socket.getOutputStream()); &#125; return m_oos;&#125; getOos应改为createOrReturnOos 注释问题不恰当的注释.注释只应该描述相关代码和设计的技术信息.如描述一些修改记录,问题追踪等是不恰当的注释,这些注释过时且无实际意义，会扰乱和降低阅读体验.这些工作需要交给版本能控制工具。 废弃的注释.注释也需要维护,过时,无关或不正确的注释会引起歧义并影响代码的可读性,需第一时间删除或更新. 冗余注释.代码已经充分自我描述了,那么注释就是冗余的. 注释应该是代码未能涉及信息的补充. 1i++; // increment i 坏注释.注释也是代码的一部分,要保持简洁和语句通顺,别在里面闲扯. 123456789101112131415161718192021/*I fear that I will always be A lonely number like root threeA three is all that's good and rightWhy must my three keep out of sight Beneath a vicious square-root sign?I wish instead I were a nineFor nine could thwart this evil trick With just some quick arithmeticI know I'll never see the sunAs 1.7321...Such is my reality A sad irrationalityWhen,hark, just what is this I see?Another square root of a threeHas quietly come waltzing byTogether now we multiplyTo form a number we preferRejoicing as an integerWe break free from our mortal bondsAnd with a wave of magic wandsOur square-root signs become ungluedAnd love for me has been renewed */double number = Math.sqrt(3)*Math.sqrt(3); 废弃的代码.不应该出现注释的代码, 注释掉的代码需要及时删除,版本控制系统会记录没一次的修改,不需要通过注释的形式. 一般性问题理所当然的行为未被实现.根据”最小惊异原则”,函数或类应该实现用户或程序员有理由期待的行为. 1Day day = DayDate.StringToDay(String dayName); 我们期望字符串Monday转化为Day类型的Day.MONDAY，也期望可以转化为常用缩写的Day.MON,还期望可以忽略大小写,Day.mon，这个再正常不过了.还比如，一个EXCEL的字段解析,一次web页面的字符串输入，至少要保证忽略两边的空格. 不正确的边界行为.单元测试需要追索每种边界条件,并编写测试. 忽略安全.不要关闭编译器的告警,不要忽略编译告警,甚至可以引入**Lint等语法静态编译校验工具来提高代码质量. 重复.牢记DRY原则(Don’t Repeat Yourself). 发现重复代码就表示遗漏了抽象.复制粘贴式的编码会造成大量的重复,你需要不断的重构，将重复的代码叠放成抽象对象. 代码出现在错误的抽象层级上.良好的软件设计要求将代码,文件,组件和模块，根据层级分离,将它们放到不同的位置. 基类依赖于派生类.基类不应该依赖派生类,抽象类不依赖于实体类，这是面向对象设计的基本准则，篇幅有限，具体详细查看设计模式. 信息过多 设计良好的模块有非常小的接口,耦合度低. 限制类或模块中暴露的接口数量.类中的方法越少越好.函数知道的变量越少越好. 隐藏模块和类中的数据和工具函数,隐藏常量和你的临时变量,不要创建有大量方法或大量实体变量的类,保持接口紧凑. 混淆视听未被执行的代码,没有用到的变量,没有信息量的注释等需要尽早删除,保持源文件整洁和良好. 垂直分割. 变量和函数应该在靠近被使用的地方定义. 本地变量应该正好在其首次被使用的位置上面声明,垂直距离要短. 私有函数应该刚好在其首次被使用的位置下面定义. 前后不一致.命名要保持一致性.如果在特定函数中用名为response的变量来持有HttpServletResponse对象,则在其他用到该对象的地方也使用response变量名. 设计耦合 不相互依赖的东西不该耦合.例如,普通的enum不应该包含在特殊类里,否则使用这些enum就需要了解这个特殊类. 花点时间设计代码结构,研究应该在什么地方声明函数,常量和变量.不要为了方便而随手放置,放置后又置之不理. 隐晦的意图. 代码尽可能具有表达力. 短小紧凑的代码不一定是最好的代码,魔法数字应该拆分到具备解释性的变量里.如下代码你能明白什么意思吗？ 123public init m_otCalc() &#123; return iThsWkd * iThsRte + (int) Math.round(0.5 * iThsRte * Math.max(0, iThsWkd - 400));&#125; 代码位置错误.开发人员做出的最重要决定之一就是在哪里放代码. 比如做一个考勤模块的功能,可以在打印报表的代码中做工作时间统计,或者在刷卡代码中保留一份工作时间记录.这个时候最小惊异原则就起了作用.代码应该放在读者自然而然的地方，期待它所在的地方，就和老婆一样，每天早上醒来就在边上. 所以说编程其实是一种艺术行为. PI应该出现在声明三角函数的地方，而不是和一只老虎困在大海里. 不恰当的静态方法. 通常应该倾向于选用非静态方法,如果需要静态函数,确保不会让它有多态行为. Math.max(double a, double)是个良好的静态方法,因为它并不在需要在的那个实体上运作. 使用解释性变量.和G16类同,使用解释性变量,只要把计算过程打散成一系列良好命名的中间值,就可以提高代码的可读性, 123456Matcher match = headerPattern.matcher(line);if(match.find())&#123; String key = match.gourp(1); String value = match.group(2); headers.put(key.toLowerCase(), value);&#125; 函数名称应该表达其行为.如果必须要通过查看函数的实现(或文档)才知道它是做什么的,那是时候该换个更好的函数名了. 1Date newDate = date.add(5); 从函数调用中看不出函数的行为,如果是添加5天并修改日期,那么命名需要调整为increaseByDays. 理解算法. 很多可笑代码的出现,是因为没花时间去理解公式和算法,硬塞进足够的if语句和标示,让系统勉强运作. 在完成某个函数之前,要确认自己完全理解了它是怎么工作的,只有理解了公式,才能更好的进行优化. 遵循标准约定.每个团队都应遵循基于通用行业规范的一套编码标准. 魔法数.用常量代替魔法数字. 封装条件语句.如果没有if或while语句的上下文,布尔逻辑就难以理解,应该把解释了条件意图的函数抽离出来. 1if (timer.hasExpired() &amp;&amp; !timer.isRecurrent()) //bad 换成 1if (shouldBeDeleted(timer)) //good 避免否定性条件.人的逆向思维能力一般都比较差，否定式要比肯定式难明白一些.所以,尽可能将条件表示为肯定形式. 1if (!buffer.shouldNotompact()) //bad 1if (buffer.shouldCompact()) //good 函数只该做一件事.遵循职责单一原则.以下的代码完成了太多的事情，我们需要拆分. 12345678public void pay() &#123; for (Employee e : employees) &#123; if (e.isPayday()) &#123; Money pay = e.calculatePay(); e.deliverPay(pay) &#125; &#125;&#125; 遍历雇员12345public void pay() &#123; for (Employee e : employees) &#123; payIfNecessary(e); &#125;&#125; 检查是否该给雇员付工资12345private void payIfNecessary(Employee e) &#123; if (e.isPayday())&#123; calculateAndDeliverPay(e); &#125;&#125; 给雇员付工资1234private void caculateAndDeliverPay(Employee e) &#123; Money pay = e.calculatePay(); e.deliverPay.pay()&#125; 掩藏时序耦合.不要隐藏时序耦合.如下代码，三个函数存在时序,捕鱼之前先织网,织网之前先编绳.如果调用倒换,可能就导致抛出异常. 1234567public class MoogDiver &#123; public void dive(String reson) &#123; saturateGradient(); reticulateSplines(); diveForMoog(reason); &#125;&#125; 我们需要做调整，该耦合的还是得耦合,要符合实际的业务逻辑. 1234567public class MoogDiver &#123; public void dive(String reson) &#123; Gradient gradient = saturateGradient(); List&lt;Spline&gt; splines = reticulateSplines(gradient ); diveForMoog(splines ,reason); &#125;&#125; 函数应该只在一个抽象层级上.避免传递浏览,函数或者接口调用者不需要了解太多架构相关的东西.如果A与B协作,B与C协作,我们不想让使用A的模块了解C的信息 bad: a.getB().getC().doSomething() good: myCollaborator.doSomething() 环境问题需要多步才能实现的构建.构建系统应到是单步的操作, 执行一条命令,就可以从版本控制系统里拉下源代码,并完成构建. 123svn get myPorjectcd myProjectant all 或者1234git clone *******cd **npm intallnpm start 需要多步才能做到的测试单个命令应该可以运行全部的单元测试，并输出结果和报告. 测试问题测试不足,未使用覆盖率工具. 一套测试中应该有多少个测试?CMMI将单元测试作为QA考核项,单元测试需考虑测试用例的代码覆盖率. 使用覆盖率工具能更容易地找到测试不足的模块,类和函数. 测试边界条件.特别需要注意测试边界条件.这是最基本的测试方法. 测试覆盖率都具备启发性,查看未执行和已执行测试的代码,往往能发现线索,有效的定位问题. 测试应该快速单元测试保障了代码的重构.重构行为给代码带来更长的生命周期和更高的质量. 函数问题过多的参数.最理想的参数数量是零,其次是一,再次是三,此类推,应避免三个以上的参数,符合职责单一原则. 输出参数.容易把输出参数误看做输入参数,应少用或不用输出参数. 标示参数.不要向函数传入布尔值.这不符合职责单一原则. 不被调用的函数.用不被调用的方法应该丢弃,直接删除,保留代码的整洁. 命名不明确.使用动词与关键字给函数去个好名字,能较好的解释方法的意图,以及参数的顺序和意图.]]></content>
      <categories>
        <category>开发者手册</category>
      </categories>
      <tags>
        <tag>新知类</tag>
        <tag>编码规则</tag>
        <tag>代码的味道</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Google的职业生涯：技术开发指导(学生)]]></title>
    <url>%2F2016%2F10%2F13%2Fgoogle-guide-to-development%2F</url>
    <content type="text"><![CDATA[Google的职业生涯：技术开发指导(面向学生)本指南列举各项领域知识和相关资源来帮助你学习和提高相关技术能力。 建议 资源 基础知识 计算机科学 掌握至少一门面向对象语言(C++, Java®, Python®) 初级程序员在线资源: - Java 程序设计 - 学习编程：基础 多伦多大学 - java编程介绍 MIT - 谷歌python教学 - python编程 莱斯大学 在线高级教程: - 面向对象 Java 程序设计 加州大学圣迭戈分校 - 计算机编程设计 - 学习编程：撰写高质量代码 多伦多大学 学习其他编程语言 - JavaScript® - CSS &amp; HTML - Ruby® - PHP® - C® - Perl® - Shell® script - Lisp® - Scheme® - CSS &amp; HTML - Ruby® - PHP® - Go® 在线资源: - Codecademy 调试代码 学习如何catch bugs，进行代码测试.在线资源:- 软件测试- 软件调试 提高离散数学的逻辑推理和知识 在线资源 - 计算机科学数学应用 MIT - 数学思维 斯坦福大学 - 概率图模型 斯坦福大学 - 博弈论 斯坦福科伦比亚大学 提高对算法和数据结构有很强的理解能力 熟悉基础数据类型（栈，队列，包），排序算法（快速排序，合并排序，堆排序），数据结构（二分搜索树，红黑树，哈希表）以及BIG O. 在线资源： - 算法简介 斯坦福大学 - 算法1&amp;算法2 普林斯顿大学 - 算法总览 维基百科 - 数据结构总览 维基百科 操作系统 在线资源： - 操作系统和系统编程 人工智能和机器学习 在线资源： - 机器学习工程师Nanodegree Udacity - 深度学习 Udacity - 机器人技术 斯坦福大学 - 机器学习 斯坦福大学 安卓开发 在线资源： - 谷歌Android开发教学 web开发 在线资源： - 谷歌web开发教学 学习其他开发技术 在线资源： - 谷歌工程师培训站点 学习密码学 在线资源： - 密码学 - 密码学应用 在一个代码库里工作，通过阅读优秀的代码来提高你的编码，文档以及debug能力 - Github - Klin 和其他程序员一起工作 这将有利于锻炼你的团队合作能力并使你从学习其他人的优点 锻炼你的算法知识和编程技巧 通过编程竞赛（CodeJam，ACM）锻炼你的算法知识 成为导师助理 通过指导其他学生将能有效增强和巩固你的知识体系]]></content>
      <categories>
        <category>开发者手册</category>
      </categories>
      <tags>
        <tag>新知类</tag>
        <tag>Google</tag>
        <tag>职业指导</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker使用手册]]></title>
    <url>%2F2016%2F09%2F27%2Fdocker-manual%2F</url>
    <content type="text"><![CDATA[什么是Docker?先看一段Docker创始人的一段视频: Ship! Docker就是用来解决日渐繁杂的开发和生产环境的痛点问题的!大大简化了软件开发的流程和环境搭建的复杂性,解放重复劳动,让技术人员更关注功能和需求. Docker的产生是为了解决以下的问题: 环境管理复杂:从各种OS到中间件到APP,开发者需要关心太多的东西,Docker可以通过镜像分享的形式简化部署多应用实例. 虚拟化手段变化:采用虚拟化手段满足用户按需分配的资源需求以及保证可用性和隔离型. 如何学习一种工具和技术?入门非常的容易 上官网,跟着教程走 下载DOCKER FOR WINDOWS SERVER安装 非win10 pro,得安装docker toolbox 安装后,上docker hub pull一个镜像下来. 试运行下 Docker run hello-world 发现已经被墙了,google之,配置DaoCloud的Docker加速器 1234docker-machine ssh defaultsudo sed -i &quot;s|EXTRA_ARGS=&apos;|EXTRA_ARGS=&apos;--registry-mirror=加速地址 |g&quot; /var/lib/boot2docker/profileexitdocker-machine restart default 开胃菜结束,进入主菜 Docker OverviewDocker是一个用于Developing,shipping,running应用的开放平台. 先预览一下,之后我们需要弄清楚以下几个问题. Docker是什么? Docker是如何驱动的? Docker能解决什么问题? Docker的架构? 什么是Docker平台?Docker提供管理容器生命周期的工具和平台: 将你的应用[包括组件]打包到Docker容器内 分发这些容器到团队,进行进一步的开发和测试 将应用发布到生产环境 Docker引擎?Docker是C/S结构的应用,Server是守护程序常驻内存,Client通过REST API和Server交互. Docker解决什么问题?快速可持续行的发布应用开发人员本地编码并通过分享Dorker容器进行集成,测试,发布 按需部署和裁剪Docker容器具备很高的移植性,它可以在开发人员的本地环境运行,也可以在数据中心,云的物理和虚拟环境中运行. 同一个硬件环境提供更高的负载Docker的架构? Docker daemonServer守护程序,用户通过Docker client和它交互 Docker Client用户和Docker交互的主要工具,使用命令行和配置和Docker damon进行交互. Docker内部结构imagesDocker的镜像是只读的模板,用于指示Docker创建容器的,由Dockerfile文本文件来描述.说白了就是Docker的Build组件. containers可运行的Docker image实例.是Docker的运行组件. registriesdocker registry是镜像库,是Docker的分发组件. Docker的容器如何加载和运行?$ docker run -i -t ubuntu /bin/bash 当运行一条命令,Docker引擎会进行一系列的处理来加载和运行容器: 获取ubuntu镜像: Docker引擎首先在本地查找镜像,如果存在就作为新的容器加载进来,如不存在就从Docker hub获取镜像 创建一个新的容器:Docker使用image创建容器 配置文件系统并加载一个读写层: 在文件系统里创建容器并将读写层让入image 配置网络接口:创建一个网络接口,允许Docker容器和local host交互 配置IP地址: 查找并绑定一个可用的ip地址 执行命令: 执行/bin/bash 应用输出:连接应用标准输入,输出,错误接口,供交互. 入门示例构建image从Docker hub获取whalesay镜像1234567891011121314151617181920212223242526272829$ docker run docker/whalesay cowsay booUnable to find image &apos;docker/whalesay:latest&apos; locallylatest: Pulling from docker/whalesaye9e06b06e14c: Pull completea82efea989f9: Pull complete37bea4ee0c81: Pull complete07f8e8c5e660: Pull complete676c4a1897e6: Pull complete5b74edbcaa5b: Pull complete1722f41ddcb5: Pull complete99da72cfe067: Pull complete5d5bd9951e26: Pull completefb434121fc77: Already existsDigest: sha256:d6ee73f978a366cf97974115abe9c4099ed59c6f75c23d03c64446bb9cd49163Status: Downloaded newer image for docker/whalesay:latest _____&lt; boo &gt; ----- \ \ \ ## . ## ## ## == ## ## ## ## === /&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;___/ === ~~~ &#123;~~ ~~~~ ~~~ ~~~~ ~~ ~ / ===- ~~~ \______ o __/ \ \ __/ \____\______/ 写一个Dockerfile123FROM docker/whalesay:latestRUN apt-get -y update &amp;&amp; apt-get install -y fortunesCMD /usr/games/fortune -a | cowsay 编译image1$ docker build -t docker-whale . 编译流程 首先,Docker校验编译所需要素. 1Sending build context to Docker daemon 2.048 kB Docker加载whalesay镜像.镜像已经在本地,所以不需要再去下载. 12Step 1 : FROM docker/whalesay:latest ---&gt; 6b362a9f73eb Docker更新apt-get包管理器 1234567Step 2 : RUN apt-get -y update &amp;&amp; apt-get install -y fortunes ---&gt; Running in 21b7de6678a8Ign http://archive.ubuntu.com trusty InReleaseGet:1 http://archive.ubuntu.com trusty-updates InRelease [65.9 kB]Get:2 http://archive.ubuntu.com trusty-security InRelease [65.9 kB]Hit http://archive.ubuntu.com trusty Release.gpgGet:3 http://archive.ubuntu.com trusty-updates/main Sources [474 kB] 安装fortunes 12345678Reading state information...The following extra packages will be installed: fortune-mod fortunes-min librecode0Suggested packages: x11-utils bsdmainutilsThe following NEW packages will be installed: fortune-mod fortunes fortunes-min librecode00 upgraded, 4 newly installed, 0 to remove and 87 not upgraded. 完成编译 12345Step 3 : CMD /usr/games/fortune -a | cowsay ---&gt; Running in 3a10806db557 ---&gt; e02e38c358dbRemoving intermediate container 3a10806db557Successfully built e02e38c358db 运行新的docker-whale123456789101112131415161718docker run docker-whale/ Everyone has a purpose in life. Perhaps \| yours is watching television. || |\ -- David Letterman /----------------------------------------- \ \ \ ## . ## ## ## == ## ## ## ## === /&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;___/ ===~~~ &#123;~~ ~~~~ ~~~ ~~~~ ~~ ~ / ===- ~~~ \______ o __/ \ \ __/ \____\______/ Docker hub使用Docker hub对镜像进行配置管理,和Git使用方式类似. 容器命名1$ docker run -d -P --name web training/webapp python app.py 容器挂载管理Docker ComposeCompose是一个定义和运行多Docker容器应用的工具. 使用Compose通常有3个步骤: 将应用的环境定义到Dockerfile,以便在其他地方可以复用. 在docker-compose.yml将应用定义为服务,这样你可以在解耦的环境中运行 最后,执行docker-compose up docker-compose.yml大致内容如下: 123456789101112131415version: &apos;2&apos;services: web: build: . ports: - &quot;5000:5000&quot; volumes: - .:/code - logvolume01:/var/log links: - redis redis: image: redisvolumes: logvolume01: &#123;&#125; Compose的使用场景 开发环境 自动化测试环境 单站部署 使用指南跟着官网教程 Docker MachineDocker Machine说白了就是个Docker Server集群管理的client端,便于远程发布和部署Docker应用 Docker应用到项目开发方法 如果是新的团队,那没什么问题,起初就可以商量好.如果是已经比较成熟的团队,Docker逐步嵌入到几个持续集成的流程中去.应用Docker到软件开发的流程,首先需要解决几个问题. Base Image的选择, phusion-baseimage 配置管理Docker镜像的工具的选择，如Ansible、Chef、Puppet Host主机系统的选择，如CoreOS、Ubuntu 使用持续集成工具(Jenkins)进行管道部署进行持续集成 使用Google Kubernetes进行生产部署 Docker的集成测试部署之道 Docker文件挂载Docker image打包发布的时候,如果源码也一并放在image里是不合理的,所以具体开发过程中需要将宿主文件挂载到Docker容器里. windows下开发环境windows在vxbox的虚拟机在起Docker,所以需要迂回挂载. 利用vxbox共享 设置vxbox共享文件夹 进入vxbox虚拟机,将windows目录挂载到虚拟机,如： 1sudo mount -t vboxsf project /mnt/data 进入Docker终端，-v启动挂载到容器 1docker run -it -v /mnt/data:/usr/data ubuntu:trusty Docker常用命令清除 停止所有container 1docker stop $(docker ps -a -q) 删除所有container 1docker rm $(docker ps -a -q) 删除所有images 1docker rmi $(docker images -q) Docker的坑希特勒吐槽Docker Docker工具 Kubernetes InfoQ上的Docker]]></content>
      <categories>
        <category>开发者手册</category>
      </categories>
      <tags>
        <tag>新知</tag>
        <tag>开发环境</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[攻城狮周记(五)]]></title>
    <url>%2F2016%2F09%2F26%2Freadmemo%2F</url>
    <content type="text"><![CDATA[Fintech细分领域研究报告随着科技的发展，大数据和人工智能等前沿科技早已介入金融领域。Fintech美国已经领先中国很多,是一个好的领域.原文 大数据团队建设 数据基础服务团队，负责Hadoop、Spark、Hbase、Hive等基础组件的运维、开发和优化； 数据开放平台团队； 数据仓库团队，负责统一的数据仓库，力图解决数据不一致、口径不一致、模型不一致以及数据质量等问题； 数据挖掘团队，偏算法研究与建模，负责核心应用开发。 质量控制（QA）团队，主要负责软件测试及DevOps流程贯彻落地。 项目管理团队，有专门的项目管理团队负责项目需求及进度。 数据分析纬度一个优秀的数据分析师是怎样炼成的？ # 前端知识库知识库 开源大数据工具原文 微信小程序微信小程序简易教程 如何讲故事?原文 数据挖掘四大信仰信仰1：不以具体业务场景出发，不考虑大数据并发实现的数据挖掘，都在耍流氓；信仰2：知其然，晓其所以然，万变不离其宗，必定变化莫测，这正是算法魅力；信仰3：在DataMining领域，不做两种人。一种是工具人，一种是研究者；信仰4：拥有健康、丰满的数据，业务场景建模已经成功90%以上了；]]></content>
      <categories>
        <category>攻城狮周记</category>
      </categories>
      <tags>
        <tag>大数据</tag>
        <tag>新知</tag>
        <tag>前端</tag>
        <tag>数据挖掘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IONIC2使用感想]]></title>
    <url>%2F2016%2F09%2F22%2Fionic2-%2F</url>
    <content type="text"><![CDATA[IONIC2基于Angular2,属于Ponegap体系,和RN都是我比较看好的框架,都还未正式发布.之所以会去使用它,完全是因为Typescript的缘故,TS作为ES/JS的超集使用起来比较方便. Ionic2处于Beta阶段,现在社区不活跃,资源也相对比较少,和我去年预研RN时候不同,RN是由于迭代太快,坑太多,但社区还是比较活跃的.如今RN已如日中天…,但不差钱还是要选择原生技术. 期间看了下官网的一个实例conference,并移植和改写了一个示例ionic2-realty,也算入了门了. 这类框架也称不上预研,入门门槛比较低,当然要精通都不是一蹴而就的,需要时间和经验的积累. 过早的使用某种技术势必要填很多的坑.于是在不断的填坑和弃坑中,度日如年…]]></content>
      <categories>
        <category>开发者手册</category>
      </categories>
      <tags>
        <tag>Ionic</tag>
        <tag>移动开发</tag>
        <tag>混合开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[My little trouble]]></title>
    <url>%2F2016%2F09%2F22%2Fmy-little-upset%2F</url>
    <content type="text"><![CDATA[碎片化的时代,获取了太多的垃圾信息,最近又想的太多.于是最近就变得比较焦虑,异常的焦虑. 两年前回到宁波,这里的好企业真的太少了,尤其是技术类的.最后进入互联网的领域,web,app大部分都毫无技术含量,发现已于研发越走越远. 反复思考自己的职业规划,思考自己想要什么.近几年换工作比较频繁,切换了不同的领域,由于具备通用的专业能力,知识的转化率都还算高.眼界虽宽了很多,但还是缺乏某一个领域深度,没有享受到领域知识的时间复利,一直处于开荒状态,不能进行有效的farm. 我觉得必须开始经营自己的品牌: 精进一项核心技能 混圈子 持续的自我进化 于是问题来了,这次换还是不换呢?]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[攻城狮周记(四)]]></title>
    <url>%2F2016%2F09%2F12%2Freadmemo%2F</url>
    <content type="text"><![CDATA[你的收入，为什么还没有指数增长？ 两个乞丐在比划说，我要是当上了皇帝，我要饭时候的那个碗，必须是纯金的。 打造自己能力的”单品爆款”,要专注,专业需要时间的积累. 做有价值的事,让自己增值. 经常复盘,我们要在有限的时间里，多做些战略上的努力，而不是战术层面的付出。原文 Saas产品如何运营原文 在大数据时代，每家公司都要有大数据部门吗？大数据都知道是一个方向,问题是谁能站在浪潮之巅?原文 邮件营销平台实践没接触过这个领域,长了点见识.邮件营销平台实践 直播技术代码居多原文 深度学习主题下周专题深入研究原文 Git配置管理git的配置管理和SVN有较多不同.SVN默认有三条配置流,trunk,branch,tag. git的master并不是svn的trunk,趋同于svn的tag,是对外可发布版本的最终标示,是一个完整的可部署的生产版本. 以下是一个不错的git配置管理模型: feature（多个、玫红）。主要是自己玩了，差不多的时候要合并回develop去。从不与master交互。 develop（1个、黄色）。主要是和feature以及release交互。 release（同一时间1个、绿色）。总是基于develop，最后又合并回develop。当然对应的tag跑到master这边去了。生命周期很短，只是为了发布 hotfix（同一时间1个、红色）。总是基于master，并最后合并到master和develop。生命周期较短，用了修复bug或小粒度修改发布。 master（1个蓝色）。没有什么东西，仅是一些关联的tag，因从不在master上开发。 在这个模型中，master和develop都具有象征意义。master分支上的代码总是稳定的（stable build），随时可以发布出去。develop上的代码总是从feature上合并过来的，可以进行Nightly Builds，但不直接在develop上进行开发。当develop上的feature足够多以至于可以进行新版本的发布时，可以创建release分 支。 release分支基于develop，进行很简单的修改后就被合并到master，并打上tag，表示可以发布了。紧接着release将被合 并到develop；此时develop可能往前跑了一段，出现合并冲突，需要手工解决冲突后再次合并。这步完成后就删除release分支。 当从已发布版本中发现bug要修复时，就应用到hotfix分支了。hotfix基于master分支，完成bug修复或紧急修改后，要merge回master，打上一个新的tag，并merge回develop，删除hotfix分支 主分支:master,develop, master分支为稳定版本,develop为整合分支可在之上进行日编译和持续集成.辅助分支:feature(功能开发),hotfix(热补丁),release(发布整合),生命周期较短 feature 分支使用规范： 可以从develop分支发起feature分支 代码必须合并回develop分支 feature分支的命名可以使用除master，develop，release-，hotfix-之外的任何名称 release分支使用规范 可以从develop分支派生 必须合并回develop分支和master分支 分支命名惯例：release-* release分支是为发布新的产品版本而设计的。在这个分支上的代码允许做小的缺陷修正、准备发布版本所需的各项说明信息（版本号、发布时间、 编译时间等等）。当develop分支上的代码已经包含了所有即将发布的版本中所计划包含的软件功能，并且已通过所有测试时，我们就可以考虑准备创建 release分支了。成功的派生了release分支，并被赋予版本号之后，develop分支就可以为“下一个版本”服务了。所谓的“下一个版本”是在当前即将发布的版本之后发布的版本。版本号的命名可以依据项目定义的版本号命名规则进行。 hotfix分支使用规范： 可以从master分支派生 必须合并回master分支和develop分支 分支命名惯例：hotfix-*和release分支一样hotfix分支都会产生新的版本号. 人员权限开发人员:feature,hotfix技术经理:feature,develop,hotfix,release运维:release,master测试人员:develop,release,master 原文 git基础 VC经济基本概念 VC经济基本概念 决策分析模型]]></content>
      <categories>
        <category>攻城狮周记</category>
      </categories>
      <tags>
        <tag>大数据</tag>
        <tag>新知</tag>
        <tag>Git配置管理</tag>
        <tag>Sass</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[攻城狮周记(三)]]></title>
    <url>%2F2016%2F09%2F05%2Freadmemo%2F</url>
    <content type="text"><![CDATA[Yahoo开源Pulsar：大规模的发布/订阅（Pub-Sub）消息传递平台yahoo/pulsar python进行数据分析 基础知识:set,list,dict等数据架构 学习数据处理库:numpy,pandas等模块 csv,数据库等导入导出 爬虫:爬豆瓣,然后爬动态网站,爬的动80%的网站后,再挑战下淘宝,天猫等 web: django, flask, highcharts 文本挖掘:jieba分词模块 人工智能之机器学习路线图 精通机器学习的5本免费电子书原文 医学影像,成像蓝海原文 互联网数据分析书籍清单数据分析是一个好行当,部分书籍已看过.原文 打破定制旅游的产能边界原文 视频直播技术编码和封装原文 如何成为一名数据科学家原文]]></content>
      <categories>
        <category>攻城狮周记</category>
      </categories>
      <tags>
        <tag>新知</tag>
        <tag>数据分析</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我皮肤上的字]]></title>
    <url>%2F2016%2F09%2F02%2Fthe-words-on-my-skin%2F</url>
    <content type="text"><![CDATA[翻译自科幻小小说,转载请注明出处. 原文 我的皮肤上写着字,字代表了我的个性. 我身上最大那几个字是母亲写的-机灵,有爱,随和,守记.它们写在我的背上,这是我自己无法接触的皮肤. 母亲的那几个最大的字叫体贴,由她的爸爸所赐,整个字填满了她的整个右手臂. 六岁,我还不太识字,我偷了母亲的那个笔,为自己选择了第一个词–快乐.当这两个字歪歪扭扭的出现在我的整个左前臂上时,母亲震惊了.私下在皮肤上写字的是违法的,母亲可能会因此失去持笔者的资格.但是母亲没有生气,她的身上没有愤怒,取而代之的是耐心和谅解. 持笔机制是这样的,只有少数的家庭成员负责持笔,成为持笔者就意味着更多的权利和责任,他们需要对用笔情况做备案报告,还时不时要受审查.违背了持笔规则会受到非常严厉的制裁.这种规则意图控制笔的滥用,但事实上,审查人员非常的腐败,用点金钱就可以买通了. 于是十岁,我又几次偷偷的在身上写了字–聪明,鬼祟,独立,一次也没被抓住. 十四岁,我半夜起来,再次在自己的大腿内侧写上–热情,敏感,轻浮.母亲为此多年没有和我说话,她默默在我的背上增加了三个词–责任,真实,谨慎. 母亲的管教激发了我的叛逆,我报复性在整个左身体写上了–艺术,粗鲁,野心,玩乐,爱交际,固执.母亲假装没有看到,她可能不想激化我们之间的矛盾,她也可能默许了我的选择,总之,她沉默了. 十八岁,我搬出了家,我给自己写上自信和性感. 我开始和一个老男人约会,我疯狂的爱上了他.他并不来自持笔者的家庭,所以他身上的词语非常匮乏,只有三个–勇敢,健壮,迷人.和他在一起很幸福,直到我发现了他的秘密和谎言.于是趁他睡着的时候,我冲动的在他的后劲(靠近耳朵那,他永远也不会看到那个地方)写上–忠诚,信任,诚实,有爱.结果第二天早上,他离我而去,再也没有回来. 我不知道他应该忠于谁,但我知道那个人不是我. 之后我又陷入到几场短暂的关系里,我的责任感和谨慎已经被刺激,狂野淹没了.我变得鲁莽而歇斯底里,虽然我身上并没有这些字.我感到茫然,我举足无措,更让我沮丧的是,我还怀孕了… 虽然母亲和我已经几个月没有联系了,我还是去了她那里.我很害怕她又会在我身上写字,害怕她会把我变成另外一个人,但她没有,她倾听了我的遭遇,安抚了我的焦虑,她耐心的等待着我,等待我持笔为自己写下此刻最需要的那几个字–母爱,信赖,聪慧. 现在,我的身上已经没有太多的位置可以写了,字越写越小,我的个性也变得越来越固定,不大会有太大的变化.我必须得小心翼翼的选词了,想着想着,我开始为年幼时候的冲动选择后悔万分,我对着母亲大声发泄着,”就让我这样吧”,我的眼泪和悔恨绝提而出. 随着宝宝的成长,我肚子上的皮肤延伸开来了,我落笔在这个额外的空间写上了–坚韧,力量,坚持,冷静, 这将有助于我的分娩. 我顺利产下了一个健康的男孩,他的皮肤就像一块空帆布,崭新而又纯粹,也承载了太多别人的期许. 母亲递给我那支笔,我准备在那张空白的背上写下什么. 什么词是宝宝最适合的?母亲和我苦思冥想. 我终于明白了应该写的字,但那些字不应该由我来写. 我于掰断了笔芯,把笔扔的远远的. 我爱我的儿子,不管他会变成什么. 他可以去做自己了.]]></content>
      <categories>
        <category>小说</category>
      </categories>
      <tags>
        <tag>翻译</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[攻城狮周记(二)]]></title>
    <url>%2F2016%2F08%2F30%2Freadmemo%2F</url>
    <content type="text"><![CDATA[百度Github技术栈原文 众安保险战略路线图原文 浏览器存储及使用原文 RN在直播应用中的实践原文 从0到N建立高性价比的大数据平台原文 直播技术知识库干活一瞥原文 一切商业皆内容,一切内容皆IP原文]]></content>
      <categories>
        <category>攻城狮周记</category>
      </categories>
      <tags>
        <tag>新知</tag>
        <tag>百度技术栈</tag>
        <tag>直播技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[攻城狮周记(一)]]></title>
    <url>%2F2016%2F08%2F22%2Freadmemo%2F</url>
    <content type="text"><![CDATA[每周花时间阅读技术文章,摘录精华 花1小时写代码，就要花10小时检查代码。查找漏洞都成了写代码的一部分了，这个差距太悬殊。就算写代码多费点时间，代码也要简单易懂。—— Robert C. Martin《Clean Code: A Handbook of Agile Software Craftsmanship》 高性能开源通用RPC框架,谷歌出品以前用RPC开发过一个分布式系统,那么gRPC又是什么? 与许多 RPC 系统类似，gRPC 也是基于以下理念：定义一个服务，指定其能够被远程调用的方法（包含参数和返回类型）。在服务端实现这个接口，并运行一个 gRPC 服务器来处理客户端调用。在客户端拥有一个存根能够像服务端一样的方法。 grpc 高并发系统HTTP缓存 服务端响应的Last-Modified会在下次请求时以If-Modified-Since请求头带到服务端进行文档是否修改的验证，如果没有修改则返回304，浏览器可以直接使用缓存内容； Cache-Control:max-age和Expires用于决定浏览器端内容缓存多久，即多久过期，过期后则删除缓存重新从服务端获取最新的；另外可以用于from cache场景； http/1.1规范定义的Cache-Control优先级高于http/1.0规范定义的Expires； 一般情况下Expires=当前系统时间+缓存时间（Cache-Control:max-age）； http/1.1规范定义了ETag来通过文档摘要的方式控制。 nginx缓存配置见原文 携程大数据实践：高并发应用架构及推荐系统案例有比较大的参考价值,当然整体架构都描述的比较笼统. 应用系统的整体架构 数据源部分，Hermes是携程框架部门提供的消息队列，基于Kafka和MySQL做为底层实现的封装，应用于系统间实时数据传输交互通道。Hive和HDFS是携程海量数据的主要存储，两者来自Hadoop生态体系。 离线部分，包含的模块有MR、Hive、Mahout、SparkQL/MLLib。Mahout提供基于Hadoop平台进行数据挖掘的一些机器学习的算法包。Spark类似hadoop也是提供大数据并行批量处理平台，但是它是基于内存的。SparkQL 和Spark MLLib是基于Spark平台的SQL查询引擎和数据挖掘相关算法框架。携程主要用Mahout和Spark MLLib进行数据挖掘工作。 调度系统zeus，是淘宝开源大数据平台调度系统. 近线部分，是基于Muise来实现我们的近实时的计算场景，Muise是也是携程OPS提供的实时计算流处理平台，内部是基于Storm实现与HERMES消息队列搭配起来使用。例如，我们使用MUSIE通过消费来自消息队列里的用户实时行为，订单记录，结合画像等一起基础数据，经一系列复杂的规则和算法，实时的识别出用户的行程意图。 后台/线上应用部分，MySQL用于支撑后台系统的数据库。ElasticSearch是基于Lucene实现的分布式搜索引擎，用于索引用户画像的数据，支持离线精准营销的用户筛选，同时支持线上应用推荐系统的选品功能。HBase 基于Hadoop的HDFS 上的列存储NoSQL数据库，用于后台报表可视化系统和线上服务的数据存储。 这里说明一下, 在线和后台应用使用的ElasticSearch和HBase集群是分开的，互不影响。Redis支持在线服务的高速缓存，用于缓存统计分析出来的热点数据。 系统案例 数据源，分结构化数据和非结构化数据. 离线计算,经过数据预处理,数据挖掘,和数据配置后(建立ES索引),输出产品画像,用户画像等. 近线计算,输出用户意图和产品缓存. 全文 大数据4V特征大数据的特点,按照IBM提出的,4V特性: Volume(海量): 数量大 Velocity(速度): 数据量增长快 Variety(多样性): 各种各样类型的数据出现 Varacity(准确性): 数据的准确性 日志分析智能化日志是企业内部宝贵的IT大数据,相比excel和数据库而言,日志是非结构化数据,需要进行进一步的挖掘. 日志分析产品:Splunk,ELK,日志易 日志易的技术架构: 实现了搜索处理语言SPL（Search Processing Language），用户可以在搜索框里编写SPL脚本，对日志进行复杂的关联分析，非常强大、灵活，实现了“框计算” IOS动态更新方案JSPatch 是 iOS 平台上的一个开源库，只需接入极小的三个引擎文件，即可以用 JavaScript 调用和替换任意 Objective-C 方法，也就是说可以在 App 上线后通过下发 JavaScript 脚本，实时修改任意 Objective-C 方法的实现，达到修复 Bug 或动态运营的目的。 如果作为热更新工具,相比RN,更轻量级,更稳定些,学习成本也稍低些. 人工智能的挑战人工智能技术前景? 无监督预测学习,例如联想能力; 单例(有限例)学习; 结合贝叶斯统计的深度学习，使得融入由因到果或互为因果的relation变得容易； 层级增强的memory，reasoning，planning的表征方法； 深度增强学习； 动态neural turing machine及其变种。这些技术的落地应用,可以使得相当程度的机器智能改善人类生活,例如机器助理,自动驾驶,智能服务等. 技术人员需要学习那些人工智能技术? 人工智能未来应该是一种工具,会用就好,软件工程师需要考虑如何将人工智能的工具应用到实际产品中. 人工智能是一种思维方式,工程师重新审视自己的工作方式:是否可以借鉴AI来改善和提升现在的工作? 移动端高效实用SQLite原文 移动端少量的KV类型数据库可以直接存在文件上,稍微复杂一点的格式化成JSON或XML保存.在更大的量级上则需要使用SQLite. 数据库初始化设置合理的page_size和cache_sizeSQLite 数据库把其所存储的数据以 page 为最小单位进行存储。cache_size 的含义为当进行查询操作时，用多少个 page 来缓存查询结果. 可能影响到 page_size 和 cache_size 最优值选取的三个因素： table_size 存储的数据类型 增删查改比例 通过timer控制数据库事务定时提交一个Transaction能够大大的提升其内部的增删改查操作的速度.事务的引入能提升性能两个数量级以上. 数据库完整性校验移动客户端的数据库运行环境比较复杂,需呀校验数据库的完整性, 1PRAGMA integrity_check 如执行失败就需要回滚到上一个版本. 数据库升级逻辑可以在meta表中并加入版本号,SQL语句需通过版本号来提供兼容性. 123CREATE TABLE meta (key LONGVARCHAR NOT NULL UNIQUE PRIMARY KEY, value LONGVARCHAR)INSERT OR REPLACE INTO meta (key,value) VALUES (version, 1)INSERT OR REPLACE INTO meta (key,value) VALUES (last_compatible_version, 1) 高效SQL语句 建立索引，就是将这列以及主键所有数据取出。以索引列为主键按照升序，原表主键为第二列，重新创建一张新的表。使其搜索速度降低到 Log(N)。 先SELECT 再选择 INSERT OR UPDATE 的方法。 FTS(Full Text Search)是SQLite未加快字符串搜索而创建的虚拟表.通过分词大大加快英文类/中文类字符串(配合ICU)的搜索速度. 为做到数据库Model跨IOS,Android平台,用protobuf作为数据库的输入输出参数.两个平台用一份proto文件分别生成各自的实现文件. 不是用SQLite的多线程实现,多线程会增加线程开销而且操作加锁,性能比较差. 加密数据库.加密对性能损耗大约是3%的CPU时间. 移动端开发流程 web端流程. 产品经理提出需求(原型等)&gt;讨论需求&gt;通过需求&gt;交付设计师设计layout&gt;确认&gt;切页面&gt;交付工程师开发&gt;后端(前端)定接口&gt;前后端并行开发&gt;修改细节及bug&gt;上线。 移动客户端. 产品经理提出需求(原型等)&gt;讨论需求&gt;通过需求&gt;设计layout(包括交互设计及ui设计)&gt;确认&gt;切图&gt;交付工程师开发&gt;后端接口开发/移动开发&gt;上线。 大体上的流程都不会变,移动端的如果使用Native开发,那前端就消失了,切图部分交给UI来做. 移动端的产品设计交互性和逻辑性会更强,所以原型设计需要由设计把控交互部分,如果产品经理无法把控交互部分,至少要画出概念图和流程图,交给设计师进行设计. 移动设计相比web端设计有一些异同点: 字体选用. web端一般是宋体或者微软雅黑. IOS:冬青黑体或者华文黑体. Android: Droid Sans Fallback, 冬青黑或者华文黑也可以考虑. 简单易用. 分辨率. iphone + andorid存在大量的分辨率,需要设计适配. 切图. 安卓和iphone差别交互设计. 架构设计主要是后端,需要考虑如何提供高性能的API接口,接口的制定可以由后端牵头也可以由移动开发人员牵头. 运营产品核心指标分析流程电商产品 SaaS类产品和移动用户产品的核心指标 内容网站关注的核心指标 UGC,社交站关注的核心指标 双边市场(服务方与提供服务方)关注的指标 融资相关流程异步36氪]]></content>
      <categories>
        <category>攻城狮周记</category>
      </categories>
      <tags>
        <tag>大数据</tag>
        <tag>新知</tag>
        <tag>gRpc</tag>
        <tag>架构</tag>
        <tag>SQLite</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[活着为了讲述]]></title>
    <url>%2F2016%2F08%2F13%2Fvivir-para-contarla%2F</url>
    <content type="text"><![CDATA[我是个爱讲故事的孩子,我想说的是:爱真的存在,幸福真的可能,死神也会败在幸福的手下. 《活着为了讲述》是诺贝尔文学奖获得者，《百年孤独》作者加西亚·马尔克斯唯一传记,14年,新闻头条报道了这位文学巨匠的陨落,当时就非常想看这本书.马尔克斯是个爱讲故事的人,在虚实之间，在&lt;&lt;活着为了讲述&gt;&gt;里他亲自讲述了自己的故事。 马尔克斯出生于哥伦比亚马格达莱纳的一个海滨小镇–阿拉卡塔卡,童年和外祖父母一起生活.他的父亲和大多数的欧美父母一样,希望他以后过上体面而稳定的生活–做一个律师,但马尔克斯对写作有着无限的遐想和热情,’要么写作,要么死去!’,’个人志向与生俱来,背道而驰,有违健康.顺势而行,灵丹妙药’.马尔克斯不但成为了一个作家,更跃升成为20世纪伟大的文学大师之一. 自传里提及了他非常多的短篇小说,一个灵感就促成了一篇故事,受卡夫卡《变形记》启发的《第三次忍受》,因美女一句话而写成的《埃娃在猫身体里面》,石鸻鸟啄人一触而就《石鸻鸟之夜》,遗憾的是这本自传并未完成,最后停留在马尔克斯的青年时期,那个时候&lt;&lt;百年孤独&gt;&gt;还未问世,还藏匿在&lt;&lt;家&gt;&gt;中,也许在他心中这才是真实的自己,&lt;&lt;百年孤独&gt;&gt;的成功反而成为一种桎梏. 马尔克斯的&lt;&lt;活着为了讲述&gt;&gt;即像小说又像自传,他自述了一个浓缩的世界,喧嚣纷乱却又生动可信的显示了一片大陆及其人民的富足和贫困,以及,妖娆妩媚的哥伦比亚女人在这个贫穷,落后的,但充满生机的小镇里抽烟,喝酒,调情,生育和生存… 生活不是我们活过的日子,而是我们记住的日子,我们为了讲述而在记忆中重现的日子.]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>消遣</tag>
        <tag>百年孤独</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[讲故事的人：斯皮尔伯格传]]></title>
    <url>%2F2016%2F08%2F10%2FSteven-Allan-Spielberg%2F</url>
    <content type="text"><![CDATA[其实每一部电影都是一个时间胶囊,当你拍完一部影片,向演职人员道别时,你也把一段生命埋在了那个片场——你知道的,而那段生命将会永远留在那里. 史蒂文·斯皮尔伯格1946年12月18日出生于俄亥俄州的辛辛那提市一个美国犹太家庭，12岁就开始执导,是个天才.在长达40多年的岁月里,史蒂文·斯皮尔伯格创造了鼓舞人心并且令人难以忘怀的影坛奇迹.他执导的电影范围也很广,惊悚片’&lt;&lt;大白鲨&gt;&gt;’,科幻片’&lt;&gt;’,动作片’&lt;&lt;夺宝奇兵&gt;&gt;’,剧情片’&lt;&lt;辛德勒的名单&gt;&gt;’,战争片’&lt;&lt;太阳帝国&gt;&gt;’钧有代表作. 斯皮尔伯格的电影我大部分都看过,印象比较深的还属&lt;&lt;辛德勒的名单&gt;&gt;.那时我还在大学里,不识愁滋味,过着一天5部电影的日子… 评价一本书的好坏需要50年以后,评价一个人一样,所以一本写当世人的传记更是不好写的,这需要岁月的沉淀和时间的审批.不过这本书也不应该称为传记,充其量是一些访谈语录加上对斯皮尔伯格电影创作的一些梳理,有电影创作的幕后故事以及创作意图但并未深入,作者的文笔也比较一般. 全书的插图较多,但排版太差,打乱了几次正文的衔接,尤其是在不熟悉的时候,比如翻看第一页的时候正文断了,第二页接了两页插图,第四页才是续接的正文,实在让人摸不清道不明. 适合电影爱好者购入,翻看,收藏. {:height=”120px” width=”120px”}]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>博闻</tag>
        <tag>电影</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[渴望生活]]></title>
    <url>%2F2016%2F08%2F09%2Flust-for-life%2F</url>
    <content type="text"><![CDATA[开启不同于前人的艺术，启发后人的艺术，这就是梵高作品的伟大之处。 梵高.温森特励志成为一名福音传教士,由于他并未完成传教士的学业,于是屈就到博里那日的矿区传教.他感受到了博里那日煤矿工人生活的艰辛和他们的朴实,然而在一次矿井坍塌事故中,矿产公司的残忍,福音教会的傲慢偏执和不作为,让他开始质疑上帝的存在,上帝放弃了这些朴实和卑微的旷工.他也因此失去了成为传教士的资格,失去了上帝,失去了自己. 他明白了有些上帝的话,不过是孩子气的借口和托词,是一个吓坏了的孤独的人在寒冷,漫长的黑夜中,由于绝望而散布编造的谎言.没有什么上帝,事情就是这么简单.压根就没有上帝,只有混乱–悲惨的,痛苦的,残忍的,莫名其妙的,无止无休的混乱. 吃土豆的人,1885 梵高在上帝退场后,终于投入了绘画的怀抱.他并没有绘画的基础,虽然他的画比例失调,但他的画有一些说不清道不明的东西…… 梵高过于迷恋绘画,显然他周围的人都无法理解,’有谁会盯着一颗树,顶着一头烈日,画一天的画呢’.在他穷困潦倒的一生里全靠他的弟弟提奥资助过活.在经常饿着肚子,发着烧,身无分文的情况下,梵高完成一副又一副的作品,他对绘画的热爱是狂热的,犹如他对爱情的渴望那样,虽然他的爱情总是不顺的. 人的行为,非常像画画.整个透视关系随着眼睛的变化而变化,起决定作用的并不是被绘画的对象,而是正在看它的人. 塞纳河上的桥,1886 梵高早期在荷兰自学绘画,最后到了巴黎–这座艺术的天堂,他才受到了艺术的召唤,他的艺术形态开始形成.在那他受到了前所未有的冲击,他的画是那么的与众不同,不同到差点让他放弃绘画生涯,梵高的画色彩强烈，色调明亮。他那富于激情的旋转、跃动的笔触，则使他的麦田、柏树、星空等，有如火焰般升腾、颤动，震撼观者的心灵。在他的画上，强烈的情感完全溶化在色彩与笔触的交响乐中,他是表现主义的先驱. 梵高觉得巴黎过于喧嚣于是独自一人来到了法国南方的城市’阿尔勒’,重新过上了贫困的,清苦的,但是纯粹的只有绘画的生活. 我在寻求,我在奋斗,我在全心全意的投入到艺术之中.我不属于这儿。我是个农民画家，我要回到我的田野上去。我要找到一个太阳，它炽热得能把我心中除了绘画这种慾望以外的一切都烧光。 向日葵,1888 在阿尔,他精神已经有些不正常了,他知道了,长时间观看事物,才能使他的思想更成熟,理解更深刻.他把他的朋友保尔高更也接到了一起住,于是两个精神病人开始了无止尽的争论.在绘画的领域,梵高是一座真正的火山,而高更则是满腔热血沸腾,即便是没有分歧的部分,他们的讨论也是惊心动魄的. 黄房子,1888 我画太阳时，要画得让人们感觉到它以可怕的速度在旋转。它发射出力量无穷的光波和热波。我画麦田时，要人们感觉到谷粒中的原子在生长、爆裂。我画苹果时，要人们感觉到苹果中的液汁溅到皮肤上，果核中的种籽在往外钻向开花结果！ 当我画一个在田里干活的农民的时候,我希望人们感觉到,农民就像庄稼那样正向下融会到土壤里面,而土壤也向上融会到农民身上.我希望人们感受到,太阳正注入到农民,土地,庄稼,犁和马的内部,恰如他们反过来又注入到太阳里面一样.当我开始感受到事件万物运动的这一普遍的节奏时,你才开始懂得了生活.只有这,才是主宰一切的上帝. 是的,梵高的上帝已经死了,他成为主宰自己生活的上帝,也是他绘画的源泉. 然而正是这份对艺术的热爱和执着与生活的艰辛形成鲜明的对比,时时刻刻折磨着他的神经,’他是一个因善良受苦的天使,也是一个用色彩享乐的天才’,最后他割下了自己的耳朵…随后,他被送入圣雷米的疗养院,在那个安静的世界里,他的内心更为纯净,他画了星空,绽放了他内心最纯净的颜色. 星空,1889 我想,对生活充满热爱的人们都应该读一下这本书,去感受一下这个崇高的灵魂,感受一下它的孤独,感受一下我们拥有的幸福. 致敬梵高! 麦田里的乌鸦,1890]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>博闻</tag>
        <tag>梵高</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[建国大业]]></title>
    <url>%2F2016%2F08%2F08%2Fblockbuster-Founding-of-the-Republic%2F</url>
    <content type="text"><![CDATA[‘念奴娇·昆仑 横空出世，莽昆仑，阅尽人间春色。 飞起玉龙三百万，搅得周天寒彻。 夏日消溶，江河横溢，人或为鱼鳖。 千秋功罪，谁人曾与评说? 而今我谓昆仑：不要这高，不要这多雪。 安得倚天抽宝剑，把汝裁为三截? 一截遗欧，一截赠美，一截还东国。 太平世界，环球同此凉热。’ 终于读完了这几本书,本意是一周完成的专题阅读,无奈工作过于操心,迟迟未能完成.上面的诗是在长征途中所写，毛泽东登上岷山峰顶，远望青海一带苍茫的昆仑山脉有感而作。整首诗气势磅礴,放眼天下.长征确定了老毛的领袖地位,长征更是宣传书,是宣传队,共产党是播种机. 传记系列的书我本不想涉及,因为传记太虚,虚了那远不如看小说了,而且大部分的自传都是写成他传,他传就是自传,总是会带有一些目的性.尤其是这几人的官方传记,更是具有强烈的政治诉求.所幸挑的这几版书均是国外名人所写,应当还具有一定的客观性吧. 一口气看完这四本书,20世纪的中国从暗潮汹涌,到动荡不安,到建国立业,经历太多.看完后恍如隔世,国外写的传记并未毁三观,大事件还是那几个大事件,想来历史是照妖镜总不至于过于捏造. 几本书都对’大跃进’描述比较少,应该是资料较少的缘故,善长宣传的共产党保密工作确实做的不错.对几个敏感事件也没有太明晰的描述,比如类似89年天安门事件,是谁下令开的枪?并未明说!觉得可能是译者的原因吧,毕竟是要在中国出版的,虽不至于造神但还是有些避讳的,于是翻墙Google了原版,均要收费,无果. 笔记以史为鉴,20世纪的中国动荡不安,经历了辛亥革命-&gt;五四运动-&gt;国民党成立-&gt;共产党成立-&gt;国共第一次合作-&gt;北伐全国一统一-&gt;剿共-&gt;九一八事变-&gt;西安事变-&gt;国共联合抗日-&gt;抗日胜利-&gt;国共内战-&gt;中华人民共和国成立-&gt;百花齐放-&gt;大跃进-&gt;文化大革命-&gt;四人帮事件-&gt;天安门事件-&gt;中国经济起飞. 从几大事件看来,蒋公失天下是必然的,作为一个政治家和政治领袖,蒋介石是一个战术家而不是战略家,虽然他善于玩弄权术并牢牢的控制了中国人口的大多数,但他实际上不了解整个政权的社会基础.蒋介石是个悲剧人物,他的悲剧是他自己造成的,虽然他有勇气,有精力,有领袖品质,但他缺乏战略眼光,在关键的时刻做了不该做的决定,该攘外的时候坚持按内,该剿匪扫荡的时候又做的不够彻底,丢了民心丢了权利. 而老毛不同,毛虽没有喝过洋墨水,但他有非常高的战略眼光,他从农民中来到农民中去,毛泽东给了农民最想要的东西：“土地和同多年来压迫他们的地主们算帐的机会。” 他来自中国’受虐待的一方’,他所知道是贫困,堕落,剥削和非正义,这些东西他花费了一生在做搏斗.他具备强大的政治野心和执行力,他把改造世界的愿望从教室里带到政治竞技场,在解放人民方面他是光辉的,但在管理复杂的政治军事方面他是不成功的.老毛喜欢斗争,所以他的周围都在斗争中度过.老毛缺乏治理能力,思想极度左倾,而新中国在动荡中最终得以站稳,这都是下面两位的功劳. 周恩来原先在日本留学,五四运动的时候回到上海,随后又到法国求学,回来领导了上海的几次大罢工,早早就成为了中共关键领导人.周的视野比较开阔,有非常大的包容性.他对共产主义的信仰是真诚的,正如他对中国的感情和他那持久的任性也是发自内心的一样.然而他却是典型的儒家政治家,做事比较温和,缺乏领导能力,无法掌舵中国这艘大船,所以最后只能做个大副.周在毛统治的阶段小心翼翼的不进行政治站队,在几次大事件相安无事,充当着调和员和补救者的角色.他并未留恋权利,连子嗣都没有留下,一心辅佐毛,治理中国,对他选择的道路,我们内心感到欣慰,对他身后的中国,我们充满了希望. &lt;&lt;邓小平传&gt;&gt; (英)理查德.伊文思伊文思是英国驻中国大使,同时也是一位中国社会问题研究专家,他在20世纪50年代,60年代,80年代先后在中国呆了8年,同时也直接参与了英国问题的谈判,他始终关注着中国,关注着邓小平.他已相对客观公平的眼光展示和解读了邓小平波澜壮阔的一生. &lt;&lt;毛泽东传&gt;&gt; (英)迪克.威尔逊 &lt;&lt;周恩来传&gt;&gt; (英)迪克.威尔逊 &lt;&lt;蒋介石传&gt;&gt; (美)布兰恩.克洛泽]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>博闻</tag>
        <tag>传记</tag>
        <tag>毛泽东</tag>
        <tag>邓小平</tag>
        <tag>周恩来</tag>
        <tag>蒋介石</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[极简欧洲史]]></title>
    <url>%2F2016%2F06%2F30%2FShortest-History-of-Europe%2F</url>
    <content type="text"><![CDATA[欧洲文明是独特的,因为它一直是唯一能让世界其他地区马首是瞻的文明.它之所以可以做到这点,是靠不断的征服和定居,强大的经济势力和思想观念,以及拥有其他人向往的东西. 该书的欧洲史划分包括古典时期、中世纪和近代。古典时期从公元元年到476年日耳曼蛮族入侵，西罗马帝国灭亡；中世纪从476年到1400年。希腊人贡献了哲学,艺术,文学,数学,科学,医学以及政治思想的源头.罗马人则建立强大的帝国,并有着先进的建筑技术与治理国家的法律.整个欧洲的文明建立在希腊文明和罗马文明之上.宗教是一种粘合剂,将不同的文明粘合在一起. 宗教世界 只要相信耶稣，你便能得救，死后免受地狱火烧之苦，还能升入天堂。 希腊人的观点:这是一个简单,符合逻辑,能以数学表达的世界.基督教的观点:这是个邪恶的世界,唯有耶稣能拯救它.日耳曼蛮族的观点:打仗是好玩的事.这些元素组合在一起,造就了欧洲的文明. 几次革命浪潮 文艺复兴着眼的是古希腊和罗马的智识成就,新教改革者则是频频回顾罗马教廷承袭罗马习性之前的基督教会. 数学是科学的中心.顿和爱因斯坦都说: 答案应该简单,符合逻辑,能以数学表达,唯有答案简单,才可能近乎正确. 军政演变 好战者和基督教的结合是个矛盾体,前者崇尚武力,而耶稣说”要爱你的敌人”,于是就有了骑士-保护弱者,战斗被赋予了这种新的道德意涵,一个男人要借由一种犹如宗教的仪式才能成为骑士,骑士绝迹之后,就演变成了”绅士”. 人是善变无常的,优柔寡断的,浅薄无知的,容易被操弄的,而政治是一种精细的艺术,需要智慧和良好的判断 近代农工制圈地运动 田地制度 为什么欧洲跑第一?中国以前很强大,但近代中国对世界几乎没有什么贡献.不管是科学上,军事上,经济上,政治上,哲学上,中国都扮演着拿来主义者,山寨者的角色,走着自己所谓的中国特色.反观欧洲,为什么欧洲可以跑第一? 不是所有东西都归国王所有,这是欧洲自由和繁荣的基石. 权利分散,遗产多元. 信仰. 没有信仰的中国人确实是可怕的,会少一份道德上的约束.]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>博闻</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Angularjs2教程:英雄之途]]></title>
    <url>%2F2016%2F06%2F17%2Fangularjs2-TUTORIAL-TOUR-OF-HEROES%2F</url>
    <content type="text"><![CDATA[转摘请说明出处! 译者自序:仅是自己学习的时候顺便翻译下,仅当做笔记加深印象之用,并未对所翻译内容进行过复查和校对,应该会有大量狗屁不通的地方,建议还是看官方原文吧 Tour of Heroes教程一步一步教大家如何用TypeScript写Angular应用.* 介绍英雄之旅:预览我们更大的计划是创建一个应用,帮助人员管理机构来管理英雄们,即使是英雄他也需要有一份工作. 当然本教程会进一步深入使用Angular来构建应用.在一个成熟的,数据驱动的应用中我们需要购将非常多的功能:获取和展示英雄列表,编辑选中的英雄细节,英雄数据视图导航等. 英雄之旅覆盖了Angular的核心功能,我们使用内置指令显示/隐藏元素并展示英雄数据列表.我们创建一个组件用于展示英雄细节,另外一个组件用于显示所有的英雄列表.我们增加一个可编辑字段通过双向数据绑定的形式更新model.我们将组件的方法绑定到用户事件上,如键盘敲击或者鼠标点击.我们将学习如何从主列表内选择英雄并在细节视图里编辑他.我们通过pipes格式化数据.我们将会创建一个共享服务来收集我们的英雄.我们将使用路由功能来实现不同视图和组件之间的导航. 我们将会接触到足够多的Angular的核心功能,我们会发现Angular很强大几乎可以用来实现任何的应用.在线示例 最终效果这是这个应用的最终效果,从仪表盘可以浏览我们的主要应用:仪表盘上面有两个链接(“Dashboard”和”英雄们”).我们可以通过点击它们导航到这个仪表盘和英雄视图中. 我们点击仪表盘上的名为”Magneta”的英雄,会有这个英雄的细节展示,并且我们可以修改英雄的名字.点击”Back”按键,我们可以返回”Dashboard”.顶部的导航栏可以带我们进入任一一个主要视图.我们点击”Heroes”,应用就会展示英雄们的列表视图.我们点击不同的英雄,会有一个可读的小细节展示到我们的点击处. 下图列出了我们导航栏的选择流程图:以下是APP的动画效果: 下一步我们开始一步步构建英雄之旅这个应用了,我们每一步都是为了解决应用中某个需求为目的的.我们一起来见识下Angular非常多的核心功能. 英雄编辑器从前…每一个故事都得从某一个时间开始,我们的故事从QuickStart教程介绍开始. 运行教程这部分的示例: live example 创建一个名为angular2-tour-of-heroes的文件夹,并跟着快速入门教程进行工程的预配置和安装. 你也可以直接下载快速入门源码 最终结构如下:我们最终的工程文件结构如下：1234567891011121314151617181920212223--angular2-quickstart----app------app.component.ts------main.ts----node_modules ...----typings ...----index.html----package.json----styles.css----systemjs.config.js----tsconfig.json----typings.json 保持app在线编译和运行实时监控文件改变,编译TypeScript并更新app,我们只需: npm start 这个命令运行编译器的观察模式,启动服务,在浏览器里打开应用,并维持app持续构建和运行. 英雄展示我们想在APP里显示英雄.让我们增加两个特性到AppComponent, title表示应用的名字,hero赋值一个英雄,名为Windstorm. 1234export class AppComponent &#123; title = &apos;Tour of Heroes&apos;; hero = &apos;Windstorm&apos;;&#125; 更新@component装饰器里的模板,将数据绑定到新的特性里. 1template: &apos;&lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt;&lt;h2&gt;&#123;&#123;hero&#125;&#125; details!&lt;/h2&gt;&apos; 此时浏览器应该会刷新并显示title和英雄名. 双大括号表示读取和渲染组件内的title和hero特性,这是单向数据绑定的”插值”形式. 关于’插值’更详细的信息请查看 数据展示章节 英雄对象现在,我们的英雄就只有一个名字而已,我们想要更多的特性,我们需要把它转换成类. 创建一个带有id和name特性的Hero类,暂时放到app.component.ts文件里,import语句之下. 1234export class Hero &#123; id: number; name: string;&#125; 现在我们有了Hero类,让我们重构下hero特性: 1234hero: Hero = &#123; id:1, hero:&apos;Windstorm&apos;&#125;; hero特性从字符串变成了类,修改模板里的对应字段: 1template: &apos;&lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt;&lt;h2&gt;&#123;&#123;hero.name&#125;&#125; details&lt;/h2&gt;&apos; 修改HTML模板我们现在需要显示更多的信息,不仅仅是名字,修改下html模板: 123456template:` &lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt; &lt;h2&gt;&#123;&#123;hero.name&#125;&#125; details!&lt;/h2&gt; &lt;div&gt;&lt;label&gt;id: &lt;/label&gt;&#123;&#123;hero.id&#125;&#125;&lt;/div&gt; &lt;div&gt;&lt;label&gt;name: &lt;/label&gt;&#123;&#123;hero.name&#125;&#125;&lt;/div&gt; ` 编辑英雄我们需要在文本框里编辑英雄的名字,重构英雄名字部分的模板,增加一个&lt;input&gt;元素. 123456789template:` &lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt; &lt;h2&gt;&#123;&#123;hero.name&#125;&#125; details!&lt;/h2&gt; &lt;div&gt;&lt;label&gt;id: &lt;/label&gt;&#123;&#123;hero.id&#125;&#125;&lt;/div&gt; &lt;div&gt; &lt;label&gt;name: &lt;/label&gt; &lt;input value=&quot;&#123;&#123;hero.name&#125;&#125;&quot; placeholder=&quot;name&quot;&gt; &lt;/div&gt; ` 现在浏览器上英雄名字确实显示到了&lt;input&gt;文本框里.但似乎有些不对,当我们改变名字的时候,我们发现这些改变并没有反应到&lt;h2&gt;里.这种单向绑定到&lt;input&gt;的形式无法满足需求. 双向绑定我们现在的需求是这样的,&lt;input&gt;框内显示英雄的名字,修改它,绑定了这个英雄名字的其他地方都需要对应改变.简而言之,我们想要双向数据绑定. 让我们使用ngModel这个内置指令来实现双向绑定. 关于ngModel的更多信息可以查看表单和模板语法章节 用以下HTML替换&lt;input&gt;: 1&lt;input [(ngModel)]=&quot;hero.name&quot; placeholder=&quot;name&quot;&gt; 刷新浏览器,我们再次编辑英雄的名字,可以发现&lt;h2&gt;里的内容也可以联动起来了. 本章小结让我们看看本章做了些什么. 英雄之旅使用大括号插入显示应用的title以及hero对象特性. 通过使用内建指令ngModel对&lt;input&gt;元素和组件数据进行双向绑定 ngModel指令将数据变化响应到绑定的hero.name特性上. app.component.ts代码如下: 123456789101112131415161718192021222324import &#123; Component &#125; from &apos;@angular/core&apos;;export class Hero &#123; id: number; name: string;&#125;@Component(&#123; selector: &apos;my-app&apos;, template: ` &lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt; &lt;h2&gt;&#123;&#123;hero.name&#125;&#125; details!&lt;/h2&gt; &lt;div&gt;&lt;label&gt;id: &lt;/label&gt;&#123;&#123;hero.id&#125;&#125;&lt;/div&gt; &lt;div&gt; &lt;label&gt;name: &lt;/label&gt; &lt;input [(ngModel)]=&quot;hero.name&quot; placeholder=&quot;name&quot;&gt; &lt;/div&gt; `&#125;)export class AppComponent &#123; title = &apos;Tour of Heroes&apos;; hero: Hero = &#123; id: 1, name: &apos;Windstorm&apos; &#125;;&#125; 未来之路现在的应用只展示了一个英雄,我们希望展示一个英雄的列表,同时允许用户可以点击选择查看他们的详情.下一章节,我们将会学习到如何获取一个列表,并将他们绑定到模板上,渲染到页面可供用户选择. Master/Detail有很多英雄我们的故事需要更多的英雄.我们可以扩展英雄之旅APP展示英雄列表,允许用户选择英雄并显示英雄的详情. 这部分的在线示例. 让我们来预估下显示一个英雄列表需要做点什么. 首先,我们需要一个英雄的列表数据.然后,我们将它通过视图模板展示出来. 显示英雄们创建英雄数据在app.component.ts底部创建一个包含10个英雄的数组. 123456789101112const HEROES: Hero[] = [ &#123; id: 11, name: &apos;Mr. Nice&apos; &#125;, &#123; id: 12, name: &apos;Narco&apos; &#125;, &#123; id: 13, name: &apos;Bombasto&apos; &#125;, &#123; id: 14, name: &apos;Celeritas&apos; &#125;, &#123; id: 15, name: &apos;Magneta&apos; &#125;, &#123; id: 16, name: &apos;RubberMan&apos; &#125;, &#123; id: 17, name: &apos;Dynama&apos; &#125;, &#123; id: 18, name: &apos;Dr IQ&apos; &#125;, &#123; id: 19, name: &apos;Magma&apos; &#125;, &#123; id: 20, name: &apos;Tornado&apos; &#125;]; 数组HEROES是Hero类型的,类型已在上一章节定义,为了创建这个英雄数组.我们最终希望可以从web service获取这个列表,目前我们先用模拟数据代替. 展示英雄AppComponent里创建一个public的heroes特性并绑定. 1public heroes = HEROES; 我们并不需要声明heroes类型,TS可以隐式赋值为HEROES数组. 在模板里展示英雄我们的组件有heroes,让我们再创建一个无序列表.将以下的HTML代码插入到模板里. 123456&lt;h2&gt;My Heroes&lt;/h2&gt;&lt;ul class=&quot;heroes&quot;&gt; &lt;li&gt; &lt;!-- each hero goes here --&gt; &lt;/li&gt;&lt;/ul&gt; 现在我们已经有模板了,开始填充英雄数据. 使用ngFor展示英雄列表我们想绑定heroes数组绑定到组件的模板里,并迭代渲染展示他们. 首先修改&lt;li&gt;标签,增加内置指令*ngFor. 1&lt;li *ngFor=&quot;let hero of heroes&quot; &gt; 前置符*表示&lt;li&gt;元素节点以及它的子孙节点组成一个主模板.ngFor指令迭代AppComponent.heroes数组,并放入hero变量中. 现在我们可以在&lt;li&gt;标签里插入一些内容了: 123&lt;li *ngFor=&quot;let hero of heroes&quot;&gt; &lt;span class=&quot;badge&quot;&gt;&#123;&#123;hero.id&#125;&#125;&lt;/span&gt; &#123;&#123;hero.name&#125;&#125;&lt;/li&gt; 样式化我们的英雄列表看起来比较乏味,我们需要一些视觉效果,如在某个英雄上鼠标悬停或者英雄选择. 通过在@component里设置styles特性.将样式加入到组件. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849styles: [` .selected &#123; background-color: #CFD8DC !important; color: white; &#125; .heroes &#123; margin: 0 0 2em 0; list-style-type: none; padding: 0; width: 15em; &#125; .heroes li &#123; cursor: pointer; position: relative; left: 0; background-color: #EEE; margin: .5em; padding: .3em 0; height: 1.6em; border-radius: 4px; &#125; .heroes li.selected:hover &#123; background-color: #BBD8DC !important; color: white; &#125; .heroes li:hover &#123; color: #607D8B; background-color: #DDD; left: .1em; &#125; .heroes .text &#123; position: relative; top: -3px; &#125; .heroes .badge &#123; display: inline-block; font-size: small; color: white; padding: 0.8em 0.7em 0 0.7em; background-color: #607D8B; line-height: 1em; position: relative; left: -1px; top: -4px; height: 1.8em; margin-right: .8em; border-radius: 4px 0 0 4px; &#125;`] 请注意,组件样式只有该组件有效,不会影响到其他的HTML.现在用于展示英雄列表的模板如下: 123456&lt;h2&gt;My Heroes&lt;/h2&gt;&lt;ul class=&quot;heroes&quot;&gt; &lt;li *ngFor=&quot;let hero of heroes&quot;&gt; &lt;span class=&quot;badge&quot;&gt;&#123;&#123;hero.id&#125;&#125;&lt;/span&gt; &#123;&#123;hero.name&#125;&#125; &lt;/li&gt;&lt;/ul&gt; 选择英雄我们有一个英雄列表,我们也有了单个英雄的显示界面,但目前两者还没有关联起来.我们接下来想要做的是,在英雄列表里点击英雄,可以查看这个英雄的详情.这种UI模式就是广泛使用的master-detail.在这个示例中,master是英雄列表,detail是选择的英雄.让我们通过一个绑定点击事件的selectedHero组件来连接master和detail. 点击事件修改模板&lt;li&gt;标签,插入Angular事件绑定到鼠标点击事件. 123&lt;li *ngFor=&quot;let hero of heroes&quot; (click)=&quot;onSelect(hero)&quot;&gt; &lt;span class=&quot;badge&quot;&gt;&#123;&#123;hero.id&#125;&#125;&lt;/span&gt; &#123;&#123;hero.name&#125;&#125;&lt;/li&gt; 来看看事件绑定: 1(click)=&quot;onSelect(hero)&quot; 这个插入语指示了&lt;li&gt;元素是click事件的目标,在等于符号右边的表达式调用了AppComponent方法,onSelect(),将模板内的变量hero作为参数传入,这个参数就是ngFor遍历的变量hero. 更多关于事件绑定可以查看用户输入和模板语法章节. 增加点击句柄我们的事件绑定的onSelect方法还没有实现,下面就来实现这个方法. 首先我们思考下,这个方法应该做些什么?它应该将组件内的选择英雄属性设置为用户点击的英雄. 声明选择的英雄我们现在不需AppComponent组件内静态的hero特性了,用selectedHero特性替换它: 1selectedHero: Hero; selectedHero不进行初始化,如果用户不点击,这个值就为空.现在增加一个onSelect方法,将点击的hero特性设置为selectedHero. 1onSelect(hero: Hero) &#123; this.selectedHero = hero; &#125; 将模板展示数据绑定selectedHero特性上. 123456&lt;h2&gt;&#123;&#123;selectedHero.name&#125;&#125; details!&lt;/h2&gt;&lt;div&gt;&lt;label&gt;id: &lt;/label&gt;&#123;&#123;selectedHero.id&#125;&#125;&lt;/div&gt;&lt;div&gt; &lt;label&gt;name: &lt;/label&gt; &lt;input [(ngModel)]=&quot;selectedHero.name&quot; placeholder=&quot;name&quot;/&gt;&lt;/div&gt; 使用ngIf过滤空异常当我们的app加载起来,我们看到英雄的列表,但此时没有英雄被选择,selectedHero是undefined.浏览器的控制窗口会有如下的打印: 1EXCEPTION: TypeError: Cannot read property &apos;name&apos; of undefined in [null] 我们之后会将英雄的详情作为组件移除,就不存在这个问题了,但在那之前要处理掉这个问题,就需要判断selectedHero是否为undefined,我们可以使用内置ngIf指令: 12345678&lt;div *ngIf=&quot;selectedHero&quot;&gt; &lt;h2&gt;&#123;&#123;selectedHero.name&#125;&#125; details!&lt;/h2&gt; &lt;div&gt;&lt;label&gt;id: &lt;/label&gt;&#123;&#123;selectedHero.id&#125;&#125;&lt;/div&gt; &lt;div&gt; &lt;label&gt;name: &lt;/label&gt; &lt;input [(ngModel)]=&quot;selectedHero.name&quot; placeholder=&quot;name&quot;/&gt; &lt;/div&gt;&lt;/div&gt; ngIf和ngFor都叫做结构指令,因为他能够改变DOM的部分结构,更对内容请查看结构指令和模板语法章节. 刷新浏览器,我们可以看到英雄列表,但我们并没有选择英雄的详情页.当selectedHero为undefined的时候,ngIf从DOM过滤掉了这部分节点.当我们点击一个列表里的英雄,详情页面会出现,这就是我们想要的效果. 美化slection被选择的英雄没有很直观的标示在英雄列表里,我们可以使用selected CSS类来改变主元素的样式. 1[class.selected]=&quot;hero === selectedHero&quot; 中括号里的class.selected,这是一种特性绑定的方法,即从某个数据源(表达式 hero === selectedHero)单向流入到特性中. 12345&lt;li *ngFor=&quot;let hero of heroes&quot; [class.selected]=&quot;hero === selectedHero&quot; (click)=&quot;onSelect(hero)&quot;&gt; &lt;span class=&quot;badge&quot;&gt;&#123;&#123;hero.id&#125;&#125;&lt;/span&gt; &#123;&#123;hero.name&#125;&#125;&lt;/li&gt; 可以在模板语法章节查看更多关于特性绑定的内容. 重新加载app到浏览器,我们选择英雄Magneta,就有高亮标示了. 完整的app.component.ts代码如下: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394import &#123; Component &#125; from &apos;@angular/core&apos;;export class Hero &#123; id: number; name: string;&#125;const HEROES: Hero[] = [ &#123; id: 11, name: &apos;Mr. Nice&apos; &#125;, &#123; id: 12, name: &apos;Narco&apos; &#125;, &#123; id: 13, name: &apos;Bombasto&apos; &#125;, &#123; id: 14, name: &apos;Celeritas&apos; &#125;, &#123; id: 15, name: &apos;Magneta&apos; &#125;, &#123; id: 16, name: &apos;RubberMan&apos; &#125;, &#123; id: 17, name: &apos;Dynama&apos; &#125;, &#123; id: 18, name: &apos;Dr IQ&apos; &#125;, &#123; id: 19, name: &apos;Magma&apos; &#125;, &#123; id: 20, name: &apos;Tornado&apos; &#125;];@Component(&#123; selector: &apos;my-app&apos;, template: ` &lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt; &lt;h2&gt;My Heroes&lt;/h2&gt; &lt;ul class=&quot;heroes&quot;&gt; &lt;li *ngFor=&quot;let hero of heroes&quot; [class.selected]=&quot;hero === selectedHero&quot; (click)=&quot;onSelect(hero)&quot;&gt; &lt;span class=&quot;badge&quot;&gt;&#123;&#123;hero.id&#125;&#125;&lt;/span&gt; &#123;&#123;hero.name&#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;div *ngIf=&quot;selectedHero&quot;&gt; &lt;h2&gt;&#123;&#123;selectedHero.name&#125;&#125; details!&lt;/h2&gt; &lt;div&gt;&lt;label&gt;id: &lt;/label&gt;&#123;&#123;selectedHero.id&#125;&#125;&lt;/div&gt; &lt;div&gt; &lt;label&gt;name: &lt;/label&gt; &lt;input [(ngModel)]=&quot;selectedHero.name&quot; placeholder=&quot;name&quot;/&gt; &lt;/div&gt; &lt;/div&gt; `, styles: [` .selected &#123; background-color: #CFD8DC !important; color: white; &#125; .heroes &#123; margin: 0 0 2em 0; list-style-type: none; padding: 0; width: 15em; &#125; .heroes li &#123; cursor: pointer; position: relative; left: 0; background-color: #EEE; margin: .5em; padding: .3em 0; height: 1.6em; border-radius: 4px; &#125; .heroes li.selected:hover &#123; background-color: #BBD8DC !important; color: white; &#125; .heroes li:hover &#123; color: #607D8B; background-color: #DDD; left: .1em; &#125; .heroes .text &#123; position: relative; top: -3px; &#125; .heroes .badge &#123; display: inline-block; font-size: small; color: white; padding: 0.8em 0.7em 0 0.7em; background-color: #607D8B; line-height: 1em; position: relative; left: -1px; top: -4px; height: 1.8em; margin-right: .8em; border-radius: 4px 0 0 4px; &#125; `]&#125;)export class AppComponent &#123; title = &apos;Tour of Heroes&apos;; heroes = HEROES; selectedHero: Hero; onSelect(hero: Hero) &#123; this.selectedHero = hero; &#125;&#125; 小结本章小结: 我们现在可以选择列表里的英雄了 应用由了选择并展示英雄详情的功能 我们学习了怎么在组件模板里使用内置指令ngIf和ngFor 现在英雄之旅初具雏形,但还远远没有完成,我们不能使用单个组件来实现整个app,需要将组件分成若干个子组件,并将他们有效的组合起来. 多组件 重构master/detail视图到分离的组件 构建一个英雄详情组件我们的英雄列表和我们的英雄详情目前处于一个文件里.他们现在虽然很小但是不利于扩展.我们目前的组件设计遵守单一组件原则,虽然这只是个教程,但精益求精依然是要追求的,尤其是使用Angular是非常容易做到这一点的. 让我们将英雄详情移出目前组件 分离英雄详情组件app文件夹里增加一个新的文件hero-detail.component.ts,并创建如下的HeroDetailComponent: app/hero-detail.component.ts (initial version) 12345678import &#123; component. Input &#125; from &apos;@angular/core&apos;;@component(&#123; selector: &apos;my-hero-detail&apos;,&#125;)export class HeroDetailComponent&#123;&#125; 命名规则我们希望通过文件名可以知道对应的组件名.所有组件的文件后缀名已.component结尾.如HeroDetailComponent对应的文件名为hero-detail.component.ts. 英雄详情模板现在,Heroes和Hero详情视图还在AppComponent的模板里.让我们英雄详情相关的内容黏贴到HeroDetailComponent里. 我们之前绑定了AppComponent的selectedHero.name特性.在新的模板中将selectedHero替换为hero. app/hero-detail.component.ts (template) 12345678910template: ` &lt;div *ngIf=&quot;hero&quot;&gt; &lt;h2&gt;&#123;&#123;hero.name&#125;&#125; details!&lt;/h2&gt; &lt;div&gt;&lt;label&gt;id: &lt;/label&gt;&#123;&#123;hero.id&#125;&#125;&lt;/div&gt; &lt;div&gt; &lt;label&gt;name: &lt;/label&gt; &lt;input [(ngModel)]=&quot;hero.name&quot; placeholder=&quot;name&quot;/&gt; &lt;/div&gt; &lt;/div&gt;` 现在英雄详情展示只会在HeroDetailComponent里. 增加hero特性将Hero类从app.component.ts移出,创建并放入一个hero.ts文件里. app/hero.ts 1234export class Hero &#123; id: number; name: string;&#125; 我们将Hero类从hero.ts暴露出来,因为我们需要在多个地方引用它.在app.component.ts和hero-detail.component.ts增加以下的语句引用Hero: 1import &#123; Hero &#125; from &apos;./hero&apos;; hero特性是输入HeroDetailComponent需要被告之哪个英雄需要显示,谁可以干这个事?它的父组件AppComponent! AppComponent知道哪个英雄需要显示:就是用户从列表里选择的那个.用户选择被放入selectedHero特性. 我们更新模板,将HeroDetailComponent的hero特性和AppComponent的selectedHero绑定. 1&lt;my-hero-detail [hero]=&quot;selectedHero&quot;&gt;&lt;/my-hero-detail&gt; 注意到hero特性是特性绑定的目标-它在方括号里并处于(=)号的左边. Angular主张将目标特性作为一个可输入的特性,如果不这样做,Angular就会拒绝绑定并抛出异常. input特性的详情请看这里. 有若干方法可以声明hero是一个输入特性.我们可以按选择,比如在hero特性里加一个@Input注释. 12@Input()hero: Hero; 更多关于@Input装饰器内容查看属性指令章节. 更新AppComponentAppComponent里导入HeroDetailComponent. 1import &#123; HeroDetailComponent &#125; from &apos;./hero-detail.component&apos;; 在模板中找到移除Hero Detail内容的地方,增加一个表示HeroDetailComponent的元素标签,并将AppComponent的selectedHero特性和HeroDetailComponent的hero特性进行双向绑定. 1&lt;my-hero-detail [hero]=&quot;selcetedHero&quot;&gt;&lt;/my-hero-detail&gt; 此时AppComponent模板如下: 123456789101112template: ` &lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt; &lt;h2&gt;My Heroes&lt;/h2&gt; &lt;ul class=&quot;heroes&quot;&gt; &lt;li *ngFor=&quot;let hero of heroes&quot; [class.selected]=&quot;hero === selectedHero&quot; (click)=&quot;onSelect(hero)&quot;&gt; &lt;span class=&quot;badge&quot;&gt;&#123;&#123;hero.id&#125;&#125;&lt;/span&gt; &#123;&#123;hero.name&#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;my-hero-detail [hero]=&quot;selectedHero&quot;&gt;&lt;/my-hero-detail&gt;`, HeroDetailComponent 可以接收AppComponent的选择事件,并在list底部将这个英雄的详情展示出来,这个详情会随着用户的选择而改变.但是!现在什么也没有发生!我们在英雄之间来回点击,但没有详情显示,我们也没有调试到任何的错误信息. 这有点像是Angular忽略了这个新的标签,事实上确实如此. 指令数组浏览器会忽略它不识别的HTML标签和属性,Angular也是如此.我们导入HeroDetailComponent,在模板里使用它,但并没有告诉Angular它是什么.如何告诉Angular?将组件列入元数据directives数组: 1directives: [HeroDetailComponent] 现在功能实现了,我们也创建了第一个可复用的组件! 小结本章小结 我们创建了一个可复用的组件 我们学习了如何让组件接收输入信息 我们学习了绑定父组件和子组件 我们学习了如何声明应用指令 未来之路我们的英雄之旅将会有可多可复用的组件.我们现在模拟数据依然处于AppComponent中,这并不合理.我们需要重构数据接入组件,将它放到分离的服务里,可被其他组件共享. 下一章,我们将学习如何创建Services. Services 我们创建一个可复用的service来管理英雄数据的调用 英雄之旅在逐步进化,可以预料以后将会增加更多的组件.多个组件需要获取英雄数据信息,我们并不想通过重复拷贝相同的代码来实现它.所以,我们将要创建一个可复用的数据服务,并学习怎么将它注入到组件里. 重构数据获取方式将它放入到分离的服务里,可以保持组件只关注它的视图,也可以使用模拟服务使得组件的单元测试更加方便. 因为数据services始终是异步的,本章最后我们将用基于Promise机制来实现数据服务. 创建一个英雄Service我们的合伙人说我们的这个APP有巨大的潜力,他们告诉我们他们想通过各种方法在不同的页面像是英雄信息.我们已经可以从列表里选择英雄,我们马上就需要增加一个仪表板来展示顶尖的英雄们,创建一个单独的视图来渲染英雄详情编辑界面,这三个视图都需要英雄数据. AppComponent里定义了要展示的英雄模拟数据.我们需要至少2个对象.首先,如何定义英雄并不是组件完成的.其次,我们并不能简单的再其他组件和视图之间分享英雄列表. 创建一个HeroServiceapp文件夹里创建一个名为hero.service.ts. app/hero.service.ts 12345import &#123; Injectable &#125; from &apos;@angular/core&apos;;@Injectable()export class HeroService &#123;&#125; 我们将Angualr的Injectable功能导入了,使用@Injectable()注释注入Services. 千万不要忘了()!否则很难诊断问题. 获取Heros增加一个getHeroes方法(打桩): 12345@Injectable()export class HeroService &#123; getHeroes() &#123; &#125;&#125; 这里有个重要的问题我们稍后再说.现在服务的消费者并不知道服务是如何获取到数据的.我们的HeroService可以从任何地方获取Hero数据.它可以从一个web服务里获取,可以从本地存储获取,甚至可以从一个模拟数据源里获取. 这就是将数据获取从组件移除最美妙的地方,我们可以根据具体实现来变更数据实现方式. 模拟英雄数据我们已经在AppComponent里模拟了Hero数据.它并不属于那,也不属于service这.我们将模拟数据一到它自己的文件里. 创建一个mock-heroes.ts文件,将模拟数据放到这里: 1234567891011121314import &#123;hero&#125; from &apos;./hero&apos;;export var HEROES: hero[] = [ &#123;id: 11, name: &apos;Mr. Nice&apos;&#125;, &#123;id: 12, name: &apos;Narco&apos;&#125;, &#123;id: 13, name: &apos;Bombasto&apos;&#125;, &#123;id: 14, name: &apos;Celeritas&apos;&#125;, &#123;id: 15, name: &apos;Magneta&apos;&#125;, &#123;id: 16, name: &apos;RubberMan&apos;&#125;, &#123;id: 17, name: &apos;Dynama&apos;&#125;, &#123;id: 18, name: &apos;Dr IQ&apos;&#125;, &#123;id: 19, name: &apos;Magma&apos;&#125;, &#123;id: 20, name: &apos;Tornado&apos;&#125; ]; 我们导出HEROES常量,这样就可以在其他地方使用它了,比如HeroService. 同时,回到app.component.ts,将heroes特性回复到未初始化状态. 1heroes: Hero[]; 返回模拟英雄数据回到HeroService我们导入模拟数据HEROES并返回给getHeroes方法.我们的HeroService现在看起来是这样的: 12345678910import &#123; Injectable &#125; from &apos;@angular/core&apos;;import &#123; HEROES &#125; from &apos;./mock-heroes&apos;;@Injectable()export class HeroService &#123; getHeroes() &#123; return HEROES; &#125;&#125; 使用英雄Service我们已经准备好在其他组件里使用HeroSevice了,从AppComponent开始. 首先,我们先导入它 import { HeroService } from &#39;./hero.service&#39;;. 导入Service后,允许我们引用它的代码.AppComponent是怎样获取HeroService实例的? new一个实例吗?不行! 我们可以new一个新的HeroService实例,如: 1heroService = new HeroService(); // don&apos;t do this 但这么做有几点不好的地方: 我们的组件需要知道如何构建HeroService示例.如果我们改变了HeroService的构造函数,我们就需要找到所有使用了这个service的地方,并修改它.不利于维护和扩展. 我们每次都new一个service,当需要缓存和共享数据这些数据的时候,我们就无法满足了. 我们现在将HeroService锁定到了AppComponent,如果执行场景有变化的时候我们该怎么办呢?我们可以离线操作吗?需要对不同的模拟版本进行单元测试?这很难办到. 要解决这些问题真的非常容易.那就是注入HeroService: 我们增加一个构造器并定义一个私有特性 我们增加一个组件的provider元数据. 构造器如下: app/app.component.ts1constructor(private heroService: HeroService) &#123; &#125; 构造器并没有干什么,参数同时定义了一个私有的heroService属性并指定它未HeroService的注入站点. 现在当构建一个新的AppComponent的时候,Angular就可以支持HeroService的实例构建了. 更多信息,请查看依赖注入章节. 注入器并不知道怎么创建HeroService.如果我们执行代码.此时Angualr会报错: 1EXCEPTION: No provider for HeroService! (AppComponent -&gt; HeroService) 我们需要通过注册一个HeroService的容器来告诉注入器如何构建HeroService.如下,在@Component里增加一个providers数组属性. 1providers: [HeroService] providers数组告诉Angular,当构建一个新的AppComponent的时候就会创建一个新的HeroService实例.AppComponent以及它的子组件都可以使用这个service去获取英雄数据. 123getHeroes() &#123; this.heroes = this.heroService.getHeroes(); &#125; ngOnInit生命周期HookAppComponent应该立即获取和展示英雄们,我们在哪里调用getHeroes方法?在构造器里?我们不这样做! 数年挖坑填坑之痛告诉我们,要保持构造器的逻辑尽量简单,尤其当我们还需要调用server的data数据的时候. 构造器用于一些简单的初始化工作,比如讲参数写入属性里,并不适合做太重的活,所以需要在其他地方调用getHeroes. Angular将会在ngOnInit生命周期Hook里调用这个getHeroes. Angular 提供了数个接口可以进入组件生命周期的关键节点:创建,改变后,消除. 每一个接口对用一个单独的方法,当组件应用了这个方法,Angular会在合适的时间调用他. 关于生命周期详细内容请查看生命周期Hook章节 以下是OnInit接口的基本应用框架: 123456import &#123; OnInit &#125; from &apos;@angular/core&apos;;export class AppComponent implements OnInit &#123; ngOnInit() &#123; &#125;&#125; 我们在ngOnInit里写入符合该逻辑的方法,Angualr会在合适的地方调用它. 123ngOnInit() &#123; this.getHeroes();&#125; 我们的应用如我们期望运行,显示了一组英雄列表,当我们选择点击的时候,可以查看该英雄的详情. 异步服务和Promises我们的HeroService会立即返回一组模拟的英雄,getHeroes是同步的. 1this.heroes = this.heroService.getHeroes(); 当某天我们想从远程服务器获取heroes的时候,虽然我们现在还不能通过http调用,但后面的章节我们马上就要这样了.我们将不得不等待服务器的响应信息,我们不能让UI跟着等待,因为浏览器是不会堵塞的. 我们就需要一些一步技术来调用getHeroes方法.我们使用Promises. Promise就是说它保证会结果准备好的时候回调我们.我们给服务器发了一个异步请求并将回调函数告诉它.当请求有结果的时候,服务器会回调告诉我们结果. 更新HeroService: 123getHeroes() &#123; return Promise.resolve(HEROES);&#125; 使用Promise回到AppComponent的getHeroes方法,目前代码如下: 123getHeroes() &#123; this.heroes = this.heroService.getHeroes();&#125; 我们需要修改代码来解析Promise: 123getHeroes() &#123; this.heroService.getHeroes().then(heroes =&gt; this.heroes = heroes);&#125; 查看APP结构12345678910111213141516171819202122232425262728293031--angular2-tour-of-heroes----app------app.component.ts------hero.ts------hero-detail.component.ts------hero.service.ts------main.ts------mock-heroes.ts----node_modules ...----typings ...----index.html----package.json----styles.css----systemjs.config.js----tsconfig.json----typings.json 小结本章小结 我们创建了一个可分享的服务类 我们使用ngOnInit生命周期的挂钩来获取英雄数据列表 我们在AppComponent里将HeroService定义为一个provider 我们创建模拟英雄数据并将它导入服务. 我们将服务设计为异步Promise,让组件从Promise里解析获取数据. 下一章我们的英雄之旅代码现在有了可复用的服务,我们现在想创建一个导航栏,可以在仪表盘和英雄详情编辑页里来回切换. 路由英雄之旅的新需求: 增加一个Dashboard视图 可以在Heroes和Dashboard视图来回切换 点击选择英雄可以跳转到英雄详情 计划 将AppComponent变为处理导航的外壳. 将Heroes相关内容从AppComponent重定向HeroesComponent. 增加路由 创建一个DashboardComponent 将Dashboard绑定到导航结构. 重组AppComponent我们当前应用加载AppComponent并立即展示英雄列表.现在我们先进入导航界面. AppComponent应该只处理导航,将英雄显示相关部分移到它自己的组件HeroesComponent. HerosComponent目前的AppComponent主要专注于英雄展示,将其改名未HerosComponent,改名步骤如下: app.component.ts改为heroes.component.ts AppComponent类改名为HeroesComponent 选择器my-app改为my-heroes 12345@Component(&#123; selector: &apos;my-heroes&apos;,&#125;)export class HeroesComponent implements OnInit &#123;&#125; 创建AppComponent 创建一个新文件名app.component.ts 定义一个AppComponent类 导出模块以便可在main.ts引用 定义title属性 增加一个有my-app选择器的@Component元数据装饰器 增加一个有&lt;h1&gt;标签的模板并绑定到title属性 模板里增加&lt;my-heroes&gt;标签用于显示英雄 将HeroesComponent放入directives数组,这样Angluar就可以识别&lt;my-heroes&gt;标签了. 增加HeroService到providers数组,因为我们在其他视图中也需要它. 增加支持import语句. 1234567891011121314151617import &#123; Component &#125; from &apos;@angular/core&apos;;import &#123; HeroService &#125; from &apos;./hero.service&apos;;import &#123; HeroesComponent &#125; from &apos;./heroes.component&apos;;@Component(&#123; selector: &apos;my-app&apos;, template: ` &lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt; &lt;my-heroes&gt;&lt;/my-heroes&gt; `, directives: [HeroesComponent], providers: [ HeroService ]&#125;)export class AppComponent &#123; title = &apos;Tour of Heroes&apos;;&#125; 这个app依然可以显示英雄,我们的重构工作就完成了. 增加路由我们准备进行下一步.和自动展示英雄相比,我们更喜欢点击展示的方式,换句话说,我们想当行到英雄列表.这个时候我们就需要Angular的组件路由功能. 设置基础标签打开index.html在顶部的&lt;head&gt;部分增加&lt;base href=&quot;/&quot;&gt;. 12&lt;head&gt; &lt;base href=&quot;/&quot;&gt; 使路由可见组件路由器是一个服务,和其他服务一样,我们需要先导入它,并将它让入providers数组. Angular路由是有由多服务(ROUTER_PROVIDERS),多指令(ROUTER_DIRECTIVES)和一个配置装饰器(RouteConfig)组成,将他们全部导入: app/app.component.ts1import &#123; RouteConfig, ROUTER_DIRECTIVES, ROUTER_PROVIDERS &#125; from &apos;@angular/router-deprecated&apos;; 然后,我们升级directives和providers元数组,让组件包含这些路由成分: 12345directives: [ROUTER_DIRECTIVES],providers: [ ROUTER_PROVIDERS, HeroService] 注意到我们将HeroesComponent从directives数组移除了.AppComponent不再显示英雄;这是路由器的工作,我们很快也会把&lt;my-heroes&gt;从模板移除. 增加配置路由器现在AppComponent还没有包括路由器,我们现在使用@RouteConfig装饰器(a)给组件分配一个路由器(b)使用routes配置路由器. 当用户点击某个连接或者在浏览器输入URL的时候,routes告诉路由器哪个视图是应该对应显示的. app/app.component.ts (RouteConfig): 1234567@RouteConfig([ &#123; path: &apos;/heroes&apos;, name: &apos;Heroes&apos;, component: HeroesComponent &#125;]) @RouteConfig 数组定义了路由,之后会有更多的路由. 这个路由定义只要有三个部分: path: 路由器对浏览器里URL的路径进行匹配(/heroes). name: 路由的正式命名;为了和路径区分,命名必须首字母大写. component: 路由对应的组件名字 深入请翻阅Routing章节 路由器出口如果我们在浏览器输入/heroes对应地址,路由器会匹配Heroes路由并渲染HeroesComponent组件.但在哪里显示?&lt;router-outlet&gt;!我们在应用里导航,路由器会将对应组件显示到&lt;router-outlet&gt;之下. 路由器链接我们并不期望用户直接粘贴URL到浏览器地址栏,我们在模板里增加一个锚标签供用户点击. 12345template: ` &lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt; &lt;a [routerLink]=&quot;[&apos;Heroes&apos;]&quot;&gt;Heroes&lt;/a&gt; &lt;router-outlet&gt;&lt;/router-outlet&gt;`, 注意到[routerLink]绑定到一个锚标签上.我们将RouterLink指令绑定一个路由,当用户点击链接的时候就知道导航的位置. 我们使用链接参数数组定义了路由指示,这个数组在当前示例中,显示一个元素,括号内是路由到组件HeroesComponent的名字Heroes. 更多关于链接数组相关内容请查看路由章节. 刷新浏览器,我们只看到app的title,并没有看到heroes列表,当我们点击Heroes导航链接就发现了英雄列表. app/app.component.ts (v2) 123456789101112131415161718192021222324252627import &#123; Component &#125; from &apos;@angular/core&apos;;import &#123; RouteConfig, ROUTER_DIRECTIVES, ROUTER_PROVIDERS &#125; from &apos;@angular/router-deprecated&apos;;import &#123; HeroService &#125; from &apos;./hero.service&apos;;import &#123; HeroesComponent &#125; from &apos;./heroes.component&apos;;@Component(&#123; selector: &apos;my-app&apos;, template: ` &lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt; &lt;a [routerLink]=&quot;[&apos;Heroes&apos;]&quot;&gt;Heroes&lt;/a&gt; &lt;router-outlet&gt;&lt;/router-outlet&gt; `, directives: [ROUTER_DIRECTIVES], providers: [ ROUTER_PROVIDERS, HeroService ]&#125;)@RouteConfig([ &#123; path: &apos;/heroes&apos;, name: &apos;Heroes&apos;, component: HeroesComponent &#125;])export class AppComponent &#123; title = &apos;Tour of Heroes&apos;;&#125; AppComponent现在关联到了路由器并显示路由的视图.基于这些功能有别于其他组件,我们称这类组件为路由器组件. 增加一个仪表盘当我们有多个视图的时候,路由才有意义.我们需要另外一个视图. app/dashboard.component.ts (v1) 1234567import &#123; Component &#125; from &apos;@angular/core&apos;;@Component(&#123; selector: &apos;my-dashboard&apos;, template: &apos;&lt;h3&gt;My Dashboard&lt;/h3&gt;&apos;&#125;)export class DashboardComponent &#123; &#125; 配置dashboard路由回到app.component.ts配置导航到dashboard的路由. 导入DashboardComponent,在@RouteConfig里定义Dashboard路由. app/app.component.ts 123456&#123; path: &apos;/dashboard&apos;, name: &apos;Dashboard&apos;, component: DashboardComponent, useAsDefault: true&#125;, 最后,增加一个导航链接到模板里: 12345678template: ` &lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt; &lt;nav&gt; &lt;a [routerLink]=&quot;[&apos;Dashboard&apos;]&quot;&gt;Dashboard&lt;/a&gt; &lt;a [routerLink]=&quot;[&apos;Heroes&apos;]&quot;&gt;Heroes&lt;/a&gt; &lt;/nav&gt; &lt;router-outlet&gt;&lt;/router-outlet&gt;`, 刷新浏览器,我们可以在dashboard和heroes之间来回切换了. Dashboard顶级英雄让我们用4个顶级英雄来填充dashboard.将template元数据用templateUrl替换: 123app/dashboard.component.ts (templateUrl)templateUrl: &apos;app/dashboard.component.html&apos;, 我们使用了全路径,这是因为Angular默认不支持相对路径,具体可以查看组件相对路径. 创建文件app/dashboard.component.html,内容如下: 12345678&lt;h3&gt;Top Heroes&lt;/h3&gt;&lt;div class=&quot;grid grid-pad&quot;&gt; &lt;div *ngFor=&quot;let hero of heroes&quot; (click)=&quot;gotoDetail(hero)&quot; class=&quot;col-1-4&quot;&gt; &lt;div class=&quot;module hero&quot;&gt; &lt;h4&gt;&#123;&#123;hero.name&#125;&#125;&lt;/h4&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 我们使用*ngFor来遍历英雄列表并展示英雄名字,我们增加一个额外的&lt;div&gt;元素用于后面进行样式化. 在这里有个(click)绑定到gotoDetail方法上,这个方法我们现在还没有. 共享HeroService我们复用HeroService来获取组件的英雄数组.回顾之前的章节,我们HeroService从HeroesComponent的providers数组移到了最高级的AppComponent组件上.这样就使得HeroService成为一个单例,对所有的应用组件生效.Angular将会注入HeroService,我们就可以在DashboardComponent里使用它. 获取heroes打开dashboard.component.ts,代码如下: 1234567891011121314import &#123; Component, OnInit &#125; from &apos;@angular/core&apos;;import &#123; Hero &#125; from &apos;./hero&apos;;import &#123; HeroService &#125; from &apos;./hero.service&apos;;export class DashboardComponent implements OnInit &#123; heroes: Hero[] = []; constructor(private heroService: HeroService) &#123; &#125; ngOnInit() &#123; this.heroService.getHeroes() .then(heroes =&gt; this.heroes = heroes.slice(1, 5)); &#125; gotoDetail() &#123; /* not implemented yet */&#125;&#125; 和创建HerosComponent类似,在这里我们创建一个heroes数组属性,注入HeroService并将他保存在私有字段heroService里,然后在Angular的ngOnInit生命周期里调用这个服务. 不同的是:我们使用slice挑选了4个英雄(2-5),并将gotoDetail方法打桩,刷新浏览器,我们现在可以看到4个英雄. 导航到英雄详情虽然我们在HeroesComponent底部现实了选择英雄的详情,蛋我们还不能满足以下几种导航需求: 1. 在Dashboard选择英雄 2. 在英雄列表选择英雄 3. 浏览器里输入完成的URl来显示英雄 增加一个HeroDetail路由显然是个好的选择. 路由到英雄详情我们在AppComponent增加一个到HeroDetailComponent的路由.这个路由不同的地方是需要给它指定具体的英雄,这和HeroesComponent,DashboardComponent不同,后者不需要传给他们任何参数. 现在,父组件HeroesComponent将hero属性绑定到一个英雄对象: &lt;my-hero-detail [hero]=&quot;selectedHero&quot;&gt;&lt;/my-hero-detail&gt; 当前的代码还无法正常运行,我们还需要做如下的工作. 路由参数我们可以在URL里增加一个英雄的id,比如路由到一个id是11的英雄,其URL为如下所示: /detail/11 URL的/detail/部分是常量,尾部的数字id根据英雄不同而变化,我们需要配置路由并使用一个变量来便表示它.配置路由参数 12345&#123; path: &apos;/detail/:id&apos;, name: &apos;HeroDetail&apos;, component: HeroDetailComponent&#125;, 路径中的冒号(:)是占位文字,当导航到HeroDetailComponent时用于填充对应的英雄id.现在HeroDetaiComponent代码如下: 1234567891011121314151617181920import &#123; Component, Input &#125; from &apos;@angular/core&apos;;import &#123; Hero &#125; from &apos;./hero&apos;;@Component(&#123; selector: &apos;my-hero-detail&apos;, template: ` &lt;div *ngIf=&quot;hero&quot;&gt; &lt;h2&gt;&#123;&#123;hero.name&#125;&#125; details!&lt;/h2&gt; &lt;div&gt; &lt;label&gt;id: &lt;/label&gt;&#123;&#123;hero.id&#125;&#125; &lt;/div&gt; &lt;div&gt; &lt;label&gt;name: &lt;/label&gt; &lt;input [(ngModel)]=&quot;hero.name&quot; placeholder=&quot;name&quot;/&gt; &lt;/div&gt; &lt;/div&gt; `&#125;)export class HeroDetailComponent &#123; @Input() hero: Hero;&#125; 模板不需要改变,我们以同样的方式显示英雄,但获取英雄的方式变化了.我们现在不从父组件的属性绑定中获取英雄.HeroDetailComponent现在需要从路由器的RouteParams service获得id,并使用这个id从HeroService里获取hero数据. 123import &#123; RouteParams &#125; from &apos;@angular/router-deprecated&apos;;import &#123; HeroService &#125; from &apos;./hero.service&apos;;import &#123; Component, OnInit &#125; from &apos;@angular/core&apos;; 注入RouteParams和HeroService服务: 1234constructor( private heroService: HeroService, private routeParams: RouteParams) &#123;&#125; 在ngOnInit生命挂钩中,从RouteParams获取id参数,并从HeroService获取英雄 12345ngOnInit() &#123; let id = +this.routeParams.get(&apos;id&apos;); this.heroService.getHero(id) .then(hero =&gt; this.hero = hero);&#125; 注意到我们调用RouteParams.get来或得id let id = +this.routeParams.get(&#39;id&#39;); 由于英雄的id是一个数字,而Route得参数都是字符串,所以用JavaScript(+)进行数值转换. 增加HeroService.getHero1234getHero(id: number) &#123; return this.getHeroes() .then(heroes =&gt; heroes.filter(hero =&gt; hero.id === id)[0]);&#125; 返回用户通过选择点击或者URL输入跳转到HeroDetailComponent视图界面后,可以选择返回: 123goBack() &#123; window.history.back();&#125; 在对应模板增加返回点击事件绑定: 12345678910&lt;div *ngIf=&quot;hero&quot;&gt; &lt;h2&gt;&#123;&#123;hero.name&#125;&#125; details!&lt;/h2&gt; &lt;div&gt; &lt;label&gt;id: &lt;/label&gt;&#123;&#123;hero.id&#125;&#125;&lt;/div&gt; &lt;div&gt; &lt;label&gt;name: &lt;/label&gt; &lt;input [(ngModel)]=&quot;hero.name&quot; placeholder=&quot;name&quot; /&gt; &lt;/div&gt; &lt;button (click)=&quot;goBack()&quot;&gt;Back&lt;/button&gt;&lt;/div&gt; 最后,我们的HeroDettailComponent如下: 12345678910111213141516171819202122232425262728import &#123; Component, OnInit &#125; from &apos;@angular/core&apos;;import &#123; RouteParams &#125; from &apos;@angular/router-deprecated&apos;;import &#123; Hero &#125; from &apos;./hero&apos;;import &#123; HeroService &#125; from &apos;./hero.service&apos;;@Component(&#123; selector: &apos;my-hero-detail&apos;, templateUrl: &apos;app/hero-detail.component.html&apos;,&#125;)export class HeroDetailComponent implements OnInit &#123; hero: Hero; constructor( private heroService: HeroService, private routeParams: RouteParams) &#123; &#125; ngOnInit() &#123; let id = +this.routeParams.get(&apos;id&apos;); this.heroService.getHero(id) .then(hero =&gt; this.hero = hero); &#125; goBack() &#123; window.history.back(); &#125;&#125; 选择一个Dashboard英雄当用户从dashboard选择一个英雄,应用将会跳转到HeroDetailComponent视图,并可以编辑英雄. 在dashbaord的模板里,绑定了英雄点击事件到gotoDetail方法里,并将选择的英雄实体传入: &lt;div *ngFor=&quot;let hero of heroes&quot; (click)=&quot;gotoDetail(hero)&quot; class=&quot;col-1-4&quot;&gt; 之前重写DashboardComponent的时候,我们还未完成gotoDetail方法,现在我们将它实现: 1234gotoDetail(hero:Hero) &#123;truelet link = [&apos;HeroDetail&apos;, &#123;id: hero.id&#125;];truethis.router.navigate(link);&#125; 这个gotoDetail方法通过两个步骤导航: 1. 设置一个路由连接参数数组 2. 将该数组传入路由器的navigate方法 link数组有两个元素,目标路由的命名以及路由参数对象,和在AppComponent中的路由配置是相对应的. 12345&#123; path: &apos;/detail/:id&apos;, name: &apos;HeroDetail&apos;, component: HeroDetailComponent&#125;, DashboardComponent还没有路由,我们将其加入: 123456import &#123; Router &#125; from &apos;@angular/router-deprecated&apos;;...constructor( private router: Router, private heroService: HeroService) &#123;&#125; HerosComponent里选择一个英雄123456789101112template: ` &lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt; &lt;h2&gt;My Heroes&lt;/h2&gt; &lt;ul class=&quot;heroes&quot;&gt; &lt;li *ngFor=&quot;let hero of heroes&quot; [class.selected]=&quot;hero === selectedHero&quot; (click)=&quot;onSelect(hero)&quot;&gt; &lt;span class=&quot;badge&quot;&gt;&#123;&#123;hero.id&#125;&#125;&lt;/span&gt; &#123;&#123;hero.name&#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;my-hero-detail [hero]=&quot;selectedHero&quot;&gt;&lt;/my-hero-detail&gt;`, 删除标签,我们不用显示完整的HeroDetailComponent了,它将显示在自己的页面上,同时当用户从列表选择一个英雄,我们将不会进入detail页面,我们先显示一个mini-detail页面,当用户再次点击这个页面的时候,才会导航到完全的详情页. 增加一个mini-detail123456&lt;div *ngIf=&quot;selectedHero&quot;&gt; &lt;h2&gt; &#123;&#123;selectedHero.name | uppercase&#125;&#125; is my hero &lt;/h2&gt; &lt;button (click)=&quot;gotoDetail()&quot;&gt;View Details&lt;/button&gt;&lt;/div&gt; 在点击一个英雄后,用户将会看到以下的页面: 注意到英雄名都是大写,这是UpperCasePipe的效果,(|)是一个管道操作符,管道擅长对格式化一些字符串,金钱符号,日期等数据. 关于管道可以查看管道章节 将内容移除组件文件 我们还需要更新组件类,完成用户点击View Details按钮功能.这个组件文件越来越大,大部分是模板或者CSS样式,很难找到组件的逻辑代码,让我们稍微重构下: 1. 将模板内容移动到hereos.component.html文件 2. 将样式内容移到heroes.component.css文件 3. 分别设置templateUrl和styleUrls为上述两文件 12345@Component(&#123; selector: &apos;my-heroes&apos;, templateUrl: &apos;app/heroes.component.html&apos;, styleUrls: [&apos;app/heroes.component.css&apos;]&#125;) 现在组件的代码比较干净了,可以更清晰的看出其逻辑: 1. 导入router 2. 将router注入构造器 3. 实现gotoDetail方法:调用router.navigate方法传入HeroDetail的链接参数数组. 12345678910111213141516171819app/heroes.component.ts (class)export class HeroesComponent implements OnInit &#123; heroes: Hero[]; selectedHero: Hero; constructor( private router: Router, private heroService: HeroService) &#123; &#125; getHeroes() &#123; this.heroService.getHeroes().then(heroes =&gt; this.heroes = heroes); &#125; ngOnInit() &#123; this.getHeroes(); &#125; onSelect(hero: Hero) &#123; this.selectedHero = hero; &#125; gotoDetail() &#123; this.router.navigate([&apos;HeroDetail&apos;, &#123; id: this.selectedHero.id &#125;]); &#125;&#125; App样式App的功能已经完成了,但是界面还不是很美观,我们的设计师提供了一些CSS文件来优化它. Dashboard样式设计师认为dashboard的英雄们用一组矩阵来显示,他们给了我们可实现响应式的大概60行CSS代码. 在aoo文件夹下面增加一个dashboard.component.css文件,并放入组件元数据styleUrls数组属性里. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162styleUrls: [&apos;app/dashboard.component.css&apos;][class*=&apos;col-&apos;] &#123; float: left;&#125;*, *:after, *:before &#123; -webkit-box-sizing: border-box; -moz-box-sizing: border-box; box-sizing: border-box;&#125;h3 &#123; text-align: center; margin-bottom: 0;&#125;[class*=&apos;col-&apos;] &#123; padding-right: 20px; padding-bottom: 20px;&#125;[class*=&apos;col-&apos;]:last-of-type &#123; padding-right: 0;&#125;.grid &#123; margin: 0;&#125;.col-1-4 &#123; width: 25%;&#125;.module &#123; padding: 20px; text-align: center; color: #eee; max-height: 120px; min-width: 120px; background-color: #607D8B; border-radius: 2px;&#125;h4 &#123; position: relative;&#125;.module:hover &#123; background-color: #EEE; cursor: pointer; color: #607d8b;&#125;.grid-pad &#123; padding: 10px 0;&#125;.grid-pad &gt; [class*=&apos;col-&apos;]:last-of-type &#123; padding-right: 20px;&#125;@media (max-width: 600px) &#123; .module &#123; font-size: 10px; max-height: 75px; &#125;&#125;@media (max-width: 1024px) &#123; .grid &#123; margin: 0; &#125; .module &#123; min-width: 60px; &#125;&#125; 英雄详情界面优化app目录下增加一个hero-detail.component.css文件,内容如下: 1234567891011121314151617181920212223242526272829label &#123; display: inline-block; width: 3em; margin: .5em 0; color: #607D8B; font-weight: bold;&#125;input &#123; height: 2em; font-size: 1em; padding-left: .4em;&#125;button &#123; margin-top: 20px; font-family: Arial; background-color: #eee; border: none; padding: 5px 10px; border-radius: 4px; cursor: pointer; cursor: hand;&#125;button:hover &#123; background-color: #cfd8dc;&#125;button:disabled &#123; background-color: #eee; color: #ccc; cursor: auto;&#125; 导航链接界面优化app目录下增加一个app.component.css文件,内容如下: 12345678910111213141516171819202122232425262728h1 &#123; font-size: 1.2em; color: #999; margin-bottom: 0;&#125;h2 &#123; font-size: 2em; margin-top: 0; padding-top: 0;&#125;nav a &#123; padding: 5px 10px; text-decoration: none; margin-top: 10px; display: inline-block; background-color: #eee; border-radius: 4px;&#125;nav a:visited, a:link &#123; color: #607D8B;&#125;nav a:hover &#123; color: #039be5; background-color: #CFD8DC;&#125;nav a.router-link-active &#123; color: #039be5;&#125; 应用全局样式之前的样式都是组件内有效,我们也可以在应用层面上组件之外创建一个全局样式,比如设计师提供一些基础样式需要在整个应用内有效的. 12345678910111213141516171819202122232425styles.css (app styles excerpt)/* Master Styles */h1 &#123; color: #369; font-family: Arial, Helvetica, sans-serif; font-size: 250%;&#125;h2, h3 &#123; color: #444; font-family: Arial, Helvetica, sans-serif; font-weight: lighter;&#125;body &#123; margin: 2em;&#125;body, input[text], button &#123; color: #888; font-family: Cambria, Georgia;&#125;/* . . . *//* everywhere else */* &#123; font-family: Arial, Helvetica, sans-serif;&#125; 增加一个新的styles.css文件,并在index.html里引用它. &lt;link rel=&quot;stylesheet&quot; href=&quot;styles.css&quot;&gt; 现在我们的app是这个样子了. 小结 我们增加了一个Angular路由组件 我们学习了如何创建导航菜单栏的路由链接. 我们使用路由参数跳转到用户选择英雄的详情页 多组件共享HeroService 分离HTML和CSS文件到各自的文件 uppercase管道来格式化数据 未来之路现在万事俱备,只欠东风了,就是远程数据接入. 下一章,我们将从一个http服务器上来获取英雄数据. Http我们的合伙人对我们的项目进度非常满意,现在他们想要从别的服务器获取英雄数据了,让用户可以增加,编辑,删除英雄,并将改动同步到服务器. 在这个章节,我们将会教大家如何响应和调用一个web服务的api. 在线示例在此. Http准备Http并不是Angular的核心模块,它属于插件,分离在npm包进行管理.不过我们可以直接从@angular/http导入Http,因为systemjs.config已经配置SystemJS加载了这个库. 注册http服务http服务还依赖于其他的services,HTTP_PROVIDERS,我们需要在应用的任意一个位置接入这些服务.所以当启动应用加载根组件AppComponent的时候,需要将这些服务注册到main.ts的bootstrap中. 123456import &#123; bootstrap &#125; from &apos;@angular/platform-browser-dynamic&apos;;import &#123; HTTP_PROVIDERS &#125; from &apos;@angular/http&apos;;import &#123; AppComponent &#125; from &apos;./app.component&apos;;bootstrap(AppComponent, [ HTTP_PROVIDERS ]); 注意到HTTP_PROVIDERS时再一个数组中,这个和@Component的provicer效果类似. 模拟web api我们一般建议将应用级别的服务注册到AppComponent的provicers里,这里我们注册到main里是有特殊的原因的. 我们的应用需要经历很长一段时间的开发测试才能最终发布,那个时候我们甚至没有一个可以处理heroes的web服务,所以我们需要模拟一个,内存服务器,而这个web服务对应用来讲是透明了,它不需要知道这个是模拟环境还是真实环境,所以这部分的配置需要放到AppComponent上层来配置. app/main.ts 1234567891011121314151617// Imports for loading &amp; configuring the in-memory web apiimport &#123; XHRBackend &#125; from &apos;@angular/http&apos;;import &#123; InMemoryBackendService, SEED_DATA &#125; from &apos;angular2-in-memory-web-api&apos;;import &#123; InMemoryDataService &#125; from &apos;./in-memory-data.service&apos;;// The usual bootstrapping importsimport &#123; bootstrap &#125; from &apos;@angular/platform-browser-dynamic&apos;;import &#123; HTTP_PROVIDERS &#125; from &apos;@angular/http&apos;;import &#123; AppComponent &#125; from &apos;./app.component&apos;;bootstrap(AppComponent, [ HTTP_PROVIDERS, &#123; provide: XHRBackend, useClass: InMemoryBackendService &#125;, // in-mem server &#123; provide: SEED_DATA, useClass: InMemoryDataService &#125; // in-mem server data]); in-memory-data.service.ts文件,内容如下: 1234567891011121314151617export class InMemoryDataService &#123; createDb() &#123; let heroes = [ &#123;id: 11, name: &apos;Mr. Nice&apos;&#125;, &#123;id: 12, name: &apos;Narco&apos;&#125;, &#123;id: 13, name: &apos;Bombasto&apos;&#125;, &#123;id: 14, name: &apos;Celeritas&apos;&#125;, &#123;id: 15, name: &apos;Magneta&apos;&#125;, &#123;id: 16, name: &apos;RubberMan&apos;&#125;, &#123;id: 17, name: &apos;Dynama&apos;&#125;, &#123;id: 18, name: &apos;Dr IQ&apos;&#125;, &#123;id: 19, name: &apos;Magma&apos;&#125;, &#123;id: 20, name: &apos;Tornado&apos;&#125; ]; return &#123;heroes&#125;; &#125;&#125; 更多Http内容,查看[Http]章节.记住,in-memory-web api只在开发早期有用. 英雄和Http目前HeroService代码实现: 123getHeroes() &#123; return Promise.resolve(HEROES);&#125; 我们返回一个模拟数据的promise解析数据,我们已经为使用Http客户端异步获取数据做好了准备: 123456getHeroes(): Promise&lt;Hero[]&gt; &#123;return this.http.get(this.heroesUrl) .toPromise() .then(response =&gt; response.json().data) .catch(this.handleError);&#125; Http Promise我们仍然返回的是一个promise,但看上去有点复杂. Angular http.get 返回一个 RxJS的Observable. Observable是一个有效管理异步数据流的方式,稍后我们再详细讲解. 现在,我们往下看,获取Observable之后使用.toPromise()操作符将它转换为Promise.但是Angular的Observable没有toPromise方法,我们需要从RxJS库里引入额外的扩展: import &#39;rxjs/add/operator/toPromise&#39;; 解析数据并回调在promise的then回调里,调用Response的json方法解析数据,json目标有一个data属性,这个data属性里就是调用者想要的英雄数组,所以我们获取这个数组,并以解析的promise值返回.调用者还是和以前一样使用这个promise的英雄数据,它不需要关心这个值是怎么来的,或者从哪里来的. 错误处理.catch(this.handleError); 抓取服务器的错误并将它传入错误处理器进行处理,这个处理函数非常关键!我们必须未雨绸缪: 1234private handleError(error: any) &#123; console.error(&apos;An error occurred&apos;, error); return Promise.reject(error.message || error);&#125; 在这个demo服务里,我们将错误放到控制台,真实应用里,需要设计好日志管理对错误进行记录. 增加,编辑,删除我们很快有了新的需求,需要有增删改的功能. Post我们使用post方法来新增英雄.Post请求相比Get请求需要有更多的设置. 1234567891011// Add new Heroprivate post(hero: Hero): Promise&lt;Hero&gt; &#123; let headers = new Headers(&#123; &apos;Content-Type&apos;: &apos;application/json&apos;&#125;); return this.http .post(this.heroesUrl, JSON.stringify(hero), &#123;headers: headers&#125;) .toPromise() .then(res =&gt; res.json().data) .catch(this.handleError);&#125; Putput 是用来编辑一个指定英雄,但结构和post请求非常的相似. 12345678910111213// Update existing Heroprivate put(hero: Hero) &#123; let headers = new Headers(); headers.append(&apos;Content-Type&apos;, &apos;application/json&apos;); let url = `$&#123;this.heroesUrl&#125;/$&#123;hero.id&#125;`; return this.http .put(url, JSON.stringify(hero), &#123;headers: headers&#125;) .toPromise() .then(() =&gt; hero) .catch(this.handleError);&#125; Deletedelete 用来删除英雄 1234567891011delete(hero: Hero) &#123; let headers = new Headers(); headers.append(&apos;Content-Type&apos;, &apos;application/json&apos;); let url = `$&#123;this.heroesUrl&#125;/$&#123;hero.id&#125;`; return this.http .delete(url, headers) .toPromise() .catch(this.handleError);&#125; Save我们将post和put方法组装成一个save方法,封装了逻辑(id存在就编辑,不存在就新增),让HeroDetailCompnent更加简洁. 123456save(hero: Hero): Promise&lt;Hero&gt; &#123; if (hero.id) &#123; return this.put(hero); &#125; return this.post(hero);&#125; 现在我们的HeroService代码如下: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576import &#123; Injectable &#125; from &apos;@angular/core&apos;;import &#123; Headers, Http &#125; from &apos;@angular/http&apos;;import &apos;rxjs/add/operator/toPromise&apos;;import &#123; Hero &#125; from &apos;./hero&apos;;@Injectable()export class HeroService &#123; private heroesUrl = &apos;app/heroes&apos;; // URL to web api constructor(private http: Http) &#123; &#125; getHeroes(): Promise&lt;Hero[]&gt; &#123; return this.http.get(this.heroesUrl) .toPromise() .then(response =&gt; response.json().data) .catch(this.handleError); &#125; getHero(id: number) &#123; return this.getHeroes() .then(heroes =&gt; heroes.filter(hero =&gt; hero.id === id)[0]); &#125; save(hero: Hero): Promise&lt;Hero&gt; &#123; if (hero.id) &#123; return this.put(hero); &#125; return this.post(hero); &#125; delete(hero: Hero) &#123; let headers = new Headers(); headers.append(&apos;Content-Type&apos;, &apos;application/json&apos;); let url = `$&#123;this.heroesUrl&#125;/$&#123;hero.id&#125;`; return this.http .delete(url, headers) .toPromise() .catch(this.handleError); &#125; // Add new Hero private post(hero: Hero): Promise&lt;Hero&gt; &#123; let headers = new Headers(&#123; &apos;Content-Type&apos;: &apos;application/json&apos;&#125;); return this.http .post(this.heroesUrl, JSON.stringify(hero), &#123;headers: headers&#125;) .toPromise() .then(res =&gt; res.json().data) .catch(this.handleError); &#125; // Update existing Hero private put(hero: Hero) &#123; let headers = new Headers(); headers.append(&apos;Content-Type&apos;, &apos;application/json&apos;); let url = `$&#123;this.heroesUrl&#125;/$&#123;hero.id&#125;`; return this.http .put(url, JSON.stringify(hero), &#123;headers: headers&#125;) .toPromise() .then(() =&gt; hero) .catch(this.handleError); &#125; private handleError(error: any) &#123; console.error(&apos;An error occurred&apos;, error); return Promise.reject(error.message || error); &#125;&#125; 更新组件现在HeroService已经可以满足增删改的要求了,我们需要更新下对应的组件,让它支持这些功能.首先引入这些方法. 1234567import &#123; Component, EventEmitter, Input, OnInit, Output &#125; from &apos;@angular/core&apos;;export class HeroDetailComponent implements OnInit &#123; @Input() hero: Hero; @Output() close = new EventEmitter(); error: any; navigated = false; // true if navigated here 增加/编辑HeroDetailComponent我们已经有了HeroDetailComponent来查看指定英雄的详情.增加和编辑是详情视图的扩展,我们可以服用这个组件.原来这个组件是用于渲染一个存在的数据,现在我们需要考虑当对象为空时如何初始化hero属性. 1234567891011ngOnInit() &#123; if (this.routeParams.get(&apos;id&apos;) !== null) &#123; let id = +this.routeParams.get(&apos;id&apos;); this.navigated = true; this.heroService.getHero(id) .then(hero =&gt; this.hero = hero); &#125; else &#123; this.navigated = false; this.hero = new Hero(); &#125;&#125; 为了区分新增还是编辑,我们通过检查url里的id参数是否存在来判断,如果id不存在,我们将HeroDetailComponent绑定到一个空的Hero对象,如果存在则将渲染这个存在的英雄. 下一步是增加一个HeroDetailComponent方法: 123456789save() &#123; this.heroService .save(this.hero) .then(hero =&gt; &#123; this.hero = hero; // saved hero, w/ id if new this.goBack(hero); &#125;) .catch(error =&gt; this.error = error); // TODO: Display error message&#125; 在保存英雄以后,通过goBack重定向到之前的页面. 1234goBack(savedHero: Hero = null) &#123; this.close.emit(savedHero); if (this.navigated) &#123; window.history.back(); &#125;&#125; 这里我们调用了emit,是为了通知我们刚刚增加或者修改了一个英雄. HeroesComponent监听这个通知信息,并自动刷新英雄列表. HeroesComponent里的增删用户可以通过点击按钮或者输入名字的方式新增英雄. 当用户点击 Add New Hero 按钮,我们展示一个HeroDetailComponent.我们不导航到这个组件里,这样我们就不会获取到id参数,通过前面设计可知,这就表示创建一个空的英雄对象. 增加以下的HTML到heroes.component.html: 1234&lt;button (click)=&quot;addHero()&quot;&gt;Add New Hero&lt;/button&gt;&lt;div *ngIf=&quot;addingHero&quot;&gt; &lt;my-hero-detail (close)=&quot;close($event)&quot;&gt;&lt;/my-hero-detail&gt;&lt;/div&gt; 用户可以通过点击英雄名字下面的删除按钮来删除一个已存在的英雄. 1&lt;button class=&quot;delete-button&quot; (click)=&quot;delete(hero, $event)&quot;&gt;Delete&lt;/button&gt; 现在让我们来修改HeroesComponent让它可以支持增删行为. 我们使用HeroDetailComponent来获取新的英雄嘻嘻,我们不得不导入并在directives数组里引用它的方式来告诉Aangular. 12345678import &#123; HeroDetailComponent &#125; from &apos;./hero-detail.component&apos;;@Component(&#123; selector: &apos;my-heroes&apos;, templateUrl: &apos;app/heroes.component.html&apos;, styleUrls: [&apos;app/heroes.component.css&apos;], directives: [HeroDetailComponent]&#125;) 接着,我们事先增加英雄的点击按钮: 123456789addHero() &#123; this.addingHero = true; this.selectedHero = null;&#125;close(savedHero: Hero) &#123; this.addingHero = false; if (savedHero) &#123; this.getHeroes(); &#125;&#125; 删除的逻辑会稍微复杂点: 12345678910delete(hero: Hero, event: any) &#123; event.stopPropagation(); this.heroService .delete(hero) .then(res =&gt; &#123; this.heroes = this.heroes.filter(h =&gt; h !== hero); if (this.selectedHero === hero) &#123; this.selectedHero = null; &#125; &#125;) .catch(error =&gt; this.error = error); // TODO: Display error message&#125; 让我们来看看现在应用的效果: 应用结构如下:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051angular2-tour-of-heroesapp--app.component.ts--component.css--dashboard.component.css--dashboard.component.html--dashboard.component.ts--hero.ts--hero-detail.component.css--hero-detail.component.html--hero-detail.component.ts--hero.service.ts--heroes.component.css--heroes.component.html--heroes.component.ts--main.ts--hero-data.service.tsnode_modules ...typings ...index.htmlpackage.jsonstyles.csssample.csssystemjs.config.jsontsconfig.jsontypings.json 总结至此本教程结束了,代码打包.]]></content>
      <categories>
        <category>开发者手册</category>
      </categories>
      <tags>
        <tag>Angularjs2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[穷爸爸富爸爸]]></title>
    <url>%2F2016%2F06%2F14%2FRich-Dad-Poor-Dad%2F</url>
    <content type="text"><![CDATA[人过三十,回想过往，在杭州折腾了几年,买房卖房,买车,现在回了自己老家,实在也没什么积蓄,有车有房那是负债,除此之外没有资产，更实现不了财务自由。倒不是觉得自己没有财商，而是缺少教育，缺乏思想的启蒙。这就是书的价值，让你有机会可以接触到优秀的思想，冲击你的价值观，引发自己的思考。我觉得实现财务自由，并不是你一定要有多少钱，而是你是否能够真正的脱离财务来实现自由，来让自己过的更充实，不用疲于上班疲于赚钱疲于那些冠冕堂皇的事业。有些人很富裕，但他的内心很贫瘠，有些人很贫穷，但是他的内心很富足，幸福就是如此吧。 读书笔记 要懂得如何[让钱来替你工作],而不是[为了钱而工作]. 作者不鼓励找一份”稳定的工作”,重要的是要有老板心态,要多想想自己要什么,要成为什么样的人,用老板的眼光思考全局.当你没有面包的时候,要考虑怎么让人给你送上面包,而不是自己上班去赚,饱汉不知饿汉饥,让饿汉去思考还是略难的. 什么是资产?资产是向你口袋送钱的东西.什么是负债?负债就是把钱从你口袋掏出的东西. 首先支付自己，先确保自己的资产,再去偿还负债,这样才能积累财富.比如,每个月拿出固定的资金进行理财和投资,剩余的部分偿还住房按揭,信用卡等等,那不够了怎么办?想办法开源啊. 从长期来看,重要的不是你挣了多少钱,而是要看你能留下多少钱,以及留住多久. 这点非常赞同.有一个同事,外号股神,她老婆就经常控诉他,’结婚没指望上他这笔钱,买房也没指望上他这笔钱,生娃更没指望上他这笔钱’,在股市里赚了再多的钱,不拿出来,那也只是个数字,没有转化到生活价值里,即便他是资产,它也可能会有赔的一天.做生意也一样,有些人大起大落,起的时候风光无限,落的时候一蹶不振,重要的不是你挣了多少钱,而是看你能保住多少留下多少,保住多久留住多久. 金钱从来不是真正的资产，我们唯一的，真正的资产是我们的头脑。 (即：思维方式) 学无止境，不要放弃对求知的渴望.觉得在校读书无用，是因为离开学校后就放弃了学习。最大的投资，就是投资教育，投资自己。 几个步骤,让我们开始行动. 我需要一个超现实的理由:精神的力量. 我们要财务自由 每天作出自己的选择:选择的力量,这是人们希望生活在一个自由国度的主要原因. 多学会思考 慎重的选择朋友–关系的力量。 物以类聚，人以群分 快速学习。 掌握一种模式，吃透它，举一反三，然后快速的学习另外一种。 首先支付自己–自律。 自律是最重要的，如果控制不了自己，就不要想着致富。在资产的支配上，首先支付自己 购买奢侈品。 用消费的欲望来激发并利用理财的天赋去投资 偶像。 对英雄的崇拜，可以借鉴和鞭挞自己，多看看传记 先予后取。 乐善好施是必须的，这就是给予的力量。如果你想获得就要先给予。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>博闻</tag>
        <tag>财富</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[偷影子的人]]></title>
    <url>%2F2016%2F06%2F14%2FLe-voleur-d'ombres%2F</url>
    <content type="text"><![CDATA[读书笔记 我只是你生活里的一个影子，你却在我的生命里占有重要地位。如果我只是个单纯的过客，为何要让我闯入你的生活？我千百次想过要离开你，但仅凭一己之力我做不到。 人们常常把一些小事抛在脑后，一些生命的片刻烙印在时光尘埃里，我们可以试着忽略，但这些微不足道的小事却一点一滴形成一条链子，将你牢牢与过去连在一起。 我喜欢看着围绕妈妈嘴角与眼周的细纹，我知道她很讨厌它们，但这些细纹却让我觉得心安，我从她脸上读到我们相依为命的痕迹。回到这里，或许我想念 的并不是我的童年，而是妈妈、我们相依的时光、星期六午后的超市生活、一起分享的晚餐、偶尔相对无言却更能感受彼此的亲密，很多夜里她都到我房间陪我，她会靠在我身旁，把手滑进我的发中…光阴转瞬即逝，这些最单纯的瞬间，却隽永地牢牢铭刻在我们心底。 你不能干涉别人的人生，就算是为了对方好。这是他的人生，只有他一个人能决定他的人生。你必须顺应事实，放手成长，你没有必要医治好在成长路上与你擦肩而过的每个人，即使你成为最顶尖的医生，也做不到这样。 生命中某些珍贵的片段，其实都来自于一些微不足道的小事. 青少年时期，我们总梦想着离开父母的一天，而改天，却换成父母离开我们了。于是我们就只能梦想着，能否有一时片刻，重新变回寄居父母屋檐下的孩子，能抱抱他们，不害羞地告诉他们，我们爱他们，为了让自己安心而紧紧依偎在他们身边。 神甫在妈妈的墓前主持弥撒。我听着他讲道，他说人们从来不会失去双亲，即使过世之后，他们还是与你们同在。那些对你们怀有感情，并且把全部的爱都奉献给你们，好让你们替他们活下去，会永远活在你们的心中，不会消失。 我再也不能看到你，再也不能听到你叫我的名字，就像从前每天早上你所做的那样。我再也嗅不到你衣服上适合你的香味，再也不能与你分享我的快乐与忧伤。我们再也不能互相倾诉，你再也无法整理插在客厅花瓶中的含羞草，那是我一月底为你摘来的。你再也不会戴夏天的草帽，不能披秋天第一波寒流来袭时你披在肩上的克什米尔披肩。你再也不会再十二月的雪覆盖花园时点燃壁炉。你在春天还未来临前离去，毫无预警地抛下我。在月台上得知你已不在时，我感觉到一生中前所未有的孤单。 每一个人都有自己的世界,一人一世界,光丽的外表或者强健的体魄并不能表示他人的幸福,每一个人都有自己的悲伤。外表风光强悍的马格,谁能想到他的晚餐没有一家人的陪伴，只有履行任务般的进行。这或许就是一个人光环下的阴影。所以没有一个人是最悲哀的。只是你不了解罢了。 我的白昼如同无止境的黑夜，而我如同行尸走肉肉一般穿越其中 我知道，人一旦开始说谎，就很难不继续下去，但我管不了那么多，每个人都有自己的理由。这一次，我也有我非得如此不可的理由]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>消遣类</tag>
        <tag>成长</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Angularjs2 5分钟入门手册(ts)]]></title>
    <url>%2F2016%2F06%2F06%2Fangularjs2-5-MINUTE-QUICKSTART%2F</url>
    <content type="text"><![CDATA[译者注:仅是官方文档的翻译.5分钟教程,5分钟入门,过易,本不想译,久未译,遂译. 我们将基于TypeScript来构建一个超级简单的Anglarjs2应用，同时为后续的APP应用开发,搭建好Angularjs2的开发环境. 在线示例在线示例 开始构建APP!前提: 安装 Node.jsnodejs官网 步骤1: 创建和配置工程 (a)创造工程文件夹 (b)增加一个包定义并配置文件 (c)安装包 (a) 创建文件12mkdir angular2-quickstartcd angular2-quickstart (b) 增加包定义和配置文件 package.json NPM的包配置文件, 列举了QuickStart依赖的包并定义了一些有用的脚本. tsconfig.json TypeScript的编译器配置文件 typings.json TypeScript标示定义文件 systemjs.config.js SystemJS配置文件 package.json: 12345678910111213141516171819202122232425262728293031323334353637&#123; &quot;name&quot;: &quot;angular2-quickstart&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;scripts&quot;: &#123; &quot;start&quot;: &quot;tsc &amp;&amp; concurrently \&quot;npm run tsc:w\&quot; \&quot;npm run lite\&quot; &quot;, &quot;lite&quot;: &quot;lite-server&quot;, &quot;postinstall&quot;: &quot;typings install&quot;, &quot;tsc&quot;: &quot;tsc&quot;, &quot;tsc:w&quot;: &quot;tsc -w&quot;, &quot;typings&quot;: &quot;typings&quot; &#125;, &quot;license&quot;: &quot;ISC&quot;, &quot;dependencies&quot;: &#123; &quot;@angular/common&quot;: &quot;2.0.0-rc.2&quot;, &quot;@angular/compiler&quot;: &quot;2.0.0-rc.2&quot;, &quot;@angular/core&quot;: &quot;2.0.0-rc.2&quot;, &quot;@angular/http&quot;: &quot;2.0.0-rc.2&quot;, &quot;@angular/platform-browser&quot;: &quot;2.0.0-rc.2&quot;, &quot;@angular/platform-browser-dynamic&quot;: &quot;2.0.0-rc.2&quot;, &quot;@angular/router&quot;: &quot;2.0.0-rc.2&quot;, &quot;@angular/router-deprecated&quot;: &quot;2.0.0-rc.2&quot;, &quot;@angular/upgrade&quot;: &quot;2.0.0-rc.2&quot;, &quot;systemjs&quot;: &quot;0.19.27&quot;, &quot;core-js&quot;: &quot;^2.4.0&quot;, &quot;reflect-metadata&quot;: &quot;^0.1.3&quot;, &quot;rxjs&quot;: &quot;5.0.0-beta.6&quot;, &quot;zone.js&quot;: &quot;^0.6.12&quot;, &quot;angular2-in-memory-web-api&quot;: &quot;0.0.12&quot;, &quot;bootstrap&quot;: &quot;^3.3.6&quot; &#125;, &quot;devDependencies&quot;: &#123; &quot;concurrently&quot;: &quot;^2.0.0&quot;, &quot;lite-server&quot;: &quot;^2.2.0&quot;, &quot;typescript&quot;: &quot;^1.8.10&quot;, &quot;typings&quot;:&quot;^1.0.4&quot; &#125;&#125; tsconfig.json: 123456789101112&#123; &quot;compilerOptions&quot;: &#123; &quot;target&quot;: &quot;es5&quot;, &quot;module&quot;: &quot;commonjs&quot;, &quot;moduleResolution&quot;: &quot;node&quot;, &quot;sourceMap&quot;: true, &quot;emitDecoratorMetadata&quot;: true, &quot;experimentalDecorators&quot;: true, &quot;removeComments&quot;: false, &quot;noImplicitAny&quot;: false &#125;&#125; typings.json: 1234567&#123; &quot;globalDependencies&quot;: &#123; &quot;core-js&quot;: &quot;registry:dt/core-js#0.0.0+20160317120654&quot;, &quot;jasmine&quot;: &quot;registry:dt/jasmine#2.2.0+20160505161446&quot;, &quot;node&quot;: &quot;registry:dt/node#4.0.0+20160509154515&quot; &#125;&#125; systemjs.config.js: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * System configuration for Angular 2 samples * Adjust as necessary for your application needs. */(function(global) &#123; // map tells the System loader where to look for things var map = &#123; &apos;app&apos;: &apos;app&apos;, // &apos;dist&apos;, &apos;@angular&apos;: &apos;node_modules/@angular&apos;, &apos;angular2-in-memory-web-api&apos;: &apos;node_modules/angular2-in-memory-web-api&apos;, &apos;rxjs&apos;: &apos;node_modules/rxjs&apos; &#125;; // packages tells the System loader how to load when no filename and/or no extension var packages = &#123; &apos;app&apos;: &#123; main: &apos;main.js&apos;, defaultExtension: &apos;js&apos; &#125;, &apos;rxjs&apos;: &#123; defaultExtension: &apos;js&apos; &#125;, &apos;angular2-in-memory-web-api&apos;: &#123; main: &apos;index.js&apos;, defaultExtension: &apos;js&apos; &#125;, &#125;; var ngPackageNames = [ &apos;common&apos;, &apos;compiler&apos;, &apos;core&apos;, &apos;http&apos;, &apos;platform-browser&apos;, &apos;platform-browser-dynamic&apos;, &apos;router&apos;, &apos;router-deprecated&apos;, &apos;upgrade&apos;, ]; // Individual files (~300 requests): function packIndex(pkgName) &#123; packages[&apos;@angular/&apos;+pkgName] = &#123; main: &apos;index.js&apos;, defaultExtension: &apos;js&apos; &#125;; &#125; // Bundled (~40 requests): function packUmd(pkgName) &#123; packages[&apos;@angular/&apos;+pkgName] = &#123; main: &apos;/bundles/&apos; + pkgName + &apos;.umd.js&apos;, defaultExtension: &apos;js&apos; &#125;; &#125; // Most environments should use UMD; some (Karma) need the individual index files var setPackageConfig = System.packageWithIndex ? packIndex : packUmd; // Add package entries for angular packages ngPackageNames.forEach(setPackageConfig); var config = &#123; map: map, packages: packages &#125;; System.config(config);&#125;)(this); (c) 安装依赖包使用npm安装package.json列出的依赖包. npm install 如果typings文件夹没有在npm install后显示,则需手动安装.npm run typings install 步骤2:第一个Aungular组件在工程跟目录下创建一个子文件夹APP mkdir app 增加一个组件文件app/app.component.ts 内容如下: 123456import &#123; Component &#125; from &apos;@angular/core&apos;;@Component(&#123; selector: &apos;my-app&apos;, template: &apos;&lt;h1&gt;My First Angular 2 App&lt;/h1&gt;&apos;&#125;)export class AppComponent &#123; &#125; AppComponent是应用的根组件.每一个Angular应用至少有一个根组件,通常都命名为AppComponent,组件是Angular应用最基础的构建模块.组件通过其关联的模板控制着视图的展示. 本快速入门教程里的示例虽然只是一个超级简单的组件,但已经包含了每一个组件的基本结构要素. import 引用想要的模块. @Component 装饰器告诉Angular这个组件的模板以及如何构建组件 组件类通过模板来控制视图的展示和行为 ImportAngular的应用都是模块化的,他们由许多不同作用的文件组成.Angular本身就是是一个包含构建应用所需功能的模块库. 当我们需要某个模块或者库的时候,就import它. 示例中我们从Angular 2核心模块引入Component,这样就可以使用@Component装饰器了. import { Component } from &#39;@angular/core&#39;; @Component decoratorComponent是一个注释器函数,应用这类元数据对象函数需要在前面加个@符号.@Component是一个装饰器: 1234@Component(&#123; selector: &apos;my-app&apos;, template: &apos;&lt;h1&gt;My First Angular 2 App&lt;/h1&gt;&apos;&#125;) 这个元数据对象有两个属性,selector和template. selector声明了一个简单的CSS选择器用来表示代表组件的HTML元素.这个组件的HTML元素名为my-app,Angular创建AppComponent实例并展示到承载这个组件的HTML的每一个my-app元素里 template声明组件相关的模板,决定了Angular如何渲染组件. 组件类文件的最后是一个AppComponent类. export class AppComponent { } 由于本入门示例中不存在需要做的功能,目前AppComponent类是空的,以后我们想构建应用的时候,需要扩充类的特性和应用逻辑. 步骤3:增加main.ts现在我们需要告诉Angular要加载根组件了,创建app/main.ts,内容如下: 123import &#123; bootstrap &#125; from &apos;@angular/platform-browser-dynamic&apos;;import &#123; AppComponent &#125; from &apos;./app.component&apos;;bootstrap(AppComponent); 要启动应用,我们引入了两样东西: Angular的浏览器bootstrap功能 应用的根组件AppComponent 然后调用bootstrap(AppComponent),Bootstrapping是平台的一个特性. 注意到我们从@angular/platform-browser-dynamic而不是从@angular/core引入bootstrap功能. Bootstrapping不属于核心库,这是因为可能会有多种方式启动Angular应用(没错,移动端/桌面/web端等等).当然,大部分的应用都是从浏览器库调用bootstrap方法的.但也有可能从不同的环境里加载组件,比如从Apache Cordova或者NativeScript加载,并运行在移动设备上.我们也有可能希望从服务器渲染第一个页面来改进性能或者加强SEO.这就需要有不同种类的bootstrap. __为什么要分离main.ts和app组件文件这只是一个简单的入门示例,现在main.ts和app组件文件都很小,我们确实可以灵活的合并或者拆分它们.但我们想阐述一个更合理的Angular应用架构.App引导程序在不同的环境里多种多样,模块化分离文件,可以让测试变的更容易些,可以对某个组件进行单元测试,而不需要启动整个应用. 步骤4:增加index.html在工程根目录里创建一个index.html: 1234567891011121314151617181920212223&lt;html&gt; &lt;head&gt; &lt;title&gt;Angular 2 QuickStart&lt;/title&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;styles.css&quot;&gt; &lt;!-- 1. Load libraries --&gt; &lt;!-- Polyfill(s) for older browsers --&gt; &lt;script src=&quot;node_modules/core-js/client/shim.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;node_modules/zone.js/dist/zone.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;node_modules/reflect-metadata/Reflect.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;node_modules/systemjs/dist/system.src.js&quot;&gt;&lt;/script&gt; &lt;!-- 2. Configure SystemJS --&gt; &lt;script src=&quot;systemjs.config.js&quot;&gt;&lt;/script&gt; &lt;script&gt; System.import(&apos;app&apos;).catch(function(err)&#123; console.error(err); &#125;); &lt;/script&gt; &lt;/head&gt; &lt;!-- 3. Display the application --&gt; &lt;body&gt; &lt;my-app&gt;Loading...&lt;/my-app&gt; &lt;/body&gt;&lt;/html&gt; 这个index.html文件定义了承载这个应用的web页.HTML里的关键部分有: JavaScript库 SystemJS的配置文件,一个导入app模块引用main文件的脚本 在里的标签,这是我们这个应用渲染位置. 库我们加载以下脚本: 12345&lt;!-- Polyfill(s) for older browsers --&gt;&lt;script src=&quot;node_modules/core-js/client/shim.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;node_modules/zone.js/dist/zone.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;node_modules/reflect-metadata/Reflect.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;node_modules/systemjs/dist/system.src.js&quot;&gt;&lt;/script&gt; 首先是core-js,它是一个ES2015(ES6)的shim,这个猴子补丁替换全局上下文(window)的ES6功能要素.接着是Angular2,zone.js,reflect-metadata的plyfills,这样这些功能就可以兼容老的浏览器了.最后是用于模块加载的库SystemJS. SystemJS入门教程使用SystemJS加载应用和库模块.之前我们已经将systemjs.config.js文件加入到了工程根目录了.基本上可以用webpack替换,不过SystemJS已经是个好选择了,最终选择权这个取决于你. 所有的模块加载都需要有配置,所有的加载配置都会随着结构增加或者考虑性能等而变的复杂.我们建议在你精通加载器的配置,SystemJS配置教程. 有了这些意识后,我们看看systemjs.config.js做了些什么?首先,我们创建一个map告诉SystemJS去哪里查找需要引入的模块.然后,将所有的包注册到SystemJS,包括:工程依赖包和应用包,app包.app包告诉SystemJS如何从app/文件目录里请求一个模块.本示例使用TypeScript导入：1import &#123; AppComponent &#125; from &apos;./app.component&apos;; 注意模块名不需要文件扩展名，SystemJS根据配置文件设置文件的默认扩展名为js. System.import告诉SystemJS导入main文件；main是Aangular应用启动入口，我们可以抓取并记录启动时候的错误信息。所有其他的模块都由import导入. Angular调用main.ts里的bootstrap函数，它读取AppComponent的元数据，找到my-app选择器，定位my-app元素标签，并将组件转染到这些标签里. 增加样式样式并不是必须的但样式会让应用更加美观，在index.html里假设有个层级样式styles.css。创建一个styles.css文件在工程根目录，内容如下： 12345678910111213h1 &#123; color: #369; font-family: Arial, Helvetica, sans-serif; font-size: 250%;&#125;body &#123; margin: 2em;&#125; /* * See https://github.com/angular/angular.io/blob/master/public/docs/_examples/styles.css * for the full set of master styles used by the documentation samples */ 步骤5：构建和运行APP！打开一个终端窗口，敲入如下命令：npm start这个命令执行了两条node进程： 及时监控进行TypeScript编 lite-server静态服务器加载index.html到浏览器，当应用文件有修改时实时刷新浏览器 浏览器上就会打开并显示: wrap up我们最终的工程文件结构如下：1234567891011121314151617181920212223--angular2-quickstart----app------app.component.ts------main.ts----node_modules ...----typings ...----index.html----package.json----styles.css----systemjs.config.js----tsconfig.json----typings.json 打包下载 下一步？我们第一个应用没有太多的功能，只是最基础的angular2的”Hello, World”应用。我们写了一个简单的angular组件，构建了一个简单的index.html,并通过一个静态文件服务器加载它.这些就是这个 “Hello, World” app的全部了 后续教程 Tour of Heroes Tutorial!]]></content>
      <categories>
        <category>开发者手册</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Angularjs2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vs code 使用指南]]></title>
    <url>%2F2016%2F04%2F05%2Fvisual-studio-code-user-manual%2F</url>
    <content type="text"><![CDATA[基础设置字体设置 File-&gt;Preferences-&gt;User Settings 添加 “editor.fontSize”: 16 编码设置 User Settings 查看 Workspace Settings 的 files.encoding 命令面板 CMD+SHIFT+P 打开命令面板 CMD+P 通用命令面板.查找文件或者进行符号查找 ?: 查看命令行列表 #: 查找工程内匹配符号 @: 表示符号查找,接:进行删选符号查找.(CMD+SHIFT+O) !: 显示warnning和error.(CMD+SHIFT+M) CMD+Shift+F:跨文件搜索 CMD+G:跳转到行 CMD+TAB: 历史文件切换 编辑器 CMD+SHIFT+N: 打开新的编辑器窗口 CMD+N: 创建新文件 CMD+\: 分割编辑窗口. ‘Cmd’+ 1/2/3进行切换 CMD+B: 切换侧边栏 快捷键https://code.visualstudio.com/docs/customization/keybindings 智能编辑 CMD+.: 快速修复 更多 重构 OPT+UPARROW/DOWNARROW: 上下移动行 F8: 移动到下一个’Warning’或’Error’ F12/OPTION+F12: 跳转到定义 SHIFT F12: 查找所有的引用 CMD+F2/CMD+D: 匹配选择,本地重构 Click + OPTION: 点击选择,本地重构 F2:文件内重命名 Alt+Shift+F: 格式化 调试Debug快捷键 Continue / Pause F5 Step Over F10 Step Into F11 Step Out Shift+F11 Restart Ctrl+Shift+F5 Stop Shift+F5 更多 版本管理COMMITCMD+SHIFT+G进入git版本管理 CMD+ENTER:输入message后commit 切换分支CMD+P 输入 git checkout * 冲突管理版本库Visual Studio Team Services]]></content>
      <categories>
        <category>开发者工具</category>
      </categories>
      <tags>
        <tag>IDE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[渔家傲·塞下秋来风景异]]></title>
    <url>%2F2016%2F03%2F12%2Fsongci-3%2F</url>
    <content type="text"><![CDATA[【原文】渔家傲·塞下秋来风景异 作者：范仲淹 塞下①秋来风景异，衡阳雁去②无留意。四面边声③连角起，千嶂④里，长烟⑤落日孤城闭。 浊酒一杯家万里，燕然未勒⑥归无计。羌管⑦悠悠霜满地⑧。人不寐，将军白发征夫泪。 【注释】 ①塞下：边地。风景异：指景物与江南一带不同。 ②衡阳雁去：雁去衡阳的倒文。湖南衡阳县南有回雁峰，相传雁至此不再南飞。 ③边声：马嘶风号之类的边地荒寒肃杀之声。角：军中的号角。 ④嶂：像屏障一样并列的山峰。 ⑤长烟：荒漠上的烟。 ⑥燕然未勒：无破敌之功。燕然：山名，即今蒙古境内之杭爱山。勒：刻石记功。东汉窦宪追击北匈奴，出塞三千馀里，至燕然山刻石记功而还。燕然未勒：指边患未平、功业未成。 ⑦羌管：羌笛，因出自羌中，得名。 ⑧霜满地：喻夜深寒重。 【作品简介】这是一首抒怀词。当时范仲淹任陕西经略副使兼知延州（今陕西延安市）。这是当时第一首描写边塞题材的作品，也是宋代最早表现军旅生活的词作。上阕写景。首句顿入，起调突兀，俊骨雄风，已自夺人。千峰连亘如屏障，一座孤城，日未落而城门紧闭。也突出布防将士的备战警惕。下阕抒情。表达将士功业未立，无计归家的责任感，披露爱国衷肠。不愧苍凉感慨的豪士之伟词。这首词开启了苏辛豪放派的先声。 【翻译】边境上秋天一来风景全异，向衡阳飞去的雁群毫无留恋的情意。从四面八方传来的边地悲声随着号角响起。重重叠叠的山峰里，长烟直上落日斜照孤城紧闭。 喝一杯陈酒怀念家乡远隔万里，可是燕然还未刻上平胡的功绩，归期无法预计。羌人的笛声悠扬，寒霜撒满大地。征人不能入睡，将军头发花白，战士洒下眼泪。]]></content>
      <categories>
        <category>宋词</category>
      </categories>
      <tags>
        <tag>赏析</tag>
        <tag>宋词三百首</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[统计数字会说谎]]></title>
    <url>%2F2016%2F03%2F12%2Fhow-to-lie-with-stastics%2F</url>
    <content type="text"><![CDATA[序 虽然经验告诉我们’眼见为实’,但眼睛告诉我们的’真想’或许隐瞒了部分事实,或许夸大了事实. 统计这种神秘的语言,在一个靠数字说话的社会里是如此地吸引眼球,但有时它却被人利用,并成为恶意夸大或简化事实,迷惑他人的工具. 该书是一个利用统计数据行骗的入门书籍. 样本偏离统计数字的样本经常存在严重偏离的情况.会接受抽样调查的人,某种意义上已经进行了一部分情景化的过滤.样本碍于情面或者是尊严的问题,未必会说真话. 小结 为了确保结论有价值,根据抽样得出的结论一定要采用具有代表性的样本,这种样本才有可能排除误差 无形的误差和有形的误差一样容易破坏样本的可行度. 最基本的样本是随机样本,它是完全遵循随机原则从总体总选出来的.随机样本的校验方法:总体中的每个名字或每个事物是否具有相同的几率被选进样本? 一般而言,民意调查都具有一定的误差. 精心挑选的平均数 平均数：一组数据的总和除以这组数据个数所得到的商叫这组数据的平均数. 中位数：将一组数据按大小顺序排列,处在最中间位置的一个数叫做这组数据的中位数 . 众数：在一组数据中出现次数最多的数叫做这组数据的众数. 当你看到某个平均收入时,首先问问:是什么的平均?包括了哪些人? 没有披露的数据有时候单凭一个数据,如平均数来描述事物过于简单,起不到作用,不管这个平均数是均值还是中位数,也不管平均数的具体类型是否已知.需要关注其他未披露的数据,才能判断统计数据的准确性. 令人惊奇的图形 最简单的图形是直线图形,在显示趋势时,直线图形非常有用.然而只需要改变纵坐标和横坐标的比例关系,将会产生一张有迷惑作用的统计图形.统计图形具有客观性幻觉. 用图形描述统计事物,具有欺骗性,视觉作用起了非常大的作用.如数字比是2:1,但视觉效果却是4:1,而在大多数时候视觉效果起着决定性的作用. 相关关系的误解 两个事物之间的关联关系并不能用于说明其中一个将引起另外一个的变化. 如何反驳统计资料怎样凭借双眼就能识破虚假的统计资料,并揭开它的老底;同样重要的是,如何在这一大片充满了欺骗性的数据海洋中找出可靠有用的资料,我们只需要问5个问题. 谁说的?学术结论,实验结果以及报道引用都可能产生偏差,这些偏差可能是测量标准的改动造成的,也可能是不正确的测量方法造成的. 查看有意识的偏差. 查找无意识的偏差. 如引用到了权威人士,辨明内容是权威的还是资料是权威的. 它是如何知道的? 看样本是否有偏离. 采样数据是否足够大,观察值是否足够,从而保证结论的可靠性? 遗漏了什么? 很多数据由于没有进行有效的比较而失去意义 有时仅给出百分比却缺少原始数据也会造成欺骗.当看到一个指数时,需要了解它的基数. 遗漏了引起变化的原因,这容易让人认为是其他的因素才应对产生的变化负责. 如报道’最近25年癌症死亡人数增多’,这个结论会有误导性.事实上人口也在增多. 是否有人偷换了概念?数据的概念是否存在欺诈性?需要留心从搜集原始资料到形成结论的整个过程中,是否存在概念的偷换. 这个资料有意义吗?这个问题通常能将一个伪装的很好的统计资料打回原形.让人印象深刻的统计数据也会和实际情况相左. 奇妙的数据与平常的感觉不符 外推法十分有用,特别是预测趋势时.]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>大数据</tag>
        <tag>新知</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript精髓笔记]]></title>
    <url>%2F2016%2F03%2F12%2Fthe-good-parts-of-javascript%2F</url>
    <content type="text"><![CDATA[语法注释 没有用的注释比没有注释更糟糕. 建议避免使用/* */注释(可能会出现在正则表达式中),使用//. 数字 javascript只有一个数字类型,它在内部表示为64位的浮点数,和double类型一样. 负数可以用 - 加数字构成. NaN是一个数值,它表示一个不能产生正常结果的运算结果.isNaN(number)检测NaN. 字符串 \是转义字符 Unicode是一个16位的字符集,Javascript的所有字符都是16位的. Javascript没有字符类型 字符串是不可变的,可以通过+运算符连接其他字符串来创建一个新字符串. 对象引用 对象通过引用来传递,引用不会复制 原型 每一个对象都有一个原型对象,Object.prototype是Javascript中的标配对象 原型连接在更新时不起作用,对某个对象做出改变时,不会触及该对象的原型 原型连接在检索的时候会用到,属性会从原型链上查找. typeof和hasOwnProperty可以检查属性是否在对象中,后者不会检查原型链 枚举 for in该语句会遍历一个对象中的所有属性名.该枚举过程将会列出原型链上的所有属性,最常用的过滤器是hasOwnProperty方法,以及typeof来排除函数. 123456var name;for (name in sample) &#123; if (typeof sampe[name] !== 'function') &#123; document.writeln(name + ':' + sample[name]); &#125;&#125; 属性名出现的顺序是不确定的,通过for而不是for in才能按顺序获取属性 删除delete 不会删除原型链上的属性. 减少全局变量的污染Javascript可以随意的使用全局变量,全局变量削弱了程序的灵活性,应当避免使用. 函数 JS中函数是对象,每个函数创建的时候会附加两个隐藏属性:函数的上下文和实现函数行为的代码. 方法调用模式当一个函数被保存为一个对象的属性时,我们称之为方法.当一个方法被调用时,this被绑定到该对象 函数调用模式当一个函数并非一个对象的属性时,那么会被当做一个函数来调用,此时this被绑定到了全局变量(设计失误),可以用that方式来解决这个问题. 1234567891011myObject.double = function() &#123; var that = this; var helper = function ( that.value = add(that.value,that.value); ); helper(); //以函数的形式调用&#125;;myObject.double();doucument.writeln(myObject.vale); Apply调用模式因为JS是一门函数式的面向对象的语言,所以函数可以拥有方法. apply方法接收两个参数,第一个绑定给this,第二个是参数数组. 12var array = [3,4]; //构造一个包含两个数字的数组,并将它们相加.var sum = add.apply(null,array); // sum为7 闭包 避免属性被非法更改 省去想函数名字的麻烦 回调回调属于异步调用,执行上不会堵塞,事件驱动模式提高并发量和响应速度,nodejs上大量使用 模块我们可以使用闭包或者函数来构造模块.模块是一个提供接口缺隐藏状态与实现的函数或对象,可以提高程序的复用性. 数组 长度: JS的数组长度无上限 判断一个对象是否是数组: 123 var is_array = function (value) &#123; return Object.prototype.toString.apply(value) === '[object Array]';&#125; 方法:增加一个方法给数组 1234567Array.method('reduce', function (f,value) &#123; var i; for (i = 0; i &lt; this.length; i += 1)&#123; value = f(this[i],value); &#125; return value;&#125;) 制定初始值: 1234567Array.dim = function (dimension, initial) &#123; var a = [], i; for (i = 0; i &lt; dimension; i += 1) &#123; a [i] = initial; &#125; return a;&#125;; 正则表达式Javascript是一个大杂烩,许多特性继承自其他语言,语法继承自java/C,函数借鉴自Scheme,原型继承自Self. 示例1234var parse_url = /^(?:([A-Za-z]+):)?(\/&#123;0,3&#125;)([0-9.\-A-Za-z]+)(?::(\d+))?(?:\/([^?#]*))?(?:\?([^#]*))?(?:#(.*))?$/;var url = "http://www.ora.com:80/goodparts?q#fragment";var result = parse_url1.exec(url); //["http://www.ora.com:80/goodparts?q#fragment", "http", "//", "www.ora.com", "80", "goodparts", "q", "fragment"] ^ : 字符串开始标记. (?:([A-Za-z]+):): ?::非捕获性匹配 +: 匹配一次或多次 ?: 匹配零次或一次 (\/{0,3}):最少匹配0次,最多匹配3次 ([0-9.\-A-Za-z]+): 匹配主机名 (?::(\d+))?: 端口号匹配 (?:\/([^?#]*))?: 匹配出去?和#之外的所有字符. 结构有两个方法来创建一个RegExp对象. 正则表达式字面量. 如上文示例中的正则表达式就是采用字面量的方式. 1var reg=/&lt;%[^%&gt;]%&gt;/g; 使用RegExp构造器. 1var reg=new RegExp('&lt;%[^%&gt;]+%&gt;','g');; 正则表达式标识符 标示 含义 g 全局的(匹配多次) i 大小写不敏感 m 多行 元素构成正则表达式的元素有如下几种 正则表达式分支一个正则表达式分支包含一个或多个正则表达式序列.序列被|字符分隔. 1"into".match(/in|int/) //in匹配成功,不会去匹配int 正则表达式序列一个正则表达式序列包含一个或多个正则表达式因子. 正则表达式因子一个正则表达式因子可以是一个字符,圆括号包含的组,字符类,或者一个转义序列. 1\ / [ ] ( ) &#123; &#125; ? + * | . ^ $ 正则表达式转义 正则表达式分组 捕获型 非捕获型: ?: 向前正向匹配: ?= 向前负向匹配: ‘?!’ 正则表达式字符集: 一种指定一组字符的便利方式. 1(?:a|e|i|o|u) //写成 [aeiou] 正则表达式字符转义:在字符类中需要被转义的特殊字符有 1- / [ \ ] ^ 正则表达式量. 用来决定因子的匹配次数. 如{m,n} 方法Arrayconcat和pushconcat方法产生一个新数组,它包含一份array的浅复制.push和concat不同,push的参数作为单个元素添加到数组,并返回新数组的长度. 1234var a = ['a', 'b', 'c'];var b = ['x', 'y', 'z'];var c = a.concat(b, true);// c is ['a', 'b', 'c', 'x', 'y', 'z', true]var d = a.push(b,true) // a is ['a', 'b', 'c', ['x', 'y', 'z'], true], d is 5; join建议用+,性能更优 pop 和 shift类似stack, 移除最后一个元素,并返回该元素. 123var a = ['a', 'b', 'c'];var c = a.pop( ); // a is ['a', 'b'] &amp; c is 'c'var d = a.shift( ); // a is ['b'] &amp; d is 'a' push 和 unshiftpush将元素插入到数组末尾,unshift相反. 123var a = ['a', 'b', 'c'];var r = a.unshift('?'); // a is ['?', 'a', 'b', 'c'], r is 4var p = a.push('@');// a is ['?', 'a', 'b', 'c', '@'], p is 5 sort 和 reverse123var n = [4, 8, 15, 16, 23, 42,"a","b"];var b = n.sort( ); //n和b 都是 [15, 16, 23, 4, 42, 8, "a", "b"]var b = n.reverse( ); //n和b 都是 ["b", "a", 8, 42, 4, 23, 16, 15] sliceslice方法对array中的一段做浅复制. 1234var a = ['a', 'b', 'c'];var b = a.slice(0, 1); // b is ['a']var c = a.slice(1); // c is ['b', 'c']var d = a.slice(1, 2); // d is ['b'] splicearray.splice(start, deleteCount, item…) : 从start开始删除deleteCount数量的元素,并用item替换 1234var a = ['a', 'b', 'c'];var r = a.splice(1, 1, 'ache', 'bug');// a = ['a', 'ache', 'bug', 'c']// r = ['b'] Functionapplyapply 方法调用function, 产地一个会绑定到this上的对象和一个可选的数组作为参数. 123456789101112131415Function.method('bind', function (that) &#123; // Return a function that will call this function as // though it is a method of that object. var method = this, slice = Array.prototype.slice, args = slice.apply(arguments, [1]); return function ( ) &#123; return method.apply(that, args.concat(slice.apply(arguments, [0]))); &#125;;&#125;);var x = function ( ) &#123; return this.value;&#125;.bind(&#123;value: 666&#125;);alert(x( )); // 666 Number toExponential(fractionDigits):把number转换成一个指数形式的字符串.参数(0-20)控制小数点后的数字位数. 12Math.PI.toExponential() //"3.141592653589793e+0"Math.PI.toExponential(2) //"3.14e+0" toFixed(fractionDigits):把number转换成一个整数形式的字符串.参数(0-20)控制小数点后的数字位数. 123Math.PI.toFixed() //"3"Math.PI.toFixed(2) //"3.14"Math.PI.toFixed(0) //"3" toPrecision(precision):和toFixed类似,参数为精度. 12Math.PI.toPrecision() //"3.141592653589793"Math.PI.toPrecision(2) //"3.1" toString(radix):将number转换成为一个字符串,参数(2-36,默认10)为控制转换进制的基数. 12Math.PI.toString() //"3.141592653589793"Math.PI.toString(2) //"11.001001000011111101101010100010001000010110100011" Object hasOwnProperty(name):查看object是否包含该属性,原型链上不检查. 12345var a = &#123;member: 1&#125;;var b = Object.create(a);var t = a.hasOwnProperty('member'); // t is truevar u = b.hasOwnProperty('member'); // u is falsevar v = b.member; // v is 1 String charAt(pos): 返回string中pos位置的字符. 12var name = 'LZ';var initial = name.charAt(0); // initial is 'L' 实现 123String.method('charAt', function (pos) &#123; return this.slice(pos, pos + 1);&#125;); charCodeAt(pos): 返回pos位置的字符的字符码位. 12var name = 'LZ';var initial = name.charCodeAt(0); // 76 indexOf(searchString,position): 在string内查找从position开始的字符串searchString,并返回起始位. 和一些Regexp相关的方法:’match’,’replace’,’search’ slice,toLowerCase,toUpperCase 代码风格 空格:缩进为4个空格,除了.和[后均跟一个空格 K&amp;R风格,把{放在一行的结尾 毒瘤全局变量JS的全局变量降低了程序的可靠性,全局变量的三种方式: foo 1- 直接给全局变量添加一个属性 ```window.foo = value 隐式全局变量 foo = value 作用域Javascript的语法来自C,一个代码块会创造一个作用域.代码块中声明的变量在其外部是不可见的.JS采用这样的块语法,却没有提供块级作用域:代码块中声明的变量在包含此代码块的函数的任何位置都是可见的. 保留字保留字过多,而大部分并不是经常使用. UnicodeJS的Unicode是16位 糟粕请避免使用以下几个方法,使javascript的代码更加的简洁和高效. ==和!= with eval continue switch穿越 缺少块语句.判断语句用{}分隔. ++ --:递增和递减避免使用++,–的方式,使代码更为简洁 位运算符:Javascript没有整数类型,它只有双精度的浮点数,执行位运算的效率较低,要避免使用. void. new]]></content>
      <categories>
        <category>开发者手册</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[木兰花·城上风光莺语乱]]></title>
    <url>%2F2016%2F03%2F11%2Fsongci-2%2F</url>
    <content type="text"><![CDATA[【原文】木兰花·城上风光莺语乱① 作者：钱惟演 城上风光莺语乱②，城下烟波春拍岸。绿杨芳草几时休，泪眼愁肠先已断。 情怀渐觉成衰晚③，鸾镜④朱颜⑤惊暗换⑥。昔年⑦多病厌芳尊⑧，今日芳尊惟恐⑨浅。 【注释】 ①木花兰：通称《玉楼春》。 ②莺语：指美好的声音。 ③衰晚：衰弱的晚年。 ④鸾镜：厨（ｃｈú）宾王有鸾，三年不鸣。夫人说悬镜照之，鸾见影则鸣。故后世称镜为鸾镜，多借此词表达离愁别恨。 ⑤朱颜：朱，红。红润美好的容颜。南唐 李煜 《虞美人》词：“雕栏玉砌依然在，只是朱颜改。”宋 司马光 《和子华招潞公暑饮》：“闲来高韵浑如鹤，醉里朱颜却变童。”这里都是指容颜的改变。 ⑥暗换：这里指不知不觉的变成了殘颜。 ⑦昔年：一作“划年”，指今年，或者近几年。 ⑧芳尊：酒杯，指饮酒。尊，同“樽”。 ⑨惟恐：惟，只、单，唯一、只有。恐，怕。这里说只怕今天的容颜不好看。不美丽。 【作品简介】《木兰花·城上风光莺语乱》由钱惟演创作，被选入《宋词三百首》。这首词是作者临死前不久的一首伤春之作。上阕由景入情，下阕直抒愁怀。“情怀渐觉”、“衰晚”，一“渐”字，表达出时间的推移催老世人的历程，接着，作者又惊异地发现镜中“朱颜”已“暗换”，进一步表达“衰晚”之感。“今日”虽仍有病，可愁比病更强烈，因而不顾病情而痛饮狂喝，将全词愁绪推向高潮。 【翻译】城上眺望，风光大好，黄莺儿的叫声乱成一片。城下湖面上烟波浩渺，春水烟波浩渺，春水不断地拍打着堤岸。这令人伤怀的青青杨柳如绵绵芳草啊，你们什么时候才能变得没有呢？我眼中充满泪水，愁绪袭来，先就使我肝肠寸断了。 我觉得自己的情怀渐渐像个老人，没有生气了。还吃惊的发现镜子中昔日红润的容颜，在不知不觉中改换了，已变得如此憔悴苍老。往年，我体弱多病，讨厌去碰那美酒金杯，如今杯儿在前，却唯恐酒斟得不满。 【赏析】 这首词是作者临死前不久的一首伤春之作。上阕由景入情，下阕直抒愁怀。“情怀渐觉”、“衰晚”，一“渐”字，表达出时间的推移催老世人的历程，接着，作者又惊异地发现镜中“朱颜”已“暗换”，进一步表达“衰晚”之感。“今日”虽仍有病，可愁比病更强烈，因而不顾病情而痛饮狂喝，将全词愁绪推向高潮。 作者一生仕宦显达，晚年被贬外放，自觉政治生命与人生旅途都到了尽头，因作此词，借悼惜春光抒发他无限的迟暮之悲。词中用清丽的语言描绘了春声、春色，首句的“乱”字用得极好，将春景渲染得十分生动热闹，而群莺乱啼已是暮春天气，这里也暗含春光将尽之意。作者又用明丽的景色来反衬自己凄黯的心情，以及对于年光飞逝、生命无多的感伤。末二句以借酒浇愁来表现他无可奈何的心境，又隐约地显示了他对生命的留恋，尤其传神。整首词情调极其凄婉。 作品中的“芳草”、“泪眼”、“鸾镜”、“朱颜”等意象无不充满绝望后的浓重感伤色彩，反映出宋初纤丽词风的艺术特色。 上片起首两句，从城上和城下两处着墨，声形兼备、富于动感地描绘春景，勾勒出一幅城头上莺语阵阵、风光无限；城脚下烟波浩淼、春水拍岸的图画，使读者隐然感觉到主人公的伤春愁绪，从而为下文的遣怀抒情作好了铺垫。 上片结末两句转而抒情，言绿杨芳草年年生发，而词人已是眼泪流尽，愁肠先断，愁惨之气溢于言表。从表现手法上讲，用绿杨芳草来渲染泪眼愁肠，也就达到了情景相生的效果，情致极为凄婉。此二句由景入情，词意陡转，波澜突起。 过片两句，从精神与形体两方面感叹老之已至，抒写了词人无可奈何的伤感情怀。从中可以窥见，一贬汉东，默默无闻，大势已去，这对于曾经“官兼将相，阶勋、品皆第一”的作者来说，打击是多么巨大。结拍两句将借酒浇愁这一司空见惯的题材赋予新意，敏锐而恰切地扣住词人对“芳尊”态度的前后变化这一细节，形成强烈反差，由景入情，画龙点睛，传神地抒发出一个政治失意者的绝望心情。宋胡仔《苕溪渔隐丛话》卷二云：“侍儿小名录云：‘钱思公谪汉东日（指钱惟演晚年谪随州），撰《玉楼春》词曰：“城上风光莺语乱，城下烟波春拍岸。绿杨芳草几时休，泪眼愁肠先已断。情怀渐变成衰晚，鸾镜朱颜惊暗换。往年多病厌芳樽，今日芳樽惟恐浅。”每酒阑歌之，则泣下。后阁有白发姬，乃邓王歌鬟惊鸿也。遽言：“先王将薨，预戒挽铎中歌《木兰花》（即《玉楼春》）引绋为送。今相公亦将亡乎。”果薨于随州。’”可为此词注脚。 宋仁宗明道二年（1033）三月，垂帘听政的刘太后死。仁宗随即亲政，并迅速清除刘太后党羽。钱惟演是刘太后的姻亲，自然在劫难逃。九月，他因为擅议宗庙罪而被免除平章事的官职，贬为崇信军节度使，谪居汉东。不久，其子钱暖被罢官，姻亲郭皇后被废。该词就写于这个时期，抒发了作者政治失意的绝望之情。作品借丽景抒哀情，首句以一“乱”字，就将暮春之景渲染得有声有色，同时也以此反衬自己年华将逝的凄黯心情，从而形成强烈对比，凄惋动人。 【作者介绍】 钱惟演（977—1034）北宋大臣，西昆体骨干诗人。字希圣，钱塘（今浙江杭州）人。吴越忠懿王钱俶第十四子。从俶归宋，历右神武将军、太仆少卿、命直秘阁，预修《册府元龟》，累迁工部尚书，拜枢密使，官终崇信军节度使，博学能文，所著今存《家王故事》、《金坡遗事》。]]></content>
      <categories>
        <category>宋词</category>
      </categories>
      <tags>
        <tag>赏析</tag>
        <tag>宋词三百首</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FusionCharts Suite XT去水印]]></title>
    <url>%2F2016%2F03%2F10%2Ffusioncharts_cracker%2F</url>
    <content type="text"><![CDATA[闲来无事，挖掘了下单位的测试数据，分析生成pareto，用于持续改进,发现Fusioncharts有现成的模块可以用，向来不想重复造轮子，下载开袋即食，见有水印，遂去之，再此奉上。 拿来主义点此 授人以鱼不如授人以渔。 打开fusioncharts.js 搜索fusioncharts.com -&gt; 12&lt;span style="white-space:pre"&gt;&lt;/span&gt;Q="http://www.fusioncharts.com?BS=FCHSEvalMark&amp;utm_source=FCS_trial&amp;pver="+m.escape(d.core.version) 置空-&gt;Q=”” 搜索Trial-&gt; 12&lt;span style="white-space:pre"&gt;&lt;/span&gt;CREDIT_STRING:"FusionCharts XT Trial" 置空-&gt;CREDIT_STRING:””]]></content>
      <categories>
        <category>开发者手册</category>
      </categories>
      <tags>
        <tag>FusionCharts</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[宴山亭·北行见杏花]]></title>
    <url>%2F2016%2F03%2F10%2Fsongci-1%2F</url>
    <content type="text"><![CDATA[【原文】《宴山亭·北行见杏花》 作者：宋徽宗(赵佶) 裁剪冰绡，轻叠数重，淡著胭脂匀注。新样靓妆，艳溢香融，羞杀蕊珠宫女。易得凋零，更多少无情风雨。愁苦。问院落凄凉，几番春暮。 凭寄离恨重重，这双燕，何曾会人言语。天遥地远，万水千山，知他故宫何处。怎不思量，除梦里有时曾去。无据。和梦也新来不做。 【注释】 宴山亭：词牌名。“宴”通“燕”。 冰绡：洁白如冰的丝织品，绡（xiāo）：生丝。 生丝织物：～头（古代束发的头巾）。冰销，洁白的绸。此处比喻杏花的花瓣。 靓（jìng、liàng）妆：妆饰艳丽。 （古代靓字读jìng） 蕊珠宫：道教传说中的仙宫。 凭寄：凭谁寄，托谁寄。 者：同这 会：理解，懂得。 无据：不可靠。 和：连。 【作品简介】 《宴山亭·北行见杏花》由宋徽宗(赵佶)创作，被选入《宋词三百首》。《宴山亭》这首词曾被王国维称为“血书”。这首词是赵佶被人掳掠北去途中，见杏花而怀念故国的伤怀之作。开头描绘杏花的形态色彩，接着以杏花的美丽妆饰与天上宫女对比，透过此花，人们能看到曾为帝王、现为囚徒的作者及今日的后宫佳丽憔悴飘零的落魄之态。下阕由上阕写杏花转为写人。题意是“北上见杏花”，并非专咏物，所以“凭寄离恨重重”承上启下。“离恨”为点睛之笔。借对梦的期待，委婉表达，此刻的作者伤心到连梦也不做了！相思极苦，衷情哽咽，令人不忍多听。 【翻译】 剪裁好白色的丝绸，轻轻叠成数层，又将淡淡的胭脂均匀的涂抹，时髦的漂亮衣服，艳丽的色彩融入四溢的清香，简直羞杀了天上的蕊珠宫女。红颜易凋零，更何况，经历了多少无情的风雨 ，面对愁苦的情景，扣问凄凉的院落，还要经受几番春暮。 谁帮我寄去重重的离愁，这双飞的燕子哪里懂得人间的苦痛。天遥地迵，万水千山阻隔，哪里知道故园今在何处？只有在梦中有时曾去。就连梦也难做成，因我痛苦的彻夜难眠。 【赏析】 此词为北宋徽宗皇帝在1127年覆国被掳往北方五国城，北行途中见杏花而托物兴感而作。上片摹写杏花以寄意。“裁剪”三句写杏花之花质冰洁如白绸剪裁剪，花瓣簇绽轻柔重叠，花色淡雅似胭脂匀染。“新样”三句以拟人手法将杏花比喻为“靓妆”新颖，艳香流融的美女，直令天界蕊珠宫仙女为之羞惭汗颜。“易得凋零”，笔势陡转，写尽杏花遭受风雨摧折之凄凉愁苦。下片由感叹杏花凋落，转入自掳离恨。双燕不解人语，故宫天遥地远，怀乡思国，只有求之梦寐，如今梦亦不成，凄楚之至。借杏花之凋落，伤江山之陆沉；以归梦之难成，寓复国之绝望。全词托物咏怀，抒写故国沦亡之悲慨，幽咽委曲，伤感无奈，对故国沦亡一句悔恨与反思，又显见其情虽真而骨力乏弱。 【作者介绍】 宋徽宗，名赵佶（公元108211月2日～1135年6月4日），神宗11子，哲宗弟，是宋朝第八位皇帝。赵佶先后被封为遂宁王、端王。哲宗于公元1100年正月病死时无子，向皇后于同月立他为帝。第二年改年号为“建中靖国”。宋徽宗在位25年（1100年2月23日—1126年1月18日），国亡被俘受折磨而死，终年54岁，葬于永佑陵（今浙江省绍兴县东南35里处）。 他自创一种书法字体被后人称之为“瘦金书”，另外，他在书画上的花押是一个类似拉长了的“天”字，据说象征“天下一人”。]]></content>
      <categories>
        <category>宋词</category>
      </categories>
      <tags>
        <tag>赏析</tag>
        <tag>宋词三百首</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[邮件管理,outlook的邮箱设置]]></title>
    <url>%2F2016%2F03%2F10%2Femail_management%2F</url>
    <content type="text"><![CDATA[性格决定了命运，你的努力，选择，耐心都可能影响你的一生，如何为人处世是个大命题，这里不扯这些，仅聊一聊专注力的事情，如何屏蔽干扰。现在育儿都很注重一点，就是专注力。我女儿在认真玩耍的时候，有人尝试去逗她玩，我都会及时阻止， 这个时候你去打扰她会影响她的专注力 这还包括成年人，当今社会信息和诱惑都非常的多，人的想法也时时刻刻都在发生改变，生活的琐事也随着经历的增长而增长，专注于一件事情会越来越难。 在大部分企业办公,电子邮件是最大的干扰之一，如何有效控制电子邮件的使用，整合大量的碎片时间？ 关闭电子邮件通知功能人脑并不擅长并发处理，左右互搏不是人人都会的，一次性专注批量的处理事情会大大提高效率。特别是像我这种有强迫症的人，如果电子邮件弹框通知，我随时都会打开查看，如果电子邮件过多，整一天会让我不厌其烦。 需要关闭电子邮件通知，outlook options-&gt;mail-&gt;Message arrival,关闭桌面通知和声音提示。 定期批量的处理邮件每隔一个小时，或者一天4次，批量专注的处理你的邮件。 保持即时通信工具的畅通，然后定期的查看电子邮件，变相的告诉对方，如果有急事，可以通过即时工具联系，提高沟通效率。 处理邮件后将邮件归档归档阅读完一份邮件第一件事情 处理完毕后，将其归档 To do,设置标记后，将其归档 分类创建分类文件夹，如： 1234567events：公司的一些通告/事件等垃圾邮件 customer:领导，需求，VPM等 members：组内成员 projects:项目分类 todo:代办的事情，通常是客户/考勤异常/manpower等等 bug:issue追踪 RES:一些资源 创建规则，移动或阻止邮件,保持inbox内的邮件数量：右击邮件-&gt;Rules-&gt;移动到各个文件夹下。 其他设置拼音检查 Outlook settings-&gt;Mail-&gt;ABC 勾上拼音检查 设置回执功能(若对方是预览打开，则无回执) Outlook settings-&gt;Mail-&gt;ABC 勾上read receipt confirming 签名： Outlook settings-&gt;Mail-&gt; 创建签名，如： 1234Best Regards!姓名/公司/部门Office: 联系电话/短号其他联系工具]]></content>
      <categories>
        <category>开发者手册</category>
      </categories>
      <tags>
        <tag>时间管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery基础]]></title>
    <url>%2F2016%2F03%2F10%2Flearning-jquery-lesson%2F</url>
    <content type="text"><![CDATA[选择元素sample12345678910111213141516171819202122&lt;$(document).ready(function() &#123; $('#selected-plays &gt; li').addClass('horizontal'); // Find First top li elements ,add css horizontal $('#selected-plays li:not(.horizontal)').addClass('sub-level'); //Find all li elements without class horizontal $('a[href^="mailto:"]').addClass('mailto');//Find anchor element that href begin with "mailto" $('a[href$=".pdf"]').addClass('pdflink');//href end with ".pdf" $('a[href^="http"][href*="henry"]').addClass('henrylink');//href begin with "http" and has "henry" $('a').filter(function() &#123; //filter the hostname return this.hostname &amp;&amp; this.hostname != location.hostname; &#125;).addClass('external'); $('tr:nth-child(odd)').addClass('alt'); //select all odd child by current parent,start with 1. $('td:contains(Henry)') // Find every cell containing "Henry" .parent() // Select its parent .find('td:eq(1)') // Find the 2nd descendant cell .addClass('highlight') // Add the "highlight" class .end() // Return to the parent of the cell containing "Henry" .find('td:eq(2)') // Find the 3rd descendant cell .addClass('highlight'); // Add the "highlight" class &#125;); 给位于嵌套列表第二个层次的所有&lt;li&gt;元素添加special类；1234$(document).ready(function() &#123; $('#selected-plays li li').addClass('special'); &#125;); 给位于表格第三列的所有单元格添加year类；123$(document).ready(function() &#123; $('td:nth-child(3)').addClass("year") &#125;); 为表格中包含文本Tragedy的第一行添加special类；123$(document).ready(function() &#123; $('td:contains(Tragedy)').first().addClass('special'); &#125;); 选择包含链接（&lt;a&gt;）的所有列表项（&lt;li&gt;元素），为每个选中的列表项的同辈列表项元素添加afterlink类；123$(document).ready(function() &#123; &lt;span style="font-family: monospace; white-space: pre; background-color: rgb(240, 240, 240);"&gt;$('li a').parent().nextAll().addClass('afterlink')&lt;/span&gt;; &#125;); 为与.pdf链接最接近的祖先元素添加tragedy类123$(document).ready(function() &#123; $('a[href$=".pdf"]').closest('ul').addClass('Tragedy');; &#125;); 事件tips:事件冒泡 1.特定元素响应事件需要停止事件传播[.stopPropagation()]2.部分事件处理对象，如锚元素（），需要阻止默认操作[.preventDefault()]3.利用事件冒泡实现事件委托 分析和练习123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124$(document).ready(function() &#123; /*Enable hover effect on the style switcher*/ $('#switcher').hover(function() &#123; $(this).addClass('hover'); &#125;, function() &#123; $(this).removeClass('hover'); &#125;);//绑定悬停效果，在鼠标enters和leaves元素时启用对应样式 /*Allow the style switcher to expand and collapse.*/ var toggleSwitcher = function(event) &#123; if (!$(event.target).is('button')) &#123; $('#switcher button').toggleClass('hidden'); &#125; &#125;;//是否包含button标签，toggleClass根据类是否存在而添加或删除类 $('#switcher').on('click', toggleSwitcher);//注册click事件 /* Simulate a click so we start in a collaped state.*/ $('#switcher').click(); /* The setBodyClass() function changes the page style. The style switcher state is also updated.*/ var setBodyClass = function(className) &#123; $('body').removeClass().addClass(className); $('#switcher button').removeClass('selected'); $('#switcher-' + className).addClass('selected'); $('#switcher').off('click', toggleSwitcher); if (className == 'default') &#123; $('#switcher').on('click', toggleSwitcher); &#125; &#125;; /*begin with the switcher-default button "selected"*/ $('#switcher-default').addClass('selected'); /*Map key codes to their corresponding buttons to click*/ var triggers = &#123; D: 'default', N: 'narrow', L: 'large' &#125;; // Call setBodyClass() when a button is clicked. $('#switcher').click(function(event) &#123; if ($(event.target).is('button')) &#123; var bodyClass = event.target.id.split('-')[1]; setBodyClass(bodyClass); &#125; &#125;); // Call setBodyClass() when a key is pressed. $(document).keyup(function(event) &#123; var key = String.fromCharCode(event.which); if (key in triggers) &#123; setBodyClass(triggers[key]); &#125; &#125;); /*Enable hover effect on the style switcher*/ $('#header div').hover(function() &#123; $(this).addClass('hover'); &#125;, function() &#123; $(this).removeClass('hover'); &#125;); //(1) 在Charles Dickens被单击时，给它应用selected样式 $('#header div').click(function(event) &#123; $('#header div').removeClass().addClass('selected'); &#125;); //(2) 双击章标题（&lt;h3 class="chapter-title"&gt;）时，切换章文本的可见性 $('div.chapter').click(function(event) &#123; if ($(event.target).is('h3')) &#123; $(event.target).parent().find('p').toggleClass('hidden'); &#125; &#125;); //(3) 用户按下向右方向键时，切换到下一个body类 $(document).keyup(function(event) &#123; if (event.keyCode == 39) &#123; var curBodyClass=$('body').attr('class'); switch(curBodyClass) &#123; case 'default': setBodyClass('narrow'); break; case 'narrow': setBodyClass('large'); break; case 'large': setBodyClass('default'); break; default: setBodyClass('narrow'); break; &#125; &#125; &#125;); /*(4) 使用console.log()函数记录在段落中移动的鼠标的坐标位置。（注意：console.log() 可以在Firefox的firebug扩展、Safari的Web Inspector或Chrome、IE中的Developer Tools中使 用。*/ $('p').mousemove(function(e)&#123; console.log("mouseXY:"+ e.pageX+","+ e.pageY); &#125;); /*(5) 使用.mousedown()和.mouseup()跟踪页面中的鼠标事件。如果鼠标按键在按下 它的地方被释放，则为所有段落添加hidden类。如果是在按下它的地方之下被释放的， 删除所有段落的hidden类。*/ var mousedownY $(document).mousedown(function(e)&#123; mousedownY = e.pageY &#125;); $(document).mouseup(function(e)&#123; console.log("mousedownY:"+ mousedownY+","+ e.pageY); if (e.pageY == mousedownY)&#123; $('p').addClass('hidden'); &#125; else if (e.pageY &gt; mousedownY)&#123; $('p').removeClass('hidden') &#125; &#125;); &#125;); 样式和动画 1.position:relative; 相对定位，元素”相对于”它的原始起点进行移动。（相对定位时，无论是否进行移动，元素仍然占据原来的空间。因此，移动元素会导致它覆盖其他框）。2.position:absolute; 绝对定位，位置将依据浏览器左上角开始计算。3.父容器使用相对定位，子元素使用绝对定位后，子元素的位置相对于父容器左上角。4.相对定位和绝对定位需要配合top、right、bottom、left使用来定位具体位置。这四个属性同时只能使用相邻的两个，即上和下，左和右不能同时使用。 code view&amp;课后练习:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114$(document).ready(function() &#123; var $speech = $('div.speech'); var defaultSize = $speech.css('fontSize'); $('#switcher button').click(function() &#123; var num = parseFloat($speech.css('fontSize')); switch (this.id) &#123; case 'switcher-large': num *= 1.4; break; case 'switcher-small': num /= 1.4; break; default: num = parseFloat(defaultSize); &#125; $speech.animate(&#123;fontSize: num + 'px'&#125;, 'slow'); &#125;);//switch button function--larg/small speech var $firstPara = $('p').eq(1); $firstPara.hide(); $('a.more').click(function() &#123; $firstPara.animate(&#123; opacity: 'toggle', height: 'toggle' &#125;, 'slow'); var $link = $(this); if ($link.text() == 'read more') &#123; $link.text('read less'); &#125; else &#123; $link.text('read more'); &#125; return false; &#125;);//展开/隐藏，注意toggle的使用 $('div.label').click(function() &#123; var paraWidth = $('div.speech p').outerWidth(); var $switcher = $(this).parent(); var switcherWidth = $switcher.outerWidth(); $switcher .css(&#123;position: 'relative'&#125;) .fadeTo('fast', 0.5) .animate(&#123; left: paraWidth - switcherWidth &#125;, &#123; duration: 'slow', queue: false &#125;) .fadeTo('slow', 1.0) .slideUp('slow', function() &#123; $switcher.css(&#123;backgroundColor: '#f00'&#125;); &#125;) .slideDown('slow'); &#125;);//多效果并行和队列 $('p').eq(2) .css('border', '1px solid #333') .click(function() &#123; var $clickedItem = $(this); $clickedItem.next().slideDown('slow', function() &#123; $clickedItem.slideUp('slow'); &#125;); &#125;);//回调机制，实现队列效果 $('p').eq(3).css('backgroundColor', '#ccc').hide(); /*1) 修改样式表，一开始先隐藏页面内容，当页面加载后，慢慢地淡入内容*/ $('#container').hide(); $('#container').fadeIn("slow"); /*(2) 在鼠标悬停到段落上面时，给段落应用黄色背景*/ var rgb = $('p').css('backgroundColor'); $('p').hover(function() &#123; $(this).css(&#123;backgroundColor:'#FFFF00'&#125;); &#125;,function()&#123; $(this).css(&#123;backgroundColor:rgb&#125;) &#125;); /*(3)单击标题（&lt;h2&gt;）使其不透明度变为25%，同时添加20px的左外边距，当这两个效果完 成后，把讲话文本变成50%的不透明度；*/ $('h2').click(function() &#123; $(this) .animate(&#123; opacity:0.25, marginLeft: "20px" //左外距 &#125;); $('div.speech p').fadeTo('slow',0.5); &#125;); /*(4)按下方向键时，使样式转换器向相应的方向平滑移动20像素*/ $(document).keyup(function(event) &#123; $('#switcher').css(&#123;position:'relative'&#125;); $switcher = $('#switcher') switch (event.keyCode)&#123; case 37: $switcher.animate(&#123; left:"-=20px" &#125;); break; case 38: $switcher.animate(&#123; top:"-=20px" &#125;); break; case 39: $switcher.animate(&#123; left:"+=20px" &#125;); break; case 40: $switcher.animate(&#123; top:"+=20px" &#125;); break; default: break; &#125; &#125;); &#125;); DOM操作 code view和练习：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970$(document).ready(function () &#123; // Use attr() to add an id, rel, and title. $('div.chapter a[href*="wikipedia"]').attr(&#123; rel : 'external', title : function () &#123; return 'Learn more about ' + $(this).text() + ' at Wikipedia.'; &#125;, id : function (index, oldValue) &#123; return 'wikilink-' + index; &#125; &#125;); // Add "back to top" links. //(1) 修改添加back to top链接的代码，以便这些链接只从第四段后面才开始出现 $('&lt;a href="#top"&gt;back to top&lt;/a&gt;').insertAfter('div.chapter p:gt(2)'); $('&lt;a id="top"&gt;&lt;/a&gt;').prependTo('body'); //(2) 在单击back to top链接时，为每个链接后面添加一个新段落，其中包含You were here字样。确保链接仍然有效。 $('.chapter a[href*="top"]').click(function () &#123; $('&lt;p&gt;you were here&lt;/p&gt;').insertAfter($(this)); &#125;); //(3) 在单击作者名字时，把文本改为粗体（通过添加一个标签，而不是操作类或CSS属性）。 //(4) 在随后单击粗体作者名字时，删除之前添加的&lt;b&gt;元素（也就是在粗体文本与正常文本之间切换）。 $('#f-author').click(function () &#123; if ($(this).parent().is('b')) &#123; $(this).unwrap('111'); &#125; else &#123; $(this).wrap('&lt;b&gt;&lt;/b&gt;'); &#125; &#125;); //(5) 为正文中的每个段落添加一个inhabitants类，但不能调用.addClass()方法。确保不影响现有的类。 $('div.chapter p').wrapInner('&lt;div class="inhabitants"&gt;&lt;/div&gt;'); // Create footnotes. var $notes = $('&lt;ol id="notes"&gt;&lt;/ol&gt;').insertBefore('#footer'); //fooer之前创建插入有序列表 $('span.footnote').each(function (index) &#123; //遍历脚注，使用each的回调函数处理 $(this) .before([ '&lt;a href="#footnote-', index + 1, '" id="context-', index + 1, '" class="context"&gt;', '&lt;sup&gt;', index + 1, '&lt;/sup&gt;&lt;/a&gt;' ].join('')) //创建了一个包含指向脚注的链接和脚注编号的&lt;sup&gt;元素，insertBefore反向插入正文， .appendTo($notes) //将footnote加入到脚注 .append([ ' (&lt;a href="#context-', index + 1, '"&gt;context&lt;/a&gt;)' ].join('')) //创建指向上文脚注标签 .wrap('&lt;li id="footnote-' + (index + 1) + '"&gt;&lt;/li&gt;'); //warp 将匹配元素包裹在元素或内容中 &#125;); // Style pull quotes. $('span.pull-quote').each(function (index) &#123; var $parentParagraph = $(this).parent('p'); $parentParagraph.css('position', 'relative'); //设置css样式相对定位 var $clonedCopy = $(this).clone(); //复制 $clonedCopy .addClass('pulled') .find('span.drop') .html('…') //修改 .end() .text($clonedCopy.text()) //将text内容存文本化 .prependTo($parentParagraph); &#125;); &#125;); AJAX code view和练习123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195$(document).ready(function () &#123; $('#letter-a a').click(function (event) &#123; event.preventDefault(); $.ajaxSetup(&#123; url : 'a.html', type : 'POST', dataType : 'html' &#125;); $.ajax(&#123; type : 'GET', success : function (data) &#123; $('#dictionary').html(data); &#125; &#125;); &#125;); $('#letter-b a').click(function (event) &#123; event.preventDefault(); $.getJSON('b.json', function (data) &#123; var html = ''; $.each(data, function (entryIndex, entry) &#123; html += '&lt;div class="entry"&gt;'; html += '&lt;h3 class="term"&gt;' + entry.term + '&lt;/h3&gt;'; html += '&lt;div class="part"&gt;' + entry.part + '&lt;/div&gt;'; html += '&lt;div class="definition"&gt;'; html += entry.definition; if (entry.quote) &#123; html += '&lt;div class="quote"&gt;'; $.each(entry.quote, function (lineIndex, line) &#123; html += '&lt;div class="quote-line"&gt;' + line + '&lt;/div&gt;'; &#125;); if (entry.author) &#123; html += '&lt;div class="quote-author"&gt;' + entry.author + '&lt;/div&gt;'; &#125; html += '&lt;/div&gt;'; &#125; html += '&lt;/div&gt;'; html += '&lt;/div&gt;'; &#125;); $('#dictionary').html(html); &#125;); &#125;); $('#letter-c a').click(function (event) &#123; event.preventDefault(); $.getScript('c.js'); &#125;); $('#letter-d a').click(function (event) &#123; event.preventDefault(); $.get('d.xml', function (data) &#123; $('#dictionary').empty(); $(data).find('entry').each(function () &#123; var $entry = $(this); var html = '&lt;div class="entry"&gt;'; html += '&lt;h3 class="term"&gt;' + $entry.attr('term'); html += '&lt;/h3&gt;'; html += '&lt;div class="part"&gt;' + $entry.attr('part'); html += '&lt;/div&gt;'; html += '&lt;div class="definition"&gt;'; html += $entry.find('definition').text(); var $quote = $entry.find('quote'); if ($quote.length) &#123; html += '&lt;div class="quote"&gt;'; $quote.find('line').each(function () &#123; html += '&lt;div class="quote-line"&gt;'; html += $(this).text() + '&lt;/div&gt;'; &#125;); if ($quote.attr('author')) &#123; html += '&lt;div class="quote-author"&gt;'; html += $quote.attr('author') + '&lt;/div&gt;'; &#125; html += '&lt;/div&gt;'; &#125; html += '&lt;/div&gt;'; html += '&lt;/div&gt;'; $('#dictionary').append($(html)); &#125;); &#125;); &#125;); $('#letter-e a').click(function (event) &#123; event.preventDefault(); var requestData = &#123; term : $(this).text() &#125;; $.get('e.php', requestData, function (data) &#123; $('#dictionary').html(data); &#125;).fail(function (jqXHR) &#123; $('#dictionary') .html('Sorry, but an error occurred: ' + jqXHR.status) .append(jqXHR.responseText); &#125;); &#125;); $('#letter-f form').submit(function (event) &#123; event.preventDefault(); var formValues = $(this).serialize(); $.get('f.php', formValues, function (data) &#123; $('#dictionary').html(data); &#125;); &#125;); var url = 'http://examples.learningjquery.com/jsonp/g.php'; $('#letter-g a').click(function (event) &#123; event.preventDefault(); $.getJSON(url + '?callback=?', function (data) &#123; var html = ''; $.each(data, function (entryIndex, entry) &#123; html += '&lt;div class="entry"&gt;'; html += '&lt;h3 class="term"&gt;' + entry.term + '&lt;/h3&gt;'; html += '&lt;div class="part"&gt;' + entry.part + '&lt;/div&gt;'; html += '&lt;div class="definition"&gt;'; html += entry.definition; if (entry.quote) &#123; html += '&lt;div class="quote"&gt;'; $.each(entry.quote, function (lineIndex, line) &#123; html += '&lt;div class="quote-line"&gt;' + line + '&lt;/div&gt;'; &#125;); if (entry.author) &#123; html += '&lt;div class="quote-author"&gt;' + entry.author + '&lt;/div&gt;'; &#125; html += '&lt;/div&gt;'; &#125; html += '&lt;/div&gt;'; html += '&lt;/div&gt;'; &#125;); $('#dictionary').html(html); &#125;); &#125;); $('#letter-h a').click(function (event) &#123; event.preventDefault(); $('#dictionary').load('h.html .entry'); &#125;); var $loading = $('&lt;div id="loading"&gt;Loading...&lt;/div&gt;') .insertBefore('#dictionary'); $(document).ajaxStart(function () &#123; $loading.show(); &#125;).ajaxStop(function () &#123; $loading.hide(); &#125;); $('body').on('click', 'h3.term', function () &#123; $(this).siblings('.definition').slideToggle(); &#125;); //(1) 页面加载后，把exercises-content.html的主体（body）内容提取到页面的内容区域 $('#dictionary').load('exercises-content.html'); //(2)请为左侧的字母列表创建“提示条”，当用户鼠标放到字母上时，从exercises-content.html中加载与该字母有关的内容。 //(3) 为页面加载添加错误处理功能，在页面的内容区显示错误消息。修改脚本，请求does-notexist.html而不是exercises-content.html，以测试错误处理功能。 $('.letter').mouseenter(function (e) &#123; e.preventDefault(); $('#dictionary').load('exercises-content.html #' + this.id, function (response, status, jqXHR) &#123; if (status == 'error') &#123; $('#dictionary') .html('An error occurred: ' + jqXHR.status) .append(jqXHR.responseText); &#125; &#125;); &#125;).mouseleave(function () &#123; $('#dictionary').html(''); &#125;); /* $('.letter').mouseenter(function (e) &#123; $('#dictionary') .load('does-not-exist.html #' + this.id); &#125;) .fail(function (jqXHR) &#123; $('#dictionary') .html('sorry An error occurred: ' + jqXHR.status) .append(jqXHR.responseText); &#125;) */ /*(4) 页面加载后，向GitHub发送一个JSONP请求，取得某个用户代码库的列表。把每 个代码库的名称和URL插入到页面的内容区。取得jQuery项目代码库的URL是https://api. github.com/users/jquery/repos。 githubUrl = 'https://api.github.com/users/jquery/repos' $.getJSON(githubUrl + '?callback=?', function (data) &#123; var html = ''; $.each(data, function (entryIndex, entry) &#123; $.each(entry, function (itemIndex, item) &#123; html += '&lt;div class="entry"&gt;'; html += '&lt;div class="name"&gt;' + item.name + '&lt;/div&gt;'; &#125; &#125;); &#125;); */ &#125;);]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[人月神话]]></title>
    <url>%2F2016%2F03%2F06%2Fthe-mythical-man-month%2F</url>
    <content type="text"><![CDATA[编程行业满足我们内心深处的创造渴望和愉悦 编程乐趣 创建事物的快乐 开发他人有用的东西的快乐 组装的快乐 面对不重复的任务，不断学习的快乐 工作在具体物质介质上的快乐 编程的苦恼 追求完美，然而却无法完美 良好的烹饪需要时间，某些任务无法在不损坏结果的情况下加快速度 编程人员都比较乐观，‘一切都会好起来’，所以职责需要分开 bug是避免不了的 工作量和项目进度无法太清晰 沟通成本是经常被忽略的东西 1/3计划，1/6编码，1/4构建测试，1/4集成测试 软件开发没有银弹，过于复杂无法数据估计 码农何去何从？]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>项目管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu的爱]]></title>
    <url>%2F2016%2F03%2F06%2Fubuntu_env%2F</url>
    <content type="text"><![CDATA[今年听闻ubuntu要发布16 LTS，于是win10弃坑，兜兜转转还是再次用回了自由的ubuntu系统，环境记录下。几个ide在ubuntu依然是不尽人意的，要解放鼠标还是得定制，得折腾，最终还不如使用mac或者emacs/vim等。 基础设置设置快捷键 System Settings -&gt; Keyboard -&gt; Shortcuts -&gt; Launcher -&gt; Launcher terminal，设成Super(Win) + R. 设置字体 System Settings——》Universal Access——》Large Text——》on 输入法方式1. 自带的ibus中文输入不是很好用，使用搜狗输入法：http://pinyin.sogou.com/linux/在Language Support将输入法系统切换到fcitx，在text entry中隐藏掉ibus界面。 方式2. emacs /etc/apt/sources.list.d/ubuntukylin.list文件，加入ubuntu kylin的apt源 123deb http://archive.ubuntukylin.com:10006/ubuntukylin trusty mainsudo apt-get updatesudo apt-get install sogoupinyin 浏览器wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb 安装迅雷：XwareDesktop 压缩工具sudo apt-get install unrar 安装jdk1234sudo add-apt-repository ppa:webupd8team/javasudo apt-get update sudo apt-get install oracle-java8-installersudo update-alternatives --config java 安装CMakersudo apt-get install cmake qtcreator pythonalternatives机制实现python2和pyhton3的共享和切换 123sudo apt-get install python3-pipsudo update-alternatives --install /usr/bin/python python /usr/bin/python2 100sudo update-alternatives --install /usr/bin/python python /usr/bin/python3 150 默认使用python3可能会导致ubuntu软件中心异常，此时需要切换到python2. 其他ruby etc. 1234sudo apt-get install ruby rakegem sources --remove https://rubygems.org/gem sources -a http://ruby.taobao.org/gem install jekyll rdiscount IDE现在编译器之多，眼花缭乱，曾几何时一直都是捧着source insight，一做就是6年，呜呼哀哉. emacssudo apt-get install emacs24配置 sublime text涉猎的语言太多(c/c++/java/python/php/ruby/javascript/c#/swift/lisp etc.)，实施的机会又越来越少.痛定思痛，决定梳理专精一门。 安装123sudo add-apt-repository ppa:webupd8team/sublime-text-3 sudo apt-get update sudo apt-get install sublime-text 配置 package control.安装包管理器，view-&gt;show console执行以下代码. 1import urllib2,os;pf='Package Control.sublime-package';ipp=sublime.installed_packages_path();os.makedirs(ipp) if not os.path.exists(ipp) else None;open(os.path.join(ipp,pf),'wb').write(urllib2.urlopen('http://sublime.wbond.net/'+pf.replace(' ','%20')).read()) 以下的插件均用ctrl+shift+p安装。 SublimeREPL SideBarEnhancements 扩展了侧边栏中菜单选项的数量，从而提升你的工作效率 Anaconda Anaconda 是一个终极 Python 插件。它为 ST3 增添了多项 IDE 类似的功能，例如： Autocompletion 自动完成，该选项默认开启，同时提供多种配置选项。Code linting 使用支持 pep8 标准的 PyLint 或者 PyFlakes。因为我个人使用的是另外的 linting 工具，所以我会在 Anaconda 的配置文件 Anaconda.sublime-settings 中将 linting 完全禁用。操作如下: Sublime &gt; Preferences &gt; Package Settings &gt; Anaconda &gt; Settings – User： {“anaconda_linting”: false} McCabe code complexity checker 让你可以在特定的文件中使用 软件复杂度检查. Goto Definitions 能够在你的整个工程中查找并且显示任意一个变量，函数，或者类的定义。 Find Usage 能够快速的查找某个变量，函数或者类在某个特定文件中的什么地方被使用了。 Show Documentation： 能够显示一个函数或者类的说明性字符串 Djaneiro Django. SublimeLinter 代码静态检查工具框架(linter),对于 Python 的代码静态检查器，我使用 SublimeLinter-pep8。其他还有SublimeLinter-jshint, SublimeLinter-pyyaml, SublimeLinter-csslint，SublimeLinter-html-tidy，以及 SublimeLinter-json。 PEP8 Autoformat 按PEP8自动格式化代码的。快捷键 CTRL+SHIFT+R 自动格式化python代码.常用配置 1234567891011121314151617&#123; &quot;auto_complete&quot;: false, &quot;caret_style&quot;: &quot;solid&quot;, &quot;ensure_newline_at_eof_on_save&quot;: true, &quot;find_selected_text&quot;: true, &quot;font_size&quot;: 11.0, &quot;highlight_modified_tabs&quot;: true, &quot;line_padding_bottom&quot;: 0, &quot;line_padding_top&quot;: 0, &quot;scroll_past_end&quot;: false, &quot;show_minimap&quot;: false, &quot;tab_size&quot;: 4, &quot;translate_tabs_to_spaces&quot;: true, &quot;trim_trailing_white_space_on_save&quot;: true, &quot;wide_caret&quot;: true, &quot;word_wrap&quot;: true,&#125; GitGutter Emmet 大名鼎鼎的Emmet Markdown Preview markdown 预览 atom下载, github血统，偶尔用来写markdown(shift + ctrl + m) pycharm下载，python全栈ide.注册时选择 License server, 填写http://idea.lanyus.com]]></content>
      <categories>
        <category>开发者手册</category>
      </categories>
      <tags>
        <tag>UBuntu</tag>
        <tag>开发环境</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[国家为什么会失败]]></title>
    <url>%2F2016%2F03%2F04%2Fwhy_nations_fail%2F</url>
    <content type="text"><![CDATA[该书列举了几个实例，反驳了国家为什么会失败的几个假说，通过对历史的层层剖析，道出了自己的命题：制度是国家为什么会失败的主要原因。 假说地理假说 目前比较贫穷的国家集中在非洲，然而根据历史表明，这些地区的国家也曾富裕过，气候并不是决定国家失败的原因。 热带疾病是造成许多非常人饱受病痛之苦，但它们不是非洲贫穷的原因，而是贫穷的结果。 动物和植物物种可能性的差异制造了农业发展程度的差异，导致不同大陆间的技术发展与富裕程 文化血统假说 宗教改革和信仰，价值和伦理是驱动国家贫富的关键。 优秀的欧洲文化传承也许就是富裕的根源。然则，无法解释阿根廷和乌拉圭欧裔很多但依然不富裕的事实。 北纬38°假说北韩和南韩差距巨大，从文化，地理，无知角度都无法解释，我们必须从制度上去寻求答案。 制度经济制度广纳式需要安全的财产权和经济机会，不只是给菁英，也要开放给社会的各领域。 榨取式这类制度的设计是为了向社会的一部分人榨取收入和财富，以使另一部分人获利。榨取式经济制度发展受限原因： 缺乏创造性破坏和创新 不只制造出更低的效率，还往往反转既有的政治集权，有时候甚至导致治安完全崩溃而陷于混乱 罗马帝国衰亡：从共和到元首制，及至后来到帝国的转变，原本具有部分广纳性的政治制度曾是经济成功的基石，播下了衰亡的种子。 政治制度经济制度对决定国家的贫穷或富裕极其重要，而决定国家经济制度的是政治和政治制度。 足够集中化和多元化的政治制度称为广纳式政治制度.如果这两种条件有任何一种付之阙如，我们会把这套制度称为榨取式政治制度。 容许自由的媒体繁荣发展，但回过头来，自由的媒体也比较能够让有害于广纳式制度的威胁曝光并广为人知，促使社会对之采取抗拒行动。相对地，在榨取式政治制度、专制政权或独裁统治下，这类的自由根本就不可能，因为它们动辄压制反对力量的形成。 广纳式经济制度强化财产权，打造公平的游戏平台，鼓励新科技与新技术的投资，助长经济成长，不像榨取式经济制度则是少数人榨取多数人资源的体系，既无法保障财产权，也不为经济活动提供诱因。 广纳式经济制度与广纳式政治制度互相支持。 在政治权力分配上， 广纳式政治制度倾向于多元，且能达到某种程度的政治集权，并以此建立法治，为财产权及广纳式市场经济奠定基础。同样的，榨取式经济制度与榨取式政治制度也是互相支援。在权力分配上，榨取式政治制度将权力集中于少数人手中，这些人因此有动机为谋取私利维持和发展榨取式经济制度，并运用所得的资源巩固自己的政治权力 “要维持党在改革中的领导地位，有三个原则必须把握：党要控制军队；党要控制党员；党要控制新闻。”]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>博闻</tag>
        <tag>国家</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[创业维艰]]></title>
    <url>%2F2016%2F02%2F24%2Fthe_hard_thing_about_hard_things%2F</url>
    <content type="text"><![CDATA[此书使我对CEO的角色有了更深入的了解，多年从事技术领域，所接触的问题都比较单纯，而CEO要面临的问题和挑战，更艰难和复杂得多。此书也使我对创业有了初步的认识：苦逼，挑战，挣扎，life is struggle。 以下是本书的笔记，纪录的非常片面，还是自己去看书吧。 挣扎之苦 不要扛下所有的责任。适当的放权，责任下放，可以提高参与感，提高团队的凝聚力。 只要坚持下去，总有转机。 不要过分苛责自己。正确评估自己，过分苛责自己于事无补。 要实话实说，对公司出现的问题做透明化处理很重要，涉及到以下三点原因。 信任。没有了信任，沟通就断了 参与解决问题的人越多越好。 健康的企业文化就像过去的路由信息协议：好事不出门，坏事传千里 人人都是产品经理 产品经理及其了解市场，产品，生产线和竞争情况，凭借自己丰富的经验和充分的自信开展工作 对目标有清晰的定义，即“目标是什么”，并能有效实施这一目标。 好：重要问题以书面形式记录下来（竞争中的良策，艰难的架构选择，艰难的产品决策，攻占或放弃的市场） 差：以口头形式表达自己的意见，抱怨“当权者”不允许他这样做。 好的产品经理考虑向市场推出超值产品，在产品进入市场期间，他们会考虑实现市场占有率和收益目标。 人才是重中之重，招聘是人才的第一步，有几个面试题可以参考： 你上班的第一个月会干什么？ 你觉得这份工作和你目前工作有什么不同？ 你为什么要加入我们小公司？ 债务管理债务： 一山藏二虎。 可能会存在多头管理 两人背负责任等于是卸掉了虎责任 因某一员工得到另一工作机会而对其补偿过度。 缺乏绩效管理机制或员工反馈机制。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>管理</tag>
        <tag>创业</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Data Crush]]></title>
    <url>%2F2016%2F02%2F15%2Fdata_crush%2F</url>
    <content type="text"><![CDATA[Data Crush: How the Information Tidal Wave is Driv看完后收获不少 大数据在推动在线数据的增长： 移动性：智能手机和平板电脑会随时随地将人们联系在一起； 虚拟生活：人们会通过互联网加强与朋友和家人之间的互动； 数字商业：购买在线产品和服务的无线选择 在线娱乐：数亿个娱乐渠道和数白万个游戏供选择和娱乐 云计算：将你所有的信息在线化 大数据：在线活动产生的大量数据 商业领导人需要遵循的六大原则： 让一切移动起来：重新定义流程和自动化，充分利用移动和流动劳动力 流程数字化：推行无纸化办公，让流程自动化 业务社交化：推行社交技术和业务流程整合在一起 信息管理自动化：重视自动化管理和运作 挖掘大内容：挖掘大量非结构化的数据，产生新的商业价值 云技术：拆分整体企业运营为单个小型应用 场景化成熟度模型： 0级—没有场景化，匿名交易了，现金支付。企业不知道消费者的具体信息。 1级—消费者使用卡（信用卡，借记卡，会员卡）支付。企业可以了解消费者的场景，不过通常是在对方购买商品之后。 2级—企业有了场景化意识。企业知道消费者在什么时候出现在什么地方，企业能掌握时间和地点数据，这些数据对零售区位的选择非常重要。 3级—企业有了消费者场景模式，能根据消费者的行为进行预测 4级—企业对消费者的习惯有了足够的了解，能根据其社交化媒体数据预测其生活 5级—企业和消费者形成良好的关系，消费者持续购买企业产品，企业和消费者在社交上先行并对消费者造成一定的影响。 社会化成熟度模型： 0级—一无所知 1级—企业可以通过消费者使用会员卡和信用卡的情况，以及消费者在社交网站上为企业点赞等行为记录下他的习惯和喜好。 2级—企业能够对消费者的行为做回应。如企业搜索社交网站上对企业的评价并做出回应。 3级—企业开始主动和消费者建立联系。企业定向追踪消费者在社交化媒体上的行为，形成对消费者的喜好和观点的了解，然后定向推送营销信息，重塑消费者的评价，维护企业和产品的形象。 4级—企业根据消费者的社交化信息进行预见性的营销。 5级—企业和消费者交互增加，创造一种和消费者的共生关系，持续维护和提高企业的品牌知名度和忠诚度。 量化成熟度模型：量化成熟度可以用来判断企业的商业流程结构是否良好，以及是否能够被消费者理解，企业也可以此来判断业务是否适合外包。 应用化成熟度模型： 0级—没有APP. 1级—信息推送。 2级—内容定位，用户定制和选择。 3级—用户参与商业流程，互动更全面。 4级—场景化意识。 5级—既有社交意识，又能根据用户的喜好，人际关系和其他社交标准来运作。 大数据和物联网一样不是一蹴而就，它必然需要经历一个大集成的过程，会有各方利益间的博弈，但相信它就在不远将来。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>大数据</tag>
        <tag>新知</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[决战大数据]]></title>
    <url>%2F2016%2F02%2F15%2Fbig_data%2F</url>
    <content type="text"><![CDATA[多算胜，少算不胜，而况于无算乎迂回前进，在运营数据中衡量每一个变动，并通过变动的结论来调整自己的下一个迂回动作。 人人都是数据分析师做好个人的大数据管理： 从小处着眼积累知识 对知识进行标签化管理 让数据的收集变得简单，即时收集。 建立用户的标签：简单的说就是通过数据的分析来对用户的偏好进行描述 建立标签 通过业务规则结合数据分析来建立标签： 通过模型来建立标签。 多个模型组合建立标签。 标签的应用 标签的使用，最核心的是数据中间层和前台业务层的对接： 中间层和业务层的对接。 中间层的易用性。 如何用框架来做决策：数据抽空场景没有任何的意义，数据分析需要和具体场景相结合。 首先确定有什么问题，从解决问题的角度去收集数据，挖掘数据。 把收集到的数据整理好，放入“数据框架”（场景）内,清楚的看到数据与决策之间的关系。 看框架与做决策的关系 数据分类的4大维度 数据再生角度，分为可再生和不可再生数据 按照数据所处的存储层次来看，可分为基础层，中间层和应用层。 按照数据业务归属来看，可以分为各个数据主体（数据仓库）。 按照是否隐私来区分，可以分为隐私数据和非隐私数据。 数据的5大价值能辨别关系，身份的数据是最重要的。在大数据时代，越能够还原用户真是身份和真是行为的数据就越能够让企业在大数据竞争中保持战略优势。 识别与串联价值，唯一能够锁定你目标的数据。 描述价值。 时间价值。 预测价值。 产生数据的价值。 tips 针对性：收集数据要有针对性，最终要为解决某个问题而服务，盲目的收集数据并没有什么用。 养数据：养数据是一种数据战略，是基于深入业务理解的更高层次的商业决策。数据具有成长性，要避免刻舟求剑的场景。 场景与还原并行:前端还原消费者场景，后端还原业务需求 关联性：一个单独的数据是没有意义的，要把数据放在“数据框架”中让数据场景化，才能看出存在的问题，进入做出决策。 存：收集数据不是目的，让收集起来的数据如何产生价值才是最终的目的；管：用数据产品来解决获取及使用数据的问题；用：诗句的分裂和重组，都能做到颠覆性创新； 电商行业成交额指标： 日均UV,浏览转化率（UV到达商品详细页面的转化率），购买转化率（到达商品详细页面的用户到购买商品的页面），比单价（平均每一笔的金额），人均笔数]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>大数据</tag>
        <tag>新知</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[禅]]></title>
    <url>%2F2016%2F01%2F05%2Fchan%2F</url>
    <content type="text"><![CDATA[当你忘了自己的过去，满意自己的现在，漠视自己的未来，你就站在了生活的最高处 有的人一生也无法到达那个高度。生活与人，不同的人有不同的感悟，相同的人不在不同的阶段也有不同的看法。别人的经验是学不来的，一个人的一生不是规划出来的，生活也不是从别人的故事里讲出来的。 心 竹密岂妨流水过，山高哪阻野云飞 禅者因解脱而自在，而豁达，而空灵，我自认是达不到的，但我可以从认识自我做起，完成几个目标，坚持写几篇博客。 给自己建立一个档案。如blog/个人站，便于更好的认识和总结自己，也有利于技能和经验的积累 登高必自卑，行远必自迩。 列一个目标清单。凡是皆是一步一步完成的,制定大目标,大目标引领自己,将大目标分解为小目标,小目标激励自己 执行 睡觉的时候睡觉，吃饭的时候吃饭. 少说多做，宁要一个开始，也不要千万个梦想，想中彩票得先买一注彩票,如何提高执行力？ 推迟满足感写完作业再玩 自我奖励和激励适当的自我奖励 自律睡觉的时候睡觉，吃饭的时候吃饭 专注 外离相为禅，内不乱为定。外若着相，内心即乱；外若离相，心即不乱。 修行禅定的能力，处在任何时间不被外事干扰。认真做一件事情，不打妄想，扔掉手机，关掉网络，一次专注做一件事情。 宁要一个完成，不要千万个开始: 人脑擅长单线程处理，一次专注于一件事的效率和成功率都会比较高 开始一个新的目标其实不会对你造成什么改变，但是完成一个目标可以 耐心 竹影扫阶尘不动，月底潭底水无痕 离开上家公司的时候我觉得选择很重要，离开后我觉得耐心也很重要。人总是要入一些围城，然后夸大自己了解事物的缺点，放大自己不了解事物的优点，从而带给自己一些期待。 其实是自己还不够豁达，眼睛容不得异物，好比人与人相处，需要缩小自己，开阔胸怀，让自己可以走进别人的心里，而不会刺伤人。 分享 布道 分享的意义 我们为什么要分享？分享的意义是什么？ 分享能够收获友谊，快乐和尊重 分享能提高和完善自己 鞭挞自己去不断的学习 一个饥饿的乞丐是没有资格付出的]]></content>
      <categories>
        <category>散文</category>
      </categories>
      <tags>
        <tag>禅</tag>
        <tag>精进</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2016年书单]]></title>
    <url>%2F2016%2F01%2F05%2Fbook-list%2F</url>
    <content type="text"><![CDATA[罗列了下今年的书单，部分是家里的藏书，虽喜欢纸质书，但有时翻看确实不如电子书方便。 kindle paperwhite2已被老婆占用了，没想到她看书的兴致也挺高毕竟影视作品是无法替代文字的魅力的。于是又入了个paperwhite3，希望新的一年多抽出时间来看书。 今年对历史和人文比较感兴趣，由于工作需要，仍然需要关注下互联网方面的书籍，参杂一些推理小说和时下的畅销书就当调剂下。书评我是不愿多写的，也可尝试下。 人性中的善良天使一部人类心理进化史，开创性地运用了最前沿的心智理论研究人类历史，以震撼人心的方式剖析促发暴力的人类心理的内外因素。本书的结论必然会引起争论，但这只是一个开端，它将引导我们用全新的角度看人性、看历史、看世界，让我们深思人类社会的未来命运。 国家为什么会失败 为什么有的国家富裕，有的却贫穷？本书用15年的原创性研究，阐释一个跟现代社会高度相关的新政治经济学理论，直面这个旷世难题。 通读了下略有感触,必然会再去读第二遍。 罗马帝国衰亡史 此书太厚，不一定能看完 乌合之众 之前看过几本心理学类的著作，如自私的基因等，也许是自己功力不够并未引起多少共鸣。此本书也看完了，还是感觉学术性稍重了些，论证过少，但还算简洁，对群体有很好的概括，有几个观点显得比较极端，不过个人比较认同： 任何一个人都比“人民群众”更聪明，所以“人民群众”是靠不住的。 任何一个群体更像是一个原始人的乌合之众！ 妇孺言论不可轻信。 群体杜撰历史。 群体的叠加只能增加愚蠢，不存在丝毫智力优势。 群体埋葬了所有的怀疑精神与独立意识，他们只臣服于激烈的言辞，虚假的形象。 群体没有推理能力，只会喊口号以号召起头脑风暴。 偶像崇拜不会消亡，因为群体需要宗教。 任何一桩惨案，总是群众所为。 UNIX编程艺术 KISS的精髓:keep it simple and stupid.不管是编码，设计，还是生活上都应该有这种思想。 Unix系统领域中的设计和开发哲学、思想文化体系、原则与经验，由公认的Unix编程大师、开源运动领袖人物之一Eric S. Raymond倾力多年写作而成。包括Unix设计者在内的多位领域专家也为本书贡献了宝贵的内容。本书内容涉及社群文化、软件开发设计与实现，覆盖面广、内容深邃，完全展现了作者极其深厚的经验积累和领域智慧。 硅谷之谜 看完吴军的浪潮之巅，对我这种刚开始弄潮的人来说有较大的启发。 失控 谷歌是如何运营的 家里有本英文版的纸质书，一直垫在床头未曾翻看，现在中文版也出来了，惭愧惭愧。 已读, 我认为,谷歌之所以能不断的聚集精英为其服务,可以实行扁平化管理,需要企业文化的支撑,也是以太效应的作用结果,不是什么企业都可以模仿的. 创业维坚 笔记在此 S 统计数字会撒谎 通熟易懂,幽默风趣,实例也比较多,推荐一读.笔记在此 Data Crush: How the Information Tidal Wave is Driv 看完后收获不少Data Crush读书笔记 决战大数据 多算胜，少算不胜，而况于无算乎 决战大数据读书笔记]]></content>
      <categories>
        <category>书单</category>
      </categories>
      <tags>
        <tag>2016书单</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[站在秋末冬至的隘口]]></title>
    <url>%2F2011%2F12%2F08%2Fstand-by-the-first-winner%2F</url>
    <content type="text"><![CDATA[站在秋末冬至的隘口 你轻轻的挥手 落叶纷飞在你的额头 落在我的心头 你微微一笑 酿成五十度的酒 一枚叶子的翠绿 绽放在冬天的枝头 你微笑的挥手 我醉在秋末冬至的隘口]]></content>
      <categories>
        <category>诗歌</category>
      </categories>
      <tags>
        <tag>秋末冬至</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阴雨.碎季.杂念]]></title>
    <url>%2F2009%2F11%2F18%2Fmy-essays-on%2F</url>
    <content type="text"><![CDATA[题记不经意看到了以前空间里的文章. 回看自己十年,真是幼稚可笑而可爱. 一也不知道什么时候开始,四季不再分明.想起姥姥屋后那一片池塘,还剩下最后一只落单的候鸟,在这样的天气在如此模糊的视野,能否再飞起来,飞向那潮湿苍白而压抑的天空. 我们和它们一样,就是这么挣扎在这个破碎的季节里的角角落落. 它们又和我们不一样,因为它们的目的更加单纯. 二2009年11月18日,有雨,1-3摄氏度. 杭城还是阴雨一阵,连绵不断的雨,把整个天空洗刷的阴郁而苍凉,而我也从未如此期盼过阳光. 从窗里望着窗外,在这个冷漠的城市里依旧车来车往,想起我那同名异姓的同事,70码,永远躺在那几条雪白的斑马线上. 举起咖啡,咖啡是叫女人从网上买的 &lt;铭咖啡&gt; 超市里是找不到的,大学时代偶尔在超市里买到过,一直念念不忘,味香苦涩而浓郁,不像其他那些袋装速溶咖啡:谈妆浓抹. 三这几天工作还算轻松,听到小潘空间里那首熟悉的歌,&lt;那些花儿&gt;,突然很有感触. &gt;那片笑声让我想起我的那些花儿在我生命每个角落静静为我开着我曾以为我会永远守在他身旁今天我们已经离去在人海茫茫 而我记忆里的那些花儿，也悄悄盛开在那逝去的年华里… 田地,青蛙,田鼠,湿了鞋子 养蚕,烤知了,打弹珠 和龟娃在大学美食城一盘炒面四瓶啤酒 记忆里非典人心惶惶，而我唯恐天下不乱的心情 记忆里在那二娘水饺，每一个烂醉如泥的夜晚… 胖子,猴子 … … 四有人说,生活如同剥洋葱,一层一层把它的皮剥去,眼泪就不受控制地往下流. 我觉得记忆更如同剥洋葱,你越不知疲倦的一层一层的剥,眼睛就越承受不住它的报复. &gt;他们都老了吧?他们在哪里呀?我们就这样各自奔天涯 往事如风,君如花,大家都好吗?]]></content>
      <categories>
        <category>散文</category>
      </categories>
      <tags>
        <tag>随想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[土豆和碧月刀]]></title>
    <url>%2F2009%2F03%2F09%2Fpotato-killer%2F</url>
    <content type="text"><![CDATA[夜,月黑风高,古荡湾新村. 夜,静的可怕. “呲呲” 从一个地方传来,这是一间屋子,屋子里自然住着人. 隐没在黑暗里,如同鬼魅,她不是真的黑,别人却叫她牙膏–”黑妹”牙膏. 没有人敢问为什么,因为她有一双手,一双晶莹的纤纤玉手 没有贪婪的目光敢在这双手上游走，因为她手里握着一把刀. 刀,是一把好刀,碧玉七星刀. 窗外吹起了风,云开见月,一缕月光,照到她的脸上. 她,是一个女人,一个敏感的女人,有着一张任何男人都会惊叹的脸. 雪肤,明眸,朱唇,皓齿. 而此时,他站在她面前,她却浑然不知.因为除了碧玉刀,她还握着一个豆,一个土豆. “呲呲”声,就来自刀下的土豆. “你来了”,她没有抬头，仿佛一切都在她的掌握之中. “是” “我原以为你不会来” “我来了” “你不该现在来” “我已经来了” 沉默……男人放下他的外套， “我原本以为已经好了” “还没有” “天已经这么黑了” “正在削” “可我饿太久了” 对视……片刻,她幽幽的叹了口气. “好吧，你要什么” “土豆牛肉” “什么！”她心中一惊，脸上笼了一层寒气. “土──豆──牛──肉！”他缓慢地，却异常清晰地吐出四个字. “是谁告诉你的?” “朋友” “你就这么相信朋友?” “我原来也不太相信，可我现在信了” “为什么” “你的眼睛告诉了我答案” “可是还要牛肉” “我知道” “那你为什么还要” “因为你在这里，牛肉也在桌上” “这么说来你一定要吃” “是” “没有商量的余地？” “是” “能不吃吗” 她抛去一个醉人的笑,足以迷倒十个彪形大汉.她有这个自信,可是这次她失算了,她没看透面对的是一个什么样的人. 在他的眼中,只有土豆. “不能” 沉默,又是沉默… 终于,她又回复了冷静. “好吧,但需要时间” “我会等” 是夜,漆黑一片 夜,静的可怕 “呲呲” 从一个地方传来,这是一间屋子,屋子里,两个人,一把刀,一包土豆…]]></content>
      <categories>
        <category>小说</category>
      </categories>
      <tags>
        <tag>古龙体</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[anonymity]]></title>
    <url>%2F2007%2F05%2F16%2Fanonymity-2007%2F</url>
    <content type="text"><![CDATA[How many days have I lost, how can I get back to the place where I started. I’m outside the house,try to find my way in,but it’s locked,and the blines are down,and I lost the key,I cann’t remember what the rooms look like and where I put anything.And if I dare go inside,i wonder,was I able to find my way out. If I go back to the beginning,i could start it over again,I can go line by line,try to find the order way,I can try to make it,better…]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>咋念</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[绝望中的虚妄(2005)]]></title>
    <url>%2F2005%2F10%2F05%2Fhope-lost%2F</url>
    <content type="text"><![CDATA[世界忘了呼吸 飓风狂妄地吞没了世界 整个的… 忘情地呼啸着 穿透了空间的每一个角落 那凛冽的 从脸孔里直灌入血液 如同千把刃向心脏里钻去 仿佛听到薄冰碎裂的声音 随着脉络的跳动 寒冷一点一点地蚕食掉血肉 终于 叫嚣出崩溃前安静而隆重的一声哀嚎 灵魂上升到苍穹的高度… …… 谁丢掉了呼吸? 就像默然欣赏着一幅恍如隔世的油画 那华丽的生命分裂时悲壮的诀别 然后顷刻间 风 忽然死了 于是垂直的雨水惊心动魄地打落在这个桀骜的生命上 双手合十 似乎感受到灵魂从眼眸里溶化的热度 穹壁上掉下的泪水 完美地交缠于粘稠的血液 一片不规则的血红里盛放着星星点点的水晶 泪水从哪里一直一直地迸涌 两边倾斜的街道疯狂地都向后奔跑 城市里的霓虹灯不断跳动 冷漠地丢开世界最后的一点热度 所有的一切都毫无挽留地向那一端里去 那一端无边的黑暗里去 凝固了的猩红的泪水不断不断地泛滥了世界 被淹没在血腥下的城市 越来越静 越来越静 鸦雀无声… …… 谁的血脉依然在动？ 谁一手扯住了回忆的翅膀？ 那对被模糊了血肉的双手 将溅起的血红都涂抹在白絮一样的因惊恐而颤动的羽翼上 然后将凝聚在眼眸里最后的一点辉煌转化为全身的力量 把羽翼活生生地从记忆上撕裂! 伴随一丝扭曲而狰狞的笑容 血红的玫瑰色遍染天壁 满天的羽毛伴随着苍穹的碎片 翩然地纷纷扬扬… 一起扑向 盛大的死亡]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>虚妄</tag>
        <tag>咋念</tag>
      </tags>
  </entry>
</search>
